{"version":3,"file":"index.js","sources":["../src/transforms.js","../src/helpers.js","../src/selection.js","../src/node.js","../src/table.js"],"sourcesContent":["import { NodeSelection, Selection } from 'prosemirror-state';\nimport { findParentNodeOfType, findPositionOfNodeBefore } from './selection';\nimport {\n  cloneTr,\n  isNodeSelection,\n  replaceNodeAtPos,\n  removeNodeAtPos,\n  canInsert,\n  isEmptyParagraph\n} from './helpers';\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a node of a given `nodeType`. It will return an original transaction if parent node hasn't been found.\n//\n// ```javascript\n// dispatch(\n//   removeParentNodeOfType(schema.nodes.table)(tr)\n// );\n// ```\nexport const removeParentNodeOfType = nodeType => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return removeNodeAtPos(parent.pos)(tr);\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces parent node of a given `nodeType` with the given `content`. It will return an original transaction if either parent node hasn't been found or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n//\n// dispatch(\n//  replaceParentNodeOfType(schema.nodes.table, node)(tr)\n// );\n// ```\nexport const replaceParentNodeOfType = (nodeType, content) => tr => {\n  if (!Array.isArray(nodeType)) {\n    nodeType = [nodeType];\n  }\n  for (let i = 0, count = nodeType.length; i < count; i++) {\n    const parent = findParentNodeOfType(nodeType[i])(tr.selection);\n    if (parent) {\n      const newTr = replaceNodeAtPos(parent.pos, content)(tr);\n      if (newTr !== tr) {\n        return newTr;\n      }\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected node. It will return an original transaction if current selection is not a `NodeSelection`.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedNode(tr)\n// );\n// ```\nexport const removeSelectedNode = tr => {\n  if (isNodeSelection(tr.selection)) {\n    const from = tr.selection.$from.pos;\n    const to = tr.selection.$to.pos;\n    return cloneTr(tr.delete(from, to));\n  }\n  return tr;\n};\n\n// :: (node: ProseMirrorNode) → (tr: Transaction) → Transaction\n// Returns a new transaction that replaces selected node with a given `node`.\n// It will return the original transaction if either current selection is not a NodeSelection or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n// dispatch(\n//   replaceSelectedNode(node)(tr)\n// );\n// ```\nexport const replaceSelectedNode = node => tr => {\n  if (isNodeSelection(tr.selection)) {\n    const { $from, $to } = tr.selection;\n    if (\n      $from.parent.canReplaceWith($from.index(), $from.indexAfter(), node.type)\n    ) {\n      return cloneTr(tr.replaceWith($from.pos, $to.pos, node));\n    }\n  }\n  return tr;\n};\n\n// :: (position: number, dir: ?number) → (tr: Transaction) → Transaction\n// Returns a new transaction that tries to find a valid cursor selection starting at the given `position`\n// and searching back if `dir` is negative, and forward if positive.\n// If a valid cursor position hasn't been found, it will return the original transaction.\n//\n// ```javascript\n// dispatch(\n//   setTextSelection(5)(tr)\n// );\n// ```\nexport const setTextSelection = (position, dir = 1) => tr => {\n  const nextSelection = Selection.findFrom(tr.doc.resolve(position), dir, true);\n  if (nextSelection) {\n    return tr.setSelection(nextSelection);\n  }\n  return tr;\n};\n\n// :: (content: union<ProseMirrorNode, Fragment>, position: ?number) → (tr: Transaction) → Transaction\n// Returns a new transaction that inserts a given `content` at the current cursor position, or at a given `position`, if it is allowed by schema. If schema restricts such nesting, it will try to find an appropriate place for a given node in the document, looping through parent nodes up until the root document node.\n// If cursor is inside of an empty paragraph, it will try to replace that paragraph with the given content. If insertion is successful and inserted node has content, it will set cursor inside of that content.\n// It will return an original transaction if the place for insertion hasn't been found.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   safeInsert(node)(tr)\n// );\n// ```\nexport const safeInsert = (content, position) => tr => {\n  const hasPosition = typeof position === 'number';\n  const { $from } = tr.selection;\n  const $insertPos = hasPosition\n    ? tr.doc.resolve(position)\n    : isNodeSelection(tr.selection)\n      ? tr.doc.resolve($from.pos + 1)\n      : $from;\n  const { parent, depth } = $insertPos;\n\n  // try to replace an empty paragraph\n  if (isEmptyParagraph(parent)) {\n    const oldTr = tr;\n    tr = replaceParentNodeOfType(parent.type, content)(tr);\n    if (oldTr !== tr) {\n      return setTextSelection($insertPos.pos)(tr);\n    }\n  }\n\n  // given node is allowed at the current cursor position\n  if (canInsert($insertPos, content)) {\n    tr.insert($insertPos.pos, content);\n    return cloneTr(\n      setTextSelection(hasPosition ? $insertPos.pos : tr.selection.$anchor.pos)(\n        tr\n      )\n    );\n  }\n\n  // looking for a place in the doc where the node is allowed\n  for (let i = $insertPos.depth; i > 0; i--) {\n    const pos = $insertPos.after(i);\n    const $pos = tr.doc.resolve(pos);\n    if (canInsert($pos, content)) {\n      tr.insert(pos, content);\n      return cloneTr(setTextSelection(tr.mapping.map(pos), -1)(tr));\n    }\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, type: ?union<NodeType, null>, attrs: ?union<Object, null>, marks?: [Mark]) → (tr: Transaction) → Transaction\n// Returns a transaction that changes the type, attributes, and/or marks of the parent node of a given `nodeType`.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   setParentNodeMarkup(schema.nodes.panel, null, { panelType })(tr);\n// );\n// ```\nexport const setParentNodeMarkup = (nodeType, type, attrs, marks) => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return cloneTr(\n      tr.setNodeMarkup(\n        parent.pos - 1,\n        type,\n        Object.assign({}, parent.node.attrs, attrs),\n        marks\n      )\n    );\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets a `NodeSelection` on a parent node of a `given nodeType`.\n//\n// ```javascript\n// dispatch(\n//   selectParentNodeOfType([tableCell, tableHeader])(state.tr)\n// );\n// ```\nexport const selectParentNodeOfType = nodeType => tr => {\n  if (!isNodeSelection(tr.selection)) {\n    const parent = findParentNodeOfType(nodeType)(tr.selection);\n    if (parent) {\n      return cloneTr(\n        tr.setSelection(NodeSelection.create(tr.doc, parent.pos - 1))\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that deletes previous node.\n//\n// ```javascript\n// dispatch(\n//   removeNodeBefore(state.tr)\n// );\n// ```\nexport const removeNodeBefore = tr => {\n  const position = findPositionOfNodeBefore(tr.selection);\n  if (typeof position === 'number') {\n    return removeNodeAtPos(position)(tr);\n  }\n  return tr;\n};\n","import { NodeSelection } from 'prosemirror-state';\nimport { Fragment, Node as PMNode } from 'prosemirror-model';\nimport { setTextSelection } from './transforms';\nimport { findParentNodeClosestToPos } from './selection';\nimport { TableMap } from 'prosemirror-tables';\n\n// :: (selection: Selection) → boolean\n// Checks if current selection is a `NodeSelection`.\n//\n// ```javascript\n// if (isNodeSelection(tr.selection)) {\n//   // ...\n// }\n// ```\nexport const isNodeSelection = selection => {\n  return selection instanceof NodeSelection;\n};\n\n// (nodeType: union<NodeType, [NodeType]>) → boolean\n// Checks if the type a given `node` equals to a given `nodeType`.\nexport const equalNodeType = (nodeType, node) => {\n  return (\n    (Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1) ||\n    node.type === nodeType\n  );\n};\n\n// (tr: Transaction) → Transaction\n// Creates a new transaction object from a given transaction\nexport const cloneTr = tr => {\n  return Object.assign(Object.create(tr), tr).setTime(Date.now());\n};\n\n// (position: number, content: union<ProseMirrorNode, Fragment>) → (tr: Transaction) → Transaction\n// Returns a `replace` transaction that replaces a node at a given position with the given `content`.\n// It will return the original transaction if replacing is not possible.\n// `position` should point at the start of a node in the document.\nexport const replaceNodeAtPos = (position, content) => tr => {\n  const before = position - 1;\n  const node = tr.doc.nodeAt(before);\n  const $pos = tr.doc.resolve(before);\n  if (canReplace($pos, content)) {\n    tr = tr.replaceWith(before, before + node.nodeSize, content);\n    const start = tr.selection.$from.pos - 1;\n    return cloneTr(setTextSelection(Math.max(start, 0), -1)(tr));\n  }\n  return tr;\n};\n\n// ($pos: ResolvedPos, doc: ProseMirrorNode, content: union<ProseMirrorNode, Fragment>, ) → boolean\n// Checks if replacing a node at a given `$pos` inside of the `doc` node with the given `content` is possible.\nexport const canReplace = ($pos, content) => {\n  const index = $pos.index($pos.depth);\n  const indexAfter = $pos.indexAfter($pos.depth);\n  const node = $pos.node($pos.depth);\n  return (\n    node &&\n    node.type.validContent(\n      content instanceof Fragment ? content : Fragment.from(content)\n    )\n  );\n};\n\n// (position: number) → (tr: Transaction) → Transaction\n// Returns a `delete` transaction that removes a node at a given position with the given `node`.\n// `position` should point at the start of a node in the document.\nexport const removeNodeAtPos = position => tr => {\n  const before = position - 1;\n  const node = tr.doc.nodeAt(before);\n  return cloneTr(tr.delete(before, before + node.nodeSize));\n};\n\n// (schema: Schema) → {[key: string]: NodeType}\n// Returns a map where keys are tableRoles and values are NodeTypes.\nexport const tableNodeTypes = schema => {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  });\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n};\n\n// :: ($pos: ResolvedPos, content: union<ProseMirrorNode, Fragment>) → boolean\n// Checks if a given `content` can be inserted at the given `$pos`\n//\n// ```javascript\n// const { selection: { $from } } = state;\n// const node = state.schema.nodes.atom.createChecked();\n// if (canInsert($from, node)) {\n//   // ...\n// }\n// ```\nexport const canInsert = ($pos, content) => {\n  const index = $pos.index();\n\n  if (content instanceof Fragment) {\n    return $pos.parent.canReplace(index, index, content);\n  } else if (content instanceof PMNode) {\n    return $pos.parent.canReplaceWith(index, index, content.type);\n  }\n  return false;\n};\n\n// (node: ProseMirrorNode) → boolean\n// Checks if a given `node` is an empty paragraph\nexport const isEmptyParagraph = node => {\n  return !node || (node.type.name === 'paragraph' && node.nodeSize === 2);\n};\n\n// ($pos: ResolvedPos) → ?{pos: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table node closest to a given `$pos`.\n//\n// ```javascript\n// const table = findTableClosestToPos(state.doc.resolve(10));\n// ```\nconst findTableClosestToPos = $pos => {\n  const predicate = node =>\n    node.type.spec.tableRole && /table/i.test(node.type.spec.tableRole);\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\n// :: ($pos: ResolvedPos) → ?{pos: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table cell or a table header node closest to a given `$pos`.\n//\n// ```javascript\n// const cell = findCellClosestToPos(state.doc.resolve(10));\n// ```\nexport const findCellClosestToPos = $pos => {\n  const predicate = node =>\n    node.type.spec.tableRole && /cell/i.test(node.type.spec.tableRole);\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\n// ($pos: ResolvedPos) → ?{left: number, top: number, right: number, bottom: number}\n// Returns the rectangle spanning a cell closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   findCellRectClosestToPos(state.doc.resolve(10))\n// );\n// ```\nexport const findCellRectClosestToPos = $pos => {\n  const cell = findCellClosestToPos($pos);\n  if (cell) {\n    const table = findTableClosestToPos($pos);\n    const map = TableMap.get(table.node);\n    const cellPos = cell.pos - table.pos - 1;\n    return map.rectBetween(cellPos, cellPos);\n  }\n};\n","import { Selection } from 'prosemirror-state';\nimport { equalNodeType, isNodeSelection } from './helpers';\n\n// :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → ?{pos: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest node and its start position `predicate` returns truthy for.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNode(predicate)(selection);\n// ```\nexport const findParentNode = predicate => selection => {\n  const { $from } = selection;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (predicate(node)) {\n      return {\n        pos: $from.start(i),\n        node\n      };\n    }\n  }\n};\n\n// :: ($pos: ResolvedPos, predicate: (node: ProseMirrorNode) → boolean) → ?{pos: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning the closest node and its start position `predicate` returns truthy for.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNodeClosestToPos(state.doc.resolve(5), predicate);\n// ```\nexport const findParentNodeClosestToPos = ($pos, predicate) => {\n  for (let i = $pos.depth; i > 0; i--) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: $pos.start(i),\n        node\n      };\n    }\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) → boolean, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node `predicate` returns truthy for.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const predicate = node => node.type === schema.nodes.table;\n// const parent = findParentDomRef(predicate, domAtPos)(selection); // <table>\n// ```\nexport const findParentDomRef = (predicate, domAtPos) => selection => {\n  const parent = findParentNode(predicate)(selection);\n  if (parent) {\n    return findDomRefAtPos(parent.pos, domAtPos);\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) → boolean) → (selection: Selection) → boolean\n// Checks if there's a parent node `predicate` returns truthy for.\n//\n// ```javascript\n// if (hasParentNode(node => node.type === schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNode = predicate => selection => {\n  return !!findParentNode(predicate)(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{node: ProseMirrorNode, pos: number}\n// Iterates over parent nodes, returning closest node of a given `nodeType`.\n//\n// ```javascript\n// const parent = findParentNodeOfType(schema.nodes.paragraph)(selection);\n// ```\nexport const findParentNodeOfType = nodeType => selection => {\n  return findParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: ($pos: ResolvedPos, nodeType: union<NodeType, [NodeType]>) → ?{node: ProseMirrorNode, pos: number}\n// Iterates over parent nodes starting from the given `$pos`, returning closest node of a given `nodeType`.\n//\n// ```javascript\n// const parent = findParentNodeOfTypeClosestToPos(state.doc.resolve(10), schema.nodes.paragraph);\n// ```\nexport const findParentNodeOfTypeClosestToPos = ($pos, nodeType) => {\n  return findParentNodeClosestToPos($pos, node =>\n    equalNodeType(nodeType, node)\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → boolean\n// Checks if there's a parent node of a given `nodeType`.\n//\n// ```javascript\n// if (hasParentNodeOfType(schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNodeOfType = nodeType => selection => {\n  return hasParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → (selection: Selection) → ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node of a given `nodeType`.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const parent = findParentDomRefOfType(schema.nodes.codeBlock, domAtPos)(selection); // <pre>\n// ```\nexport const findParentDomRefOfType = (nodeType, domAtPos) => selection => {\n  return findParentDomRef(node => equalNodeType(nodeType, node), domAtPos)(\n    selection\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) → (selection: Selection) → ?{node: ProseMirrorNode, pos: number}\n// Returns a node of a given `nodeType` if it is selected.\n//\n// ```javascript\n// const { extension, inlineExtension, bodiedExtension } = schema.nodes;\n// const selectedNode = findSelectedNodeOfType([\n//   extension,\n//   inlineExtension,\n//   bodiedExtension,\n// ])(selection);\n// ```\nexport const findSelectedNodeOfType = nodeType => selection => {\n  if (isNodeSelection(selection)) {\n    const { node, $from } = selection;\n    if (equalNodeType(nodeType, node)) {\n      return { node, pos: $from.pos };\n    }\n  }\n};\n\n// :: (selection: Selection) → ?number\n// Returns position of the previous node.\n//\n// ```javascript\n// const pos = findPositionOfNodeBefore(tr.selection);\n// ```\nexport const findPositionOfNodeBefore = selection => {\n  const { nodeBefore } = selection.$from;\n  const maybeSelection = Selection.findFrom(selection.$from, -1);\n  if (maybeSelection && nodeBefore) {\n    // leaf node\n    const parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);\n    if (parent) {\n      return parent.pos;\n    }\n    return maybeSelection.$from.pos + 1;\n  }\n};\n\n// :: (position: number, domAtPos: (pos: number) → {node: dom.Node, offset: number}) → dom.Node\n// Returns DOM reference of a node at a given `position`.\n// @see https://github.com/atlassian/prosemirror-utils/issues/8 for more context.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const ref = findDomRefAtPos($from.pos, domAtPos);\n// ```\nexport const findDomRefAtPos = (position, domAtPos) => {\n  const dom = domAtPos(position);\n  if (dom.offset > 0) {\n    return dom.node.childNodes[dom.offset - 1];\n  }\n  return dom.node;\n};\n","// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Flattens descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const children = flatten(node);\n// ```\nexport const flatten = (node, descend = true) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n  const result = [];\n  node.descendants((child, pos) => {\n    result.push({ node: child, pos });\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n};\n\n// :: (node: ProseMirrorNode, predicate: (node: ProseMirrorNode) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findChildren(node, child => child.isText, false);\n// ```\nexport const findChildren = (node, predicate, descend) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n  return flatten(node, descend).filter(child => predicate(child.node));\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns text nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findTextNodes(node);\n// ```\nexport const findTextNodes = (node, descend) => {\n  return findChildren(node, child => child.isText, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns inline nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const inlineNodes = findInlineNodes(node);\n// ```\nexport const findInlineNodes = (node, descend) => {\n  return findChildren(node, child => child.isInline, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Returns block descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const blockNodes = findBlockNodes(node);\n// ```\nexport const findBlockNodes = (node, descend) => {\n  return findChildren(node, child => child.isBlock, descend);\n};\n\n// :: (node: ProseMirrorNode, predicate: (attrs: ?Object) → boolean, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const mergedCells = findChildrenByAttr(table, attrs => attrs.colspan === 2);\n// ```\nexport const findChildrenByAttr = (node, predicate, descend) => {\n  return findChildren(node, child => !!predicate(child.attrs), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes of a given nodeType. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const cells = findChildrenByType(table, schema.nodes.tableCell);\n// ```\nexport const findChildrenByType = (node, nodeType, descend) => {\n  return findChildren(node, child => child.type === nodeType, descend);\n};\n\n// :: (node: ProseMirrorNode, markType: markType, descend: ?boolean) → [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes that have a mark of a given markType. It doesn't descend into a `node` when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const nodes = findChildrenByMark(state.doc, schema.marks.strong);\n// ```\nexport const findChildrenByMark = (node, markType, descend) => {\n  return findChildren(node, child => markType.isInSet(child.marks), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType) → boolean\n// Returns `true` if a given node contains nodes of a given `nodeType`\n//\n// ```javascript\n// if (contains(panel, schema.nodes.listItem)) {\n//   // ...\n// }\n// ```\nexport const contains = (node, nodeType) => {\n  return !!findChildrenByType(node, nodeType).length;\n};\n","import {\n  CellSelection,\n  TableMap,\n  addColumn,\n  addRow,\n  removeColumn,\n  removeRow\n} from 'prosemirror-tables';\nimport { Selection } from 'prosemirror-state';\nimport { Slice } from 'prosemirror-model';\nimport { findParentNode } from './selection';\nimport {\n  cloneTr,\n  tableNodeTypes,\n  findCellRectClosestToPos,\n  findCellClosestToPos\n} from './helpers';\n\n// :: (selection: Selection) → ?{pos: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest table node.\n//\n// ```javascript\n// const table = findTable(selection);\n// ```\nexport const findTable = selection =>\n  findParentNode(\n    node => node.type.spec.tableRole && node.type.spec.tableRole === 'table'\n  )(selection);\n\n// :: (selection: Selection) → boolean\n// Checks if current selection is a `CellSelection`.\n//\n// ```javascript\n// if (isCellSelection(selection)) {\n//   // ...\n// }\n// ```\nexport const isCellSelection = selection => {\n  return selection instanceof CellSelection;\n};\n\n// :: (columnIndex: number) → (selection: Selection) → boolean\n// Checks if entire column at index `columnIndex` is selected.\n//\n// ```javascript\n// const className = isColumnSelected(i)(selection) ? 'selected' : '';\n// ```\nexport const isColumnSelected = columnIndex => selection => {\n  if (isCellSelection(selection)) {\n    const { $anchorCell, $headCell } = selection;\n    const start = $anchorCell.start(-1);\n    const map = TableMap.get($anchorCell.node(-1));\n    const anchor = map.colCount($anchorCell.pos - start);\n    const head = map.colCount($headCell.pos - start);\n\n    return (\n      selection.isColSelection() &&\n      (columnIndex <= Math.max(anchor, head) &&\n        columnIndex >= Math.min(anchor, head))\n    );\n  }\n\n  return false;\n};\n\n// :: (rowIndex: number) → (selection: Selection) → boolean\n// Checks if entire row at index `rowIndex` is selected.\n//\n// ```javascript\n// const className = isRowSelected(i)(selection) ? 'selected' : '';\n// ```\nexport const isRowSelected = rowIndex => selection => {\n  if (isCellSelection(selection)) {\n    const { $anchorCell, $headCell } = selection;\n    const anchor = $anchorCell.index(-1);\n    const head = $headCell.index(-1);\n\n    return (\n      selection.isRowSelection() &&\n      (rowIndex <= Math.max(anchor, head) && rowIndex >= Math.min(anchor, head))\n    );\n  }\n\n  return false;\n};\n\n// :: (selection: Selection) → boolean\n// Checks if entire table is selected\n//\n// ```javascript\n// const className = isTableSelected(selection) ? 'selected' : '';\n// ```\nexport const isTableSelected = selection => {\n  if (isCellSelection(selection)) {\n    return selection.isColSelection() && selection.isRowSelection();\n  }\n\n  return false;\n};\n\n// :: (columnIndex: number) → (selection: Selection) → ?[{ pos: number, node: ProseMirrorNode }]\n// Returns an array of cells in a column at index `columnIndex`.\n//\n// ```javascript\n// const cells = getCellsInColumn(i)(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInColumn = columnIndex => selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex >= 0 && columnIndex <= map.width - 1) {\n      const cells = map.cellsInRect({\n        left: columnIndex,\n        right: columnIndex + 1,\n        top: 0,\n        bottom: map.height\n      });\n      return cells.map(pos => {\n        const node = table.node.nodeAt(pos);\n        return { pos: pos + table.pos + 1, node };\n      });\n    }\n  }\n};\n\n// :: (rowIndex: number) → (selection: Selection) → ?[{ pos: number, node: ProseMirrorNode }]\n// Returns an array of cells in a row at index `rowIndex`.\n//\n// ```javascript\n// const cells = getCellsInRow(i)(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInRow = rowIndex => selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (rowIndex >= 0 && rowIndex <= map.height - 1) {\n      const cells = map.cellsInRect({\n        left: 0,\n        right: map.width,\n        top: rowIndex,\n        bottom: rowIndex + 1\n      });\n      return cells.map(pos => {\n        const node = table.node.nodeAt(pos);\n        return { pos: pos + table.pos + 1, node };\n      });\n    }\n  }\n};\n\n// :: (selection: Selection) → ?[{ pos: number, node: ProseMirrorNode }]\n// Returns an array of all cells in a table.\n//\n// ```javascript\n// const cells = getCellsInTable(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInTable = selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const cells = map.cellsInRect({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    });\n    return cells.map(pos => {\n      const node = table.node.nodeAt(pos);\n      return { pos: pos + table.pos + 1, node };\n    });\n  }\n};\n\n// :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `columnIndex`.\n//\n// ```javascript\n// dispatch(\n//   selectColumn(i)(state.tr)\n// );\n// ```\nexport const selectColumn = columnIndex => tr => {\n  const cells = getCellsInColumn(columnIndex)(tr.selection);\n  if (cells) {\n    const $anchor = tr.doc.resolve(cells[0].pos - 1);\n    const $head = tr.doc.resolve(cells[cells.length - 1].pos - 1);\n    return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n  }\n  return tr;\n};\n\n// :: (rowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `rowIndex`.\n//\n// ```javascript\n// dispatch(\n//   selectRow(i)(state.tr)\n// );\n// ```\nexport const selectRow = rowIndex => tr => {\n  const cells = getCellsInRow(rowIndex)(tr.selection);\n  if (cells) {\n    const $anchor = tr.doc.resolve(cells[0].pos - 1);\n    const $head = tr.doc.resolve(cells[cells.length - 1].pos - 1);\n    return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n  }\n  return tr;\n};\n\n// :: (selection: Selection) → (tr: Transaction) → Transaction\n// Returns a new transaction that creates a `CellSelection` on the entire table.\n//\n// ```javascript\n// dispatch(\n//   selectTable(i)(state.tr)\n// );\n// ```\nexport const selectTable = tr => {\n  const cells = getCellsInTable(tr.selection);\n  if (cells) {\n    const $anchor = tr.doc.resolve(cells[0].pos - 1);\n    const $head = tr.doc.resolve(cells[cells.length - 1].pos - 1);\n    return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n  }\n  return tr;\n};\n\n// :: (cell: {pos: number, node: ProseMirrorNode}, schema: Schema) → (tr: Transaction) → Transaction\n// Returns a new transaction that clears the content of a given `cell`.\n//\n// ```javascript\n// const $pos = state.doc.resolve(13);\n// dispatch(\n//   emptyCell(findCellClosestToPos($pos), state.schema)(state.tr)\n// );\n// ```\nexport const emptyCell = (cell, schema) => tr => {\n  if (cell) {\n    const content = tableNodeTypes(schema).cell.createAndFill().content;\n    if (!cell.node.content.eq(content)) {\n      tr.replaceWith(\n        cell.pos - 1,\n        cell.pos + cell.node.nodeSize - 2,\n        new Slice(content, 0, 0)\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new column at index `columnIndex`.\n//\n// ```javascript\n// dispatch(\n//   addColumnAt(i)(state.tr)\n// );\n// ```\nexport const addColumnAt = columnIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex >= 0 && columnIndex <= map.width) {\n      return cloneTr(\n        addColumn(\n          tr,\n          {\n            map,\n            tableStart: table.pos,\n            table: table.node\n          },\n          columnIndex\n        )\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (rowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that adds a new row at index `rowIndex`.\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i)(state.tr)\n// );\n// ```\nexport const addRowAt = rowIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (rowIndex >= 0 && rowIndex <= map.height) {\n      return cloneTr(\n        addRow(\n          tr,\n          {\n            map,\n            tableStart: table.pos,\n            table: table.node\n          },\n          rowIndex\n        )\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a column at index `columnIndex`. If there is only one column left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeColumnAt(i)(state.tr)\n// );\n// ```\nexport const removeColumnAt = columnIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex === 0 && map.width === 1) {\n      return removeTable(tr);\n    } else if (columnIndex >= 0 && columnIndex <= map.width) {\n      removeColumn(\n        tr,\n        {\n          map,\n          tableStart: table.pos,\n          table: table.node\n        },\n        columnIndex\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (rowIndex: number) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a row at index `rowIndex`. If there is only one row left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeRowAt(i)(state.tr)\n// );\n// ```\nexport const removeRowAt = rowIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (rowIndex === 0 && map.height === 1) {\n      return removeTable(tr);\n    } else if (rowIndex >= 0 && rowIndex <= map.height) {\n      removeRow(\n        tr,\n        {\n          map,\n          tableStart: table.pos,\n          table: table.node\n        },\n        rowIndex\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes a table node if the cursor is inside of it.\n//\n// ```javascript\n// dispatch(\n//   removeTable(state.tr)\n// );\n// ```\nexport const removeTable = tr => {\n  const { $from } = tr.selection;\n  for (let depth = $from.depth; depth > 0; depth--) {\n    let node = $from.node(depth);\n    if (node.type.spec.tableRole === 'table') {\n      return cloneTr(tr.delete($from.before(depth), $from.after(depth)));\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected columns.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedColumns(state.tr)\n// );\n// ```\nexport const removeSelectedColumns = tr => {\n  const { selection } = tr;\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n  if (isCellSelection(selection)) {\n    const table = findTable(selection);\n    if (table) {\n      const map = TableMap.get(table.node);\n      const rect = map.rectBetween(\n        selection.$anchorCell.pos - table.pos,\n        selection.$headCell.pos - table.pos\n      );\n      for (let i = rect.right - 1; i >= rect.left; i--) {\n        tr = removeColumnAt(i)(tr);\n      }\n      return tr;\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) → Transaction\n// Returns a new transaction that removes selected rows.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedRows(state.tr)\n// );\n// ```\nexport const removeSelectedRows = tr => {\n  const { selection } = tr;\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n  if (isCellSelection(selection)) {\n    const table = findTable(selection);\n    if (table) {\n      const map = TableMap.get(table.node);\n      const rect = map.rectBetween(\n        selection.$anchorCell.pos - table.pos,\n        selection.$headCell.pos - table.pos\n      );\n      for (let i = rect.bottom - 1; i >= rect.top; i--) {\n        tr = removeRowAt(i)(tr);\n      }\n      return tr;\n    }\n  }\n  return tr;\n};\n\n// :: ($pos: ResolvedPos) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a column closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeColumnClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\nexport const removeColumnClosestToPos = $pos => tr => {\n  const rect = findCellRectClosestToPos($pos);\n  if (rect) {\n    return removeColumnAt(rect.left)(tr);\n  }\n  return tr;\n};\n\n// :: ($pos: ResolvedPos) → (tr: Transaction) → Transaction\n// Returns a new transaction that removes a row closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeRowClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\nexport const removeRowClosestToPos = $pos => tr => {\n  const rect = findCellRectClosestToPos($pos);\n  if (rect) {\n    return removeRowAt(rect.top)(tr);\n  }\n  return tr;\n};\n\n// :: (columnIndex: number, cellTransform: (cell: { pos: number, node: ProseMirrorNode }) → (tr: Transaction)), setCursorToLastCell: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a column at a given `columnIndex`.\n// It will set the selection into the last cell of the column if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInColumn(0, (cell, tr) => emptyCell(cell, state.schema)(tr))(state.tr)\n// );\n// ```\nexport const forEachCellInColumn = (\n  columnIndex,\n  cellTransform,\n  setCursorToLastCell\n) => tr => {\n  const cells = getCellsInColumn(columnIndex)(tr.selection);\n  if (cells) {\n    for (let i = cells.length - 1; i >= 0; i--) {\n      tr = cellTransform(cells[i], tr);\n    }\n    if (setCursorToLastCell) {\n      const $pos = tr.doc.resolve(\n        tr.mapping.map(cells[cells.length - 1].pos - 1)\n      );\n      tr.setSelection(Selection.near($pos));\n    }\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// :: (rowIndex: number, cellTransform: (cell: { pos: number, node: ProseMirrorNode }) → (tr: Transaction)), setCursorToLastCell: ?boolean) → (tr: Transaction) → Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a row at a given `rowIndex`.\n// It will set the selection into the last cell of the row if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInRow(0, (cell, tr) => setCellAttrs(cell, { background: 'red' })(tr))(state.tr)\n// );\n// ```\nexport const forEachCellInRow = (\n  rowIndex,\n  cellTransform,\n  setCursorToLastCell\n) => tr => {\n  const cells = getCellsInRow(rowIndex)(tr.selection);\n  if (cells) {\n    for (let i = cells.length - 1; i >= 0; i--) {\n      tr = cellTransform(cells[i], tr);\n    }\n    if (setCursorToLastCell) {\n      const $pos = tr.doc.resolve(\n        tr.mapping.map(cells[cells.length - 1].pos - 1)\n      );\n      tr.setSelection(Selection.near($pos));\n    }\n  }\n  return tr;\n};\n\n// :: (cell: { pos: number, node: ProseMirrorNode }, attrs: Object) → (tr: Transaction) → Transaction\n// Returns a new transaction that sets given `attrs` to a given `cell`.\n//\n// ```javascript\n// dispatch(\n//   setCellAttrs(findCellClosestToPos($pos), { background: 'blue' })(tr);\n// );\n// ```\nexport const setCellAttrs = (cell, attrs) => tr => {\n  if (cell) {\n    tr.setNodeMarkup(\n      cell.pos - 1,\n      null,\n      Object.assign({}, cell.node.attrs, attrs)\n    );\n    return cloneTr(tr);\n  }\n  return tr;\n};\n"],"names":["removeParentNodeOfType","parent","findParentNodeOfType","nodeType","tr","selection","removeNodeAtPos","pos","replaceParentNodeOfType","content","Array","isArray","i","count","length","newTr","replaceNodeAtPos","removeSelectedNode","isNodeSelection","from","$from","to","$to","cloneTr","delete","replaceSelectedNode","canReplaceWith","index","indexAfter","node","type","replaceWith","setTextSelection","position","dir","nextSelection","Selection","findFrom","doc","resolve","setSelection","safeInsert","hasPosition","$insertPos","depth","isEmptyParagraph","oldTr","canInsert","insert","$anchor","after","$pos","mapping","map","setParentNodeMarkup","attrs","marks","setNodeMarkup","Object","assign","selectParentNodeOfType","NodeSelection","create","removeNodeBefore","findPositionOfNodeBefore","equalNodeType","indexOf","setTime","Date","now","before","nodeAt","canReplace","nodeSize","start","Math","max","validContent","Fragment","tableNodeTypes","schema","cached","roles","keys","nodes","forEach","spec","tableRole","PMNode","name","findTableClosestToPos","predicate","test","findParentNodeClosestToPos","findCellClosestToPos","findCellRectClosestToPos","cell","table","TableMap","get","cellPos","rectBetween","findParentNode","findParentDomRef","domAtPos","findDomRefAtPos","hasParentNode","findParentNodeOfTypeClosestToPos","hasParentNodeOfType","findParentDomRefOfType","findSelectedNodeOfType","nodeBefore","maybeSelection","dom","offset","childNodes","flatten","descend","Error","result","descendants","child","push","findChildren","filter","findTextNodes","isText","findInlineNodes","isInline","findBlockNodes","isBlock","findChildrenByAttr","findChildrenByType","findChildrenByMark","markType","isInSet","contains","findTable","isCellSelection","CellSelection","isColumnSelected","$anchorCell","$headCell","anchor","colCount","head","isColSelection","columnIndex","min","isRowSelected","isRowSelection","rowIndex","isTableSelected","getCellsInColumn","width","cells","cellsInRect","height","getCellsInRow","getCellsInTable","selectColumn","$head","selectRow","selectTable","emptyCell","createAndFill","eq","Slice","addColumnAt","addColumn","addRowAt","addRow","removeColumnAt","removeTable","removeRowAt","removeSelectedColumns","rect","right","left","removeSelectedRows","bottom","top","removeColumnClosestToPos","removeRowClosestToPos","forEachCellInColumn","cellTransform","setCursorToLastCell","near","forEachCellInRow","setCellAttrs"],"mappings":"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"}