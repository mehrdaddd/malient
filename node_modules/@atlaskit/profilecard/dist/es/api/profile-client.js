import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _Promise from 'babel-runtime/core-js/promise';
import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _extends from 'babel-runtime/helpers/extends';
import 'es6-promise/auto'; // 'whatwg-fetch' needs a Promise polyfill
import 'whatwg-fetch';
import { LRUCache } from 'lru-fast';

/**
 * Transform presence response to atlaskit/avatar compatible presence value
 * @param presenceResponse
 * @returns {string}
 */
var calculatePresence = function calculatePresence(presenceResponse) {
  if (!presenceResponse) {
    return null;
  }

  var state = presenceResponse.state;
  var stateMetadata = presenceResponse.stateMetadata ? JSON.parse(presenceResponse.stateMetadata) : null;

  if (state === 'busy') {
    if (stateMetadata && stateMetadata.focus) {
      state = 'focus';
    }
  }
  return state;
};

/**
 * Transform response from GraphQL
 * - Prefix `timestring` with `remoteWeekdayString` depending on `remoteWeekdayIndex`
 * - Remove properties which will be not used later
 * @ignore
 * @param  {object} response
 * @return {object}
 */
export var modifyResponse = function modifyResponse(response) {
  var presence = calculatePresence(response.Presence);
  var data = _extends({}, response.User, {
    presence: presence,
    presenceMessage: response.Presence && response.Presence.message
  });

  var localWeekdayIndex = new Date().getDay().toString();

  if (data.remoteWeekdayIndex && data.remoteWeekdayIndex !== localWeekdayIndex) {
    data.remoteTimeString = data.remoteWeekdayString + ' ' + data.remoteTimeString;
  }

  data.isCensored = data.isCensored !== 'visible';

  data.timestring = data.remoteTimeString;

  delete data.remoteWeekdayIndex;
  delete data.remoteWeekdayString;
  delete data.remoteTimeString;
  delete data.id;

  return data;
};

var buildHeaders = function buildHeaders() {
  var headers = new Headers();
  headers.append('Content-Type', 'application/json');

  return headers;
};

/**
 * @param  {string} userId
 * @param  {string} cloudId
 * @return {string} GraphQL Query String
 */
var buildUserQuery = function buildUserQuery(cloudId, userId) {
  return {
    query: 'query User($userId: String!, $cloudId: String!) {\n    User: CloudUser(userId: $userId, cloudId: $cloudId) {\n      id,\n      isCurrentUser,\n      isCensored: censoredStatus,\n      isActive: active,\n      isBot,\n      isNotMentionable,\n      fullName,\n      nickname,\n      email,\n      meta: title,\n      location,\n      companyName,\n      avatarUrl(size: 192),\n      remoteWeekdayIndex: localTime(format: "d"),\n      remoteWeekdayString: localTime(format: "ddd"),\n      remoteTimeString: localTime(format: "h:mma"),\n    }\n    Presence: Presence(organizationId: $cloudId, userId: $userId) {\n      state,\n      type,\n      date,\n      stateMetadata,\n      message\n    }\n  }',
    variables: {
      cloudId: cloudId,
      userId: userId
    }
  };
};

/**
* @param {string} serviceUrl - GraphQL service endpoint
* @param {string} userId
* @param {string} cloudId
*/
var requestService = function requestService(serviceUrl, cloudId, userId) {
  var headers = buildHeaders();
  var userQuery = buildUserQuery(cloudId, userId);

  return fetch(new Request(serviceUrl, {
    method: 'POST',
    credentials: 'include',
    mode: 'cors',
    headers: headers,
    body: _JSON$stringify(userQuery)
  })).then(function (response) {
    if (!response.ok) {
      return _Promise.reject({
        code: response.status,
        reason: response.statusText
      });
    }

    return response.json().then(function (json) {
      if (json.errors) {
        return _Promise.reject({
          reason: json.errors[0].category || 'default'
        });
      }

      return modifyResponse(json.data);
    });
  });
};

var ProfileClient = function () {
  /**
   * @param {object} config
   * @param {string} config.url
   * @param {string} [config.cacheSize=10]
   * @param {string} [config.cacheMaxAge=null]
   */
  function ProfileClient(config) {
    _classCallCheck(this, ProfileClient);

    var defaults = {
      cacheSize: 10,
      cacheMaxAge: null
    };

    this.config = _extends({}, defaults, config);
    // Set maxCacheAge only if it's a positive number
    this.cacheMaxAge = Math.max(parseInt(this.config.cacheMaxAge, 10), 0) || null;
    // DIR-474: cap cache at 30 days.
    if (this.cacheMaxAge) {
      this.cacheMaxAge = Math.min(this.cacheMaxAge, 30 * 24 * 60 * 60 * 1000);
    }
    // Only set cache if maxCacheAge is set
    this.cache = this.cacheMaxAge === null ? null : new LRUCache(this.config.cacheSize);
  }

  ProfileClient.prototype.makeRequest = function makeRequest(cloudId, userId) {
    if (!this.config.url) {
      throw new Error('config.url is a required parameter');
    }

    return requestService(this.config.url, cloudId, userId);
  };

  ProfileClient.prototype.setCachedProfile = function setCachedProfile(cloudId, userId, cacheItem) {
    var cacheIdentifier = cloudId + '/' + userId;
    this.cache.put(cacheIdentifier, cacheItem);
  };

  ProfileClient.prototype.getCachedProfile = function getCachedProfile(cloudId, userId) {
    var cacheIdentifier = cloudId + '/' + userId;

    var cached = this.cache && this.cache.get(cacheIdentifier);

    if (!cached) {
      return null;
    }

    if (cached.expire < Date.now()) {
      this.cache.remove(cacheIdentifier);
      return null;
    }

    this.cache.set(cacheIdentifier, {
      expire: Date.now() + this.cacheMaxAge,
      profile: cached.profile
    });

    return cached.profile;
  };

  ProfileClient.prototype.flushCache = function flushCache() {
    if (this.cache) {
      this.cache.removeAll();
    }
  };

  ProfileClient.prototype.getProfile = function getProfile(cloudId, userId) {
    var _this = this;

    if (!cloudId || !userId) {
      return _Promise.reject(new Error('cloudId or userId missing'));
    }

    var cache = this.getCachedProfile(cloudId, userId);

    if (cache) {
      return _Promise.resolve(cache);
    }

    return new _Promise(function (resolve, reject) {
      _this.makeRequest(cloudId, userId).then(function (data) {
        if (_this.cache) {
          _this.setCachedProfile(cloudId, userId, {
            expire: Date.now() + _this.cacheMaxAge,
            profile: data
          });
        }
        resolve(data);
      }).catch(function (error) {
        reject(error);
      });
    });
  };

  return ProfileClient;
}();

export default ProfileClient;