"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var isRetina_1 = require("../utils/isRetina");
var isLinkDetails_1 = require("../utils/isLinkDetails");
var isValidPercentageUnit_1 = require("../utils/isValidPercentageUnit");
var containsPixelUnit_1 = require("../utils/containsPixelUnit");
var cardDimensions_1 = require("../utils/cardDimensions");
var getElementDimension_1 = require("../utils/getElementDimension");
var utils_1 = require("../utils");
// return type is "any" to avoid TS attempting to infer the return type
// if TS attempts to infer the return type it can NOT publish .d.ts files because WithDataURIImpl isn't exported
function withDataURI(Component) {
    var WithDataURIImpl = /** @class */ (function (_super) {
        tslib_1.__extends(WithDataURIImpl, _super);
        function WithDataURIImpl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.state = {};
            _this.setDataURI = function (dataURI) { return _this.setState({ dataURI: dataURI }); };
            _this.clearDataURI = function () { return _this.setState({ dataURI: undefined }); };
            return _this;
        }
        WithDataURIImpl.prototype.componentDidMount = function () {
            this.updateDataURI(this.props);
        };
        WithDataURIImpl.prototype.componentWillReceiveProps = function (nextProps) {
            var _a = this.props, currentDataURIService = _a.dataURIService, currentMetadata = _a.metadata;
            var nextDataURIService = nextProps.dataURIService, nextMetadata = nextProps.metadata;
            if (nextDataURIService !== currentDataURIService ||
                nextMetadata !== currentMetadata) {
                this.updateDataURI(nextProps);
            }
        };
        WithDataURIImpl.prototype.isSmall = function () {
            return this.props.appearance === 'small';
        };
        // No mather if the integrator passed pixels or percentages, this will
        // always return a pixels value that the /image endpoint can use
        WithDataURIImpl.prototype.dataURIDimension = function (dimension) {
            var retinaFactor = isRetina_1.isRetina() ? 2 : 1;
            var dimensionValue = (this.props.dimensions && this.props.dimensions[dimension]) || '';
            if (this.isSmall()) {
                return cardDimensions_1.getCardMinHeight('small') * retinaFactor;
            }
            if (isValidPercentageUnit_1.isValidPercentageUnit(dimensionValue)) {
                return getElementDimension_1.getElementDimension(this, dimension) * retinaFactor;
            }
            if (typeof dimensionValue === 'number') {
                return dimensionValue * retinaFactor;
            }
            if (containsPixelUnit_1.containsPixelUnit("" + dimensionValue)) {
                return parseInt("" + dimensionValue, 10) * retinaFactor;
            }
            return utils_1.defaultImageCardDimensions[dimension] * retinaFactor;
        };
        WithDataURIImpl.prototype.updateDataURI = function (props) {
            var dataURIService = props.dataURIService, metadata = props.metadata, resizeMode = props.resizeMode, appearance = props.appearance;
            var _a = this, setDataURI = _a.setDataURI, clearDataURI = _a.clearDataURI;
            // clear the dataURI if we're updating to undefined metadata or we're updating to a link
            if (!dataURIService || !metadata || isLinkDetails_1.isLinkDetails(metadata)) {
                this.clearDataURI();
                return;
            }
            var width = this.dataURIDimension('width');
            var height = this.dataURIDimension('height');
            var allowAnimated = appearance !== 'small';
            dataURIService
                .fetchImageDataUri({ type: 'file', details: metadata }, {
                width: width,
                height: height,
                mode: resizeMode,
                allowAnimated: allowAnimated,
            })
                .then(setDataURI, clearDataURI);
        };
        WithDataURIImpl.prototype.render = function () {
            var dataURI = this.state.dataURI || this.props.preview;
            var props = tslib_1.__assign({}, this.props);
            delete props.dataURIService;
            var otherProps = tslib_1.__assign({ dataURI: dataURI }, props);
            return React.createElement(Component, tslib_1.__assign({}, otherProps));
        };
        return WithDataURIImpl;
    }(React.Component));
    return WithDataURIImpl;
}
exports.withDataURI = withDataURI;
//# sourceMappingURL=withDataURI.js.map