"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var uuid = require("uuid");
var chunkinator_1 = require("chunkinator");
var media_store_1 = require("./media-store");
var hasherCreator_1 = require("./utils/hashing/hasherCreator");
var hashingFunction = function (blob) {
    return hasherCreator_1.createHasher().hash(blob);
};
var createProbingFunction = function (store) { return function (chunks) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var response, results;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, store.probeChunks(hashedChunks(chunks))];
            case 1:
                response = _a.sent();
                results = response.data.results;
                return [2 /*return*/, Object.values(results).map(function (result) { return result.exists; })];
        }
    });
}); }; };
exports.uploadFile = function (file, config, callbacks) {
    var content = file.content, collection = file.collection, name = file.name, mimeType = file.mimeType;
    var occurrenceKey = uuid.v4();
    var store = new media_store_1.MediaStore(config);
    var deferredUploadId = store
        .createUpload()
        .then(function (response) { return response.data[0].id; });
    var uploadingFunction = function (chunk) {
        return store.uploadChunk(chunk.hash, chunk.blob);
    };
    var offset = 0;
    var processingFunction = function (chunks) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var _a, _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _b = (_a = store).appendChunksToUpload;
                    return [4 /*yield*/, deferredUploadId];
                case 1: return [4 /*yield*/, _b.apply(_a, [_c.sent(), {
                            chunks: hashedChunks(chunks),
                            offset: offset,
                        }])];
                case 2:
                    _c.sent();
                    offset += chunks.length;
                    return [2 /*return*/];
            }
        });
    }); };
    var deferredEmptyFile = store.createFile({ collection: collection, occurrenceKey: occurrenceKey });
    var _a = chunkinator_1.default(content, {
        hashingFunction: hashingFunction,
        hashingConcurrency: 5,
        probingBatchSize: 100,
        chunkSize: 4 * 1024 * 1024,
        uploadingConcurrency: 3,
        uploadingFunction: uploadingFunction,
        probingFunction: createProbingFunction(store),
        processingBatchSize: 1000,
        processingFunction: processingFunction,
    }, {
        onProgress: function (progress) {
            if (callbacks && callbacks.onProgress) {
                callbacks.onProgress(progress);
            }
        },
    }), response = _a.response, cancel = _a.cancel;
    var fileId = Promise.all([
        deferredUploadId,
        deferredEmptyFile,
        response,
    ]).then(function (_a) {
        var uploadId = _a[0], emptyFile = _a[1];
        var fileId = emptyFile.data.id;
        return store
            .createFileFromUpload({ uploadId: uploadId, name: name, mimeType: mimeType }, {
            occurrenceKey: occurrenceKey,
            collection: collection,
            replaceFileId: fileId,
        })
            .then(function () { return fileId; });
    });
    return { deferredFileId: fileId, cancel: cancel };
};
var hashedChunks = function (chunks) { return chunks.map(function (chunk) { return chunk.hash; }); };
//# sourceMappingURL=uploader.js.map