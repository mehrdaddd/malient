"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var util_shared_styles_1 = require("@atlaskit/util-shared-styles");
var spinner_1 = require("@atlaskit/spinner");
var warning_1 = require("@atlaskit/icon/glyph/warning");
var media_ui_1 = require("@atlaskit/media-ui");
var DetailView_1 = require("../DetailView");
var AlertView_1 = require("./AlertView");
var ActionsView_1 = require("./ActionsView");
var Transition_1 = require("./Transition");
var styled_1 = require("./styled");
function minWidth() {
    return 240;
}
exports.minWidth = minWidth;
function maxWidth(_a) {
    var hasPreview = _a.hasPreview;
    return hasPreview ? 400 : 664;
}
exports.maxWidth = maxWidth;
function progress() {
    return {
        actionState: 'pending',
        actionMessage: undefined,
    };
}
function success(message) {
    return {
        actionState: 'success',
        actionMessage: message,
    };
}
function failure(message) {
    return {
        actionState: 'failure',
        actionMessage: message,
    };
}
function dismiss() {
    return {
        actionState: undefined,
        actionMessage: undefined,
    };
}
var CardView = /** @class */ (function (_super) {
    tslib_1.__extends(CardView, _super);
    function CardView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {};
        _this.handleAction = function (action) {
            // store the action so we can try it again later if it fails
            _this.setState({ action: action });
            // prevent the next alert from being cleared by any previous success alerts that haven't already been cleared
            if (_this.timeout) {
                clearTimeout(_this.timeout);
            }
            // handle the action
            action.handler(_this.actionHandlerCallbacks);
        };
        _this.handleTryAgain = function () {
            var action = _this.state.action;
            if (action) {
                action.handler(_this.actionHandlerCallbacks);
            }
        };
        _this.handleCancel = function () {
            _this.setState(dismiss());
        };
        return _this;
    }
    Object.defineProperty(CardView.prototype, "actionHandlerCallbacks", {
        get: function () {
            var _this = this;
            return {
                progress: function () { return _this.setState(progress()); },
                success: function (message) {
                    _this.setState(success(message), function () {
                        // hide the alert after 2s
                        _this.timeout = setTimeout(function () { return _this.setState(dismiss()); }, 2000);
                    });
                },
                failure: function () { return _this.setState(failure('Something went wrong.')); },
            };
        },
        enumerable: true,
        configurable: true
    });
    CardView.prototype.componentWillUnmount = function () {
        // prevent the alert from being cleared and unmounted
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
    };
    CardView.prototype.renderActions = function () {
        var actions = this.props.actions;
        var actionState = this.state.actionState;
        if (actionState === 'pending') {
            return (React.createElement(styled_1.ActionsStateWrapper, null,
                React.createElement(spinner_1.default, { size: "small" })));
        }
        if (actionState === 'failure') {
            return (React.createElement(styled_1.ActionsStateWrapper, null,
                React.createElement(warning_1.default, { size: "medium", label: "", primaryColor: util_shared_styles_1.akColorY300 })));
        }
        return React.createElement(ActionsView_1.default, { actions: actions, onAction: this.handleAction });
    };
    CardView.prototype.renderAlert = function () {
        var _a = this.state, actionState = _a.actionState, actionMessage = _a.actionMessage;
        var visible = (actionState === 'success' || actionState === 'failure') &&
            Boolean(actionMessage);
        var alertType = actionState === 'success' ? 'success' : 'failure';
        return (React.createElement(styled_1.AlertWrapper, null,
            React.createElement(Transition_1.default, { enter: ['fade', 'slide-up'], exit: ['fade', 'slide-down'], timeout: 300 }, visible ? (React.createElement(AlertView_1.default, { type: alertType, message: actionMessage, onTryAgain: this.handleTryAgain, onCancel: this.handleCancel })) : null)));
    };
    CardView.prototype.render = function () {
        var _a = this.props, onClick = _a.onClick, link = _a.link, context = _a.context, title = _a.title, description = _a.description, icon = _a.icon, preview = _a.preview, user = _a.user, users = _a.users, details = _a.details;
        return (React.createElement(media_ui_1.CardFrame, { minWidth: minWidth(), maxWidth: maxWidth({ hasPreview: Boolean(preview) }), href: link, icon: React.createElement(media_ui_1.LinkIcon, { src: context && context.icon }), text: context && context.text, onClick: onClick },
            this.renderAlert(),
            preview ? React.createElement(media_ui_1.CardPreview, { url: preview }) : null,
            React.createElement(DetailView_1.DetailView, { title: title, description: description, icon: icon, user: user, users: users, details: details, actions: this.renderActions() })));
    };
    return CardView;
}(React.Component));
exports.CardView = CardView;
//# sourceMappingURL=index.js.map