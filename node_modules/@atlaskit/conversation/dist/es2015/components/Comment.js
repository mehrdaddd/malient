import * as tslib_1 from "tslib";
import * as React from 'react';
import * as distanceInWordsToNow from 'date-fns/distance_in_words_to_now';
import AkAvatar from '@atlaskit/avatar';
import AkComment, { CommentAuthor, CommentAction, CommentTime, } from '@atlaskit/comment';
import { WithProviders } from '@atlaskit/editor-common';
import { ResourcedReactions } from '@atlaskit/reactions';
import { ReactRenderer } from '@atlaskit/renderer';
import styled from 'styled-components';
import Editor from './Editor';
import CommentContainer from '../containers/Comment';
export var DeletedMessage = function () { return React.createElement("em", null, "Comment deleted by the author"); };
var commentChanged = function (oldComment, newComment) {
    if (oldComment.state !== newComment.state) {
        return true;
    }
    if (oldComment.deleted !== newComment.deleted) {
        return true;
    }
    return false;
};
var Reactions = styled.div(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n  height: 20px;\n  & > div {\n    height: 20px;\n  }\n"], ["\n  height: 20px;\n  & > div {\n    height: 20px;\n  }\n"])));
var Comment = /** @class */ (function (_super) {
    tslib_1.__extends(Comment, _super);
    function Comment(props) {
        var _this = _super.call(this, props) || this;
        _this.dispatch = function (dispatch) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var handler = _this.props[dispatch];
            if (handler) {
                handler.apply(handler, args);
                _this.setState({
                    lastDispatch: { handler: dispatch, args: args },
                });
            }
        };
        _this.onReply = function () {
            _this.setState({
                isReplying: true,
            });
        };
        _this.onSaveReply = function (value) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, conversationId, comment;
            return tslib_1.__generator(this, function (_b) {
                _a = this.props, conversationId = _a.conversationId, comment = _a.comment;
                this.dispatch('onAddComment', conversationId, comment.commentId, value);
                this.setState({
                    isReplying: false,
                });
                return [2 /*return*/];
            });
        }); };
        _this.onCancelReply = function () {
            _this.setState({
                isReplying: false,
            });
        };
        _this.onDelete = function () {
            var _a = _this.props, conversationId = _a.conversationId, comment = _a.comment;
            _this.dispatch('onDeleteComment', conversationId, comment.commentId);
        };
        _this.onEdit = function () {
            _this.setState({
                isEditing: true,
            });
        };
        _this.onSaveEdit = function (value) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, conversationId, comment;
            return tslib_1.__generator(this, function (_b) {
                _a = this.props, conversationId = _a.conversationId, comment = _a.comment;
                this.dispatch('onUpdateComment', conversationId, comment.commentId, value);
                this.setState({
                    isEditing: false,
                });
                return [2 /*return*/];
            });
        }); };
        _this.onCancelEdit = function () {
            _this.setState({
                isEditing: false,
            });
        };
        _this.onRequestCancel = function () {
            var _a = _this.props, comment = _a.comment, onCancel = _a.onCancel;
            // Invoke optional onCancel hook
            if (onCancel) {
                onCancel();
            }
            _this.dispatch('onRevertComment', comment.conversationId, comment.commentId);
        };
        _this.onRequestRetry = function () {
            var lastDispatch = _this.state.lastDispatch;
            var _a = _this.props, onRetry = _a.onRetry, comment = _a.comment;
            if (onRetry && comment.isPlaceholder) {
                return onRetry(comment.localId);
            }
            if (!lastDispatch) {
                return;
            }
            _this.dispatch.apply(_this, [lastDispatch.handler].concat(lastDispatch.args));
        };
        /**
         * Username click handler - pass a User object, returns a handler which will invoke onUserClick with it
         * @param {User} user
         */
        _this.handleUserClick = function (user) { return function () {
            var onUserClick = _this.props.onUserClick;
            if (onUserClick && typeof onUserClick === 'function') {
                onUserClick(user);
            }
        }; };
        _this.handleTimeClick = function () {
            var _a = _this.props, comment = _a.comment, onHighlightComment = _a.onHighlightComment, disableScrollTo = _a.disableScrollTo;
            if (!disableScrollTo && comment && onHighlightComment) {
                onHighlightComment(comment.commentId);
            }
        };
        _this.state = {
            isEditing: false,
        };
        return _this;
    }
    Comment.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var _a = this.state, isEditing = _a.isEditing, isReplying = _a.isReplying;
        var isHighlighted = this.props.isHighlighted;
        if (nextState.isEditing !== isEditing ||
            nextState.isReplying !== isReplying ||
            nextProps.isHighlighted !== isHighlighted) {
            return true;
        }
        if (commentChanged(this.props.comment, nextProps.comment)) {
            return true;
        }
        var _b = this.props.comments, oldComments = _b === void 0 ? [] : _b;
        var _c = nextProps.comments, newComments = _c === void 0 ? [] : _c;
        if (oldComments.length !== newComments.length) {
            return true;
        }
        if (newComments.some(function (newComment) {
            var oldComment = oldComments.filter(function (oldComment) {
                return oldComment.commentId === newComment.commentId ||
                    oldComment.localId === newComment.localId;
            })[0];
            return commentChanged(oldComment, newComment);
        })) {
            return true;
        }
        return false;
    };
    Comment.prototype.getContent = function () {
        var _a = this.props, comment = _a.comment, dataProviders = _a.dataProviders, user = _a.user, renderEditor = _a.renderEditor, disableScrollTo = _a.disableScrollTo, allowFeedbackAndHelpButtons = _a.allowFeedbackAndHelpButtons;
        var isEditing = this.state.isEditing;
        if (comment.deleted) {
            return React.createElement(DeletedMessage, null);
        }
        if (isEditing) {
            return (React.createElement(Editor, { defaultValue: comment.document.adf, isExpanded: true, isEditing: isEditing, onSave: this.onSaveEdit, onCancel: this.onCancelEdit, dataProviders: dataProviders, user: user, renderEditor: renderEditor, disableScrollTo: disableScrollTo, allowFeedbackAndHelpButtons: allowFeedbackAndHelpButtons }));
        }
        return (React.createElement(ReactRenderer, { document: comment.document.adf, dataProviders: dataProviders }));
    };
    Comment.prototype.renderComments = function () {
        var _a = this.props, comments = _a.comments, conversationId = _a.conversationId, user = _a.user, onUserClick = _a.onUserClick, dataProviders = _a.dataProviders, onAddComment = _a.onAddComment, onUpdateComment = _a.onUpdateComment, onDeleteComment = _a.onDeleteComment, onRevertComment = _a.onRevertComment, onHighlightComment = _a.onHighlightComment, onRetry = _a.onRetry, onCancel = _a.onCancel, renderEditor = _a.renderEditor, containerId = _a.containerId, disableScrollTo = _a.disableScrollTo;
        if (!comments || comments.length === 0) {
            return null;
        }
        return comments.map(function (child) { return (React.createElement(CommentContainer, { key: child.localId, comment: child, user: user, conversationId: conversationId, onAddComment: onAddComment, onUpdateComment: onUpdateComment, onDeleteComment: onDeleteComment, onRevertComment: onRevertComment, onHighlightComment: onHighlightComment, onRetry: onRetry, onCancel: onCancel, onUserClick: onUserClick, dataProviders: dataProviders, renderComment: function (props) { return React.createElement(Comment, tslib_1.__assign({}, props)); }, renderEditor: renderEditor, containerId: containerId, disableScrollTo: disableScrollTo })); });
    };
    Comment.prototype.renderEditor = function () {
        var isReplying = this.state.isReplying;
        if (!isReplying) {
            return null;
        }
        var _a = this.props, dataProviders = _a.dataProviders, user = _a.user, renderEditor = _a.renderEditor, disableScrollTo = _a.disableScrollTo, allowFeedbackAndHelpButtons = _a.allowFeedbackAndHelpButtons;
        return (React.createElement(Editor, { isExpanded: true, onCancel: this.onCancelReply, onSave: this.onSaveReply, dataProviders: dataProviders, user: user, renderEditor: renderEditor, disableScrollTo: disableScrollTo, allowFeedbackAndHelpButtons: allowFeedbackAndHelpButtons }));
    };
    Comment.prototype.getActions = function () {
        var _a = this.props, comment = _a.comment, user = _a.user, dataProviders = _a.dataProviders, containerId = _a.containerId;
        var isEditing = this.state.isEditing;
        var canReply = !!user && !isEditing && !comment.deleted;
        if (!canReply) {
            return undefined;
        }
        var createdBy = comment.createdBy, commentAri = comment.commentAri;
        var actions = [
            React.createElement(CommentAction, { key: "reply", onClick: this.onReply }, "Reply"),
        ];
        if (createdBy && user && user.id === createdBy.id) {
            actions = actions.concat([
                React.createElement(CommentAction, { key: "edit", onClick: this.onEdit }, "Edit"),
                React.createElement(CommentAction, { key: "delete", onClick: this.onDelete }, "Delete"),
            ]);
        }
        if (containerId &&
            commentAri &&
            dataProviders &&
            dataProviders.hasProvider('reactionsProvider') &&
            dataProviders.hasProvider('emojiProvider')) {
            actions = actions.concat([
                React.createElement(WithProviders, { key: "reactions", providers: ['emojiProvider', 'reactionsProvider'], providerFactory: dataProviders, renderNode: function (_a) {
                        var emojiProvider = _a.emojiProvider, reactionsProvider = _a.reactionsProvider;
                        return (React.createElement(Reactions, null,
                            React.createElement(ResourcedReactions, { containerAri: containerId, ari: commentAri, emojiProvider: emojiProvider, reactionsProvider: reactionsProvider })));
                    } }),
            ]);
        }
        return actions;
    };
    Comment.prototype.render = function () {
        var _a = this.props, comment = _a.comment, onUserClick = _a.onUserClick, isHighlighted = _a.isHighlighted, disableScrollTo = _a.disableScrollTo;
        var createdBy = comment.createdBy, commentState = comment.state, error = comment.error;
        var errorProps = {};
        if (error) {
            errorProps.actions = [];
            if (error.canRetry) {
                errorProps.actions = [
                    React.createElement(CommentAction, { key: "retry", onClick: this.onRequestRetry }, "Retry"),
                ];
            }
            errorProps.actions = errorProps.actions.concat([
                React.createElement(CommentAction, { key: "cancel", onClick: this.onRequestCancel }, "Cancel"),
            ]);
            errorProps.message = error.message;
        }
        var comments = this.renderComments();
        var editor = this.renderEditor();
        var commentId = disableScrollTo
            ? undefined
            : "comment-" + comment.commentId;
        return (React.createElement(AkComment, { id: commentId, author: 
            // Render with onClick/href if they're supplied
            onUserClick || createdBy.profileUrl ? (React.createElement(CommentAuthor, { onClick: this.handleUserClick(createdBy), href: createdBy.profileUrl || '#' }, createdBy && createdBy.name)) : (
            // Otherwise just render text
            React.createElement(CommentAuthor, null, createdBy && createdBy.name)), avatar: React.createElement(AkAvatar, { src: createdBy && createdBy.avatarUrl, href: createdBy && createdBy.profileUrl, name: createdBy && createdBy.name, enableTooltip: true }), time: React.createElement(CommentTime, { onClick: this.handleTimeClick, href: disableScrollTo ? undefined : "#" + commentId }, distanceInWordsToNow(new Date(comment.createdAt), {
                addSuffix: true,
            })), actions: this.getActions(), content: this.getContent(), isSaving: commentState === 'SAVING', isError: commentState === 'ERROR', errorActions: errorProps.actions, errorIconLabel: errorProps.message, highlighted: isHighlighted }, editor || comments ? (React.createElement("div", null,
            comments,
            editor)) : null));
    };
    return Comment;
}(React.Component));
export default Comment;
var templateObject_1;
//# sourceMappingURL=Comment.js.map