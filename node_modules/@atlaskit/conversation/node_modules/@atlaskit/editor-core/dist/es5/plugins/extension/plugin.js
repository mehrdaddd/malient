"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prosemirror_state_1 = require("prosemirror-state");
var extension_1 = require("./nodeviews/extension");
var prosemirror_utils_1 = require("prosemirror-utils");
var utils_1 = require("../../utils");
exports.pluginKey = new prosemirror_state_1.PluginKey('extensionPlugin');
exports.default = function (dispatch, providerFactory, extensionHandlers) {
    return new prosemirror_state_1.Plugin({
        state: {
            init: function () { return ({
                element: null,
            }); },
            apply: function (tr, state, prevState, nextState) {
                var meta = tr.getMeta(exports.pluginKey);
                if (meta) {
                    var newState = tslib_1.__assign({}, state, meta);
                    dispatch(exports.pluginKey, newState);
                    return newState;
                }
                return state;
            },
        },
        view: function () {
            return {
                update: function (view) {
                    var state = view.state;
                    var element = exports.pluginKey.getState(state).element;
                    var _a = state.schema.nodes, extension = _a.extension, inlineExtension = _a.inlineExtension, bodiedExtension = _a.bodiedExtension;
                    /** Check whether selection has an extension */
                    var selectedExtNode = prosemirror_utils_1.findParentNodeOfType([
                        extension,
                        inlineExtension,
                        bodiedExtension,
                    ])(state.selection);
                    var domAtPos = view.domAtPos.bind(view);
                    var stickToolbarToBottom = true;
                    if (selectedExtNode && selectedExtNode.node.attrs.parameters) {
                        stickToolbarToBottom =
                            typeof selectedExtNode.node.attrs.parameters
                                .stickToolbarToBottom === 'undefined'
                                ? true
                                : selectedExtNode.node.attrs.parameters.stickToolbarToBottom;
                    }
                    var selectedExtDomNode = selectedExtNode &&
                        prosemirror_utils_1.findDomRefAtPos(selectedExtNode.pos, domAtPos);
                    /** If a node is selected, get position of that instead
                     * The check will be refactored once we have isNodeOfTypeSelected from PM-utils
                     */
                    if (state.selection instanceof prosemirror_state_1.NodeSelection &&
                        (state.selection.node.type === state.schema.nodes.bodiedExtension ||
                            state.selection.node.type === state.schema.nodes.extension ||
                            state.selection.node.type === state.schema.nodes.inlineExtension)) {
                        selectedExtNode = {
                            node: state.selection.node,
                            pos: state.selection.$head.pos,
                        };
                        selectedExtDomNode = prosemirror_utils_1.findDomRefAtPos(selectedExtNode.pos, domAtPos);
                    }
                    /** No-op, extensions not even in the picture */
                    if (!selectedExtNode && !element) {
                        return;
                    }
                    var newElement = utils_1.closestElement(selectedExtDomNode, '.extension-container') ||
                        selectedExtDomNode;
                    if (selectedExtNode) {
                        /** Update with new element */
                        if (element !== newElement) {
                            var tr = state.tr.setMeta(exports.pluginKey, { element: newElement });
                            view.dispatch(tr);
                        }
                        /** We still want to re-render the toolbar for any size-adjustments */
                        dispatch(exports.pluginKey, {
                            element: newElement,
                            stickToolbarToBottom: stickToolbarToBottom,
                        });
                    }
                    else if (!selectedExtNode && element !== null) {
                        /** case 2: selection has no extension, but element is alive and kicking */
                        var tr = state.tr.setMeta(exports.pluginKey, { element: null });
                        view.dispatch(tr);
                    }
                },
            };
        },
        key: exports.pluginKey,
        props: {
            nodeViews: {
                extension: extension_1.default(providerFactory, extensionHandlers),
                bodiedExtension: extension_1.default(providerFactory, extensionHandlers),
                inlineExtension: extension_1.default(providerFactory, extensionHandlers),
            },
        },
    });
};
//# sourceMappingURL=plugin.js.map