"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_model_1 = require("prosemirror-model");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_transform_1 = require("prosemirror-transform");
var baseCommand = require("prosemirror-commands");
var baseListCommand = require("prosemirror-schema-list");
var blockTypes = require("../plugins/block-type/types");
var utils_1 = require("../utils");
var hyperlink_1 = require("../plugins/hyperlink");
function setBlockType(view, name) {
    var nodes = view.state.schema.nodes;
    switch (name) {
        case blockTypes.NORMAL_TEXT.name:
            if (nodes.paragraph) {
                return setNormalText()(view.state, view.dispatch);
            }
            break;
        case blockTypes.HEADING_1.name:
            if (nodes.heading) {
                return setHeading(1)(view.state, view.dispatch);
            }
            break;
        case blockTypes.HEADING_2.name:
            if (nodes.heading) {
                return setHeading(2)(view.state, view.dispatch);
            }
            break;
        case blockTypes.HEADING_3.name:
            if (nodes.heading) {
                return setHeading(3)(view.state, view.dispatch);
            }
            break;
        case blockTypes.HEADING_4.name:
            if (nodes.heading) {
                return setHeading(4)(view.state, view.dispatch);
            }
            break;
        case blockTypes.HEADING_5.name:
            if (nodes.heading) {
                return setHeading(5)(view.state, view.dispatch);
            }
            break;
        case blockTypes.HEADING_6.name:
            if (nodes.heading) {
                return setHeading(6)(view.state, view.dispatch);
            }
            break;
    }
    return false;
}
exports.setBlockType = setBlockType;
function setNormalText() {
    return function (state, dispatch) {
        var tr = state.tr, _a = state.selection, $from = _a.$from, $to = _a.$to, schema = state.schema;
        dispatch(tr.setBlockType($from.pos, $to.pos, schema.nodes.paragraph));
        return true;
    };
}
exports.setNormalText = setNormalText;
function setHeading(level) {
    return function (state, dispatch) {
        var tr = state.tr, _a = state.selection, $from = _a.$from, $to = _a.$to, schema = state.schema;
        dispatch(tr.setBlockType($from.pos, $to.pos, schema.nodes.heading, { level: level }));
        return true;
    };
}
exports.setHeading = setHeading;
/**
 * Sometimes a selection in the editor can be slightly offset, for example:
 * it's possible for a selection to start or end at an empty node at the very end of
 * a line. This isn't obvious by looking at the editor and it's likely not what the
 * user intended - so we need to adjust the selection a bit in scenarios like that.
 */
function adjustSelectionInList(doc, selection) {
    var $from = selection.$from, $to = selection.$to;
    var isSameLine = $from.pos === $to.pos;
    if (isSameLine) {
        $from = doc.resolve($from.start($from.depth));
        $to = doc.resolve($from.end($from.depth));
    }
    var startPos = $from.pos;
    var endPos = $to.pos;
    if (isSameLine && startPos === doc.nodeSize - 3) {
        // Line is empty, don't do anything
        return selection;
    }
    // Selection started at the very beginning of a line and therefor points to the previous line.
    if ($from.nodeBefore && !isSameLine) {
        startPos++;
        var node = doc.nodeAt(startPos);
        while (!node || (node && !node.isText)) {
            startPos++;
            node = doc.nodeAt(startPos);
        }
    }
    if (endPos === startPos) {
        return new prosemirror_state_1.TextSelection(doc.resolve(startPos));
    }
    return new prosemirror_state_1.TextSelection(doc.resolve(startPos), doc.resolve(endPos));
}
exports.adjustSelectionInList = adjustSelectionInList;
function preventDefault() {
    return function (state, dispatch) {
        return true;
    };
}
exports.preventDefault = preventDefault;
function toggleList(listType) {
    return function (state, dispatch, view) {
        dispatch(state.tr.setSelection(adjustSelectionInList(state.doc, state.selection)));
        state = view.state;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        var parent = $from.node(-2);
        var grandgrandParent = $from.node(-3);
        var isRangeOfSingleType = utils_1.isRangeOfType(state.doc, $from, $to, state.schema.nodes[listType]);
        if (((parent && parent.type === state.schema.nodes[listType]) ||
            (grandgrandParent &&
                grandgrandParent.type === state.schema.nodes[listType])) &&
            isRangeOfSingleType) {
            // Untoggles list
            return liftListItems()(state, dispatch);
        }
        else {
            // Wraps selection in list and converts list type e.g. bullet_list -> ordered_list if needed
            if (!isRangeOfSingleType) {
                liftListItems()(state, dispatch);
                state = view.state;
            }
            return wrapInList(state.schema.nodes[listType])(state, dispatch);
        }
    };
}
exports.toggleList = toggleList;
function toggleBulletList() {
    return toggleList('bulletList');
}
exports.toggleBulletList = toggleBulletList;
function toggleOrderedList() {
    return toggleList('orderedList');
}
exports.toggleOrderedList = toggleOrderedList;
function wrapInList(nodeType) {
    return baseCommand.autoJoin(baseListCommand.wrapInList(nodeType), function (before, after) { return before.type === after.type && before.type === nodeType; });
}
exports.wrapInList = wrapInList;
function liftListItems() {
    return function (state, dispatch) {
        var tr = state.tr;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        tr.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {
            // Following condition will ensure that block types paragraph, heading, codeBlock, blockquote, panel are lifted.
            // isTextblock is true for paragraph, heading, codeBlock.
            if (node.isTextblock ||
                node.type.name === 'blockquote' ||
                node.type.name === 'panel') {
                var sel = new prosemirror_state_1.NodeSelection(tr.doc.resolve(tr.mapping.map(pos)));
                var range = sel.$from.blockRange(sel.$to);
                if (!range || sel.$from.parent.type !== state.schema.nodes.listItem) {
                    return false;
                }
                var target = range && prosemirror_transform_1.liftTarget(range);
                if (target === undefined || target === null) {
                    return false;
                }
                tr.lift(range, target);
            }
        });
        dispatch(tr);
        return true;
    };
}
exports.liftListItems = liftListItems;
function insertBlockType(name) {
    return function (state, dispatch) {
        var nodes = state.schema.nodes;
        switch (name) {
            case blockTypes.BLOCK_QUOTE.name:
                if (nodes.paragraph && nodes.blockquote) {
                    return wrapSelectionIn(nodes.blockquote)(state, dispatch);
                }
                break;
            case blockTypes.CODE_BLOCK.name:
                if (nodes.codeBlock) {
                    return insertCodeBlock()(state, dispatch);
                }
                break;
            case blockTypes.PANEL.name:
                if (nodes.panel && nodes.paragraph) {
                    return wrapSelectionIn(nodes.panel)(state, dispatch);
                }
                break;
        }
        return false;
    };
}
exports.insertBlockType = insertBlockType;
/**
 * Function will add wraping node.
 * 1. If currently selected blocks can be wrapped in the warpper type it will wrap them.
 * 2. If current block can not be wrapped inside wrapping block it will create a new block below selection,
 *  and set selection on it.
 */
function wrapSelectionIn(type) {
    return function (state, dispatch) {
        var tr = state.tr;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        var paragraph = state.schema.nodes.paragraph;
        var range = $from.blockRange($to);
        var wrapping = range && prosemirror_transform_1.findWrapping(range, type);
        if (range && wrapping) {
            tr.wrap(range, wrapping).scrollIntoView();
        }
        else {
            tr.replaceRangeWith($to.pos, $to.pos, type.createAndFill({}, paragraph.create()));
            tr.setSelection(prosemirror_state_1.Selection.near(tr.doc.resolve(state.selection.to + 1)));
        }
        dispatch(tr);
        return true;
    };
}
/**
 * Function will insert code block at current selection if block is empty or below current selection and set focus on it.
 */
function insertCodeBlock() {
    return function (state, dispatch) {
        var tr = state.tr;
        var $to = state.selection.$to;
        var codeBlock = state.schema.nodes.codeBlock;
        var moveSel = $to.node($to.depth).textContent ? 1 : 0;
        tr.replaceRangeWith($to.pos, $to.pos, codeBlock.createAndFill());
        tr.setSelection(prosemirror_state_1.Selection.near(tr.doc.resolve(state.selection.to + moveSel)));
        dispatch(tr);
        return true;
    };
}
exports.insertCodeBlock = insertCodeBlock;
function showLinkPanel() {
    return function (state, dispatch, view) {
        var pluginState = hyperlink_1.hyperlinkPluginKey.getState(state);
        return pluginState.showLinkPanel(view);
    };
}
exports.showLinkPanel = showLinkPanel;
function insertNewLine() {
    return function (state, dispatch) {
        var $from = state.selection.$from;
        var parent = $from.parent;
        var hardBreak = state.schema.nodes.hardBreak;
        if (hardBreak) {
            var hardBreakNode = hardBreak.create();
            if (parent && parent.type.validContent(prosemirror_model_1.Fragment.from(hardBreakNode))) {
                dispatch(state.tr.replaceSelectionWith(hardBreakNode));
                return true;
            }
        }
        if (state.selection instanceof prosemirror_state_1.TextSelection) {
            dispatch(state.tr.insertText('\n'));
            return true;
        }
        return false;
    };
}
exports.insertNewLine = insertNewLine;
function insertRule() {
    return function (state, dispatch) {
        var to = state.selection.to;
        var rule = state.schema.nodes.rule;
        if (rule) {
            var ruleNode = rule.create();
            dispatch(state.tr.insert(to + 1, ruleNode));
            return true;
        }
        return false;
    };
}
exports.insertRule = insertRule;
function indentList() {
    return function (state, dispatch) {
        var listItem = state.schema.nodes.listItem;
        var $from = state.selection.$from;
        if ($from.node(-1).type === listItem) {
            return baseListCommand.sinkListItem(listItem)(state, dispatch);
        }
        return false;
    };
}
exports.indentList = indentList;
function outdentList() {
    return function (state, dispatch) {
        var listItem = state.schema.nodes.listItem;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        if ($from.node(-1).type === listItem) {
            // if we're backspacing at the start of a list item, unindent it
            // take the the range of nodes we might be lifting
            var range = $from.blockRange($to, function (node) { return node.childCount > 0 && node.firstChild.type === listItem; });
            if (!range) {
                return false;
            }
            var tr_1;
            if (baseListCommand.liftListItem(listItem)(state, function (liftTr) { return (tr_1 = liftTr); })) {
                /* we now need to handle the case that we lifted a sublist out,
                  * and any listItems at the current level get shifted out to
                  * their own new list; e.g.:
                  *
                  * unorderedList
                  *  listItem(A)
                  *  listItem
                  *    unorderedList
                  *      listItem(B)
                  *  listItem(C)
                  *
                  * becomes, after unindenting the first, top level listItem, A:
                  *
                  * content of A
                  * unorderedList
                  *  listItem(B)
                  * unorderedList
                  *  listItem(C)
                  *
                  * so, we try to merge these two lists if they're of the same type, to give:
                  *
                  * content of A
                  * unorderedList
                  *  listItem(B)
                  *  listItem(C)
                  */
                var $start = state.doc.resolve(range.start);
                var $end = state.doc.resolve(range.end);
                var $join = tr_1.doc.resolve(tr_1.mapping.map(range.end - 1));
                if ($join.nodeBefore &&
                    $join.nodeAfter &&
                    $join.nodeBefore.type === $join.nodeAfter.type) {
                    if ($end.nodeAfter &&
                        $end.nodeAfter.type === listItem &&
                        $end.parent.type === $start.parent.type) {
                        tr_1.join($join.pos);
                    }
                }
                dispatch(tr_1.scrollIntoView());
                return true;
            }
        }
        return false;
    };
}
exports.outdentList = outdentList;
function shouldAppendParagraphAfterBlockNode(state) {
    return ((utils_1.atTheEndOfDoc(state) && utils_1.atTheBeginningOfBlock(state)) || utils_1.isTableCell(state));
}
exports.shouldAppendParagraphAfterBlockNode = shouldAppendParagraphAfterBlockNode;
function insertNodesEndWithNewParagraph(nodes) {
    return function (state, dispatch) {
        var tr = state.tr, schema = state.schema;
        var paragraph = schema.nodes.paragraph;
        if (shouldAppendParagraphAfterBlockNode(state)) {
            nodes.push(paragraph.create());
        }
        tr.replaceSelection(new prosemirror_model_1.Slice(prosemirror_model_1.Fragment.from(nodes), 0, 0));
        dispatch(tr);
        return true;
    };
}
exports.insertNodesEndWithNewParagraph = insertNodesEndWithNewParagraph;
function createNewParagraphAbove(state, dispatch) {
    var append = false;
    if (!utils_1.canMoveUp(state) && canCreateParagraphNear(state)) {
        createParagraphNear(append)(state, dispatch);
        return true;
    }
    return false;
}
exports.createNewParagraphAbove = createNewParagraphAbove;
function createNewParagraphBelow(state, dispatch) {
    var append = true;
    if (!utils_1.canMoveDown(state) && canCreateParagraphNear(state)) {
        createParagraphNear(append)(state, dispatch);
        return true;
    }
    return false;
}
exports.createNewParagraphBelow = createNewParagraphBelow;
function canCreateParagraphNear(state) {
    var $from = state.selection.$from;
    var node = $from.node($from.depth);
    var insideCodeBlock = !!node && node.type === state.schema.nodes.codeBlock;
    var isNodeSelection = state.selection instanceof prosemirror_state_1.NodeSelection;
    return $from.depth > 1 || isNodeSelection || insideCodeBlock;
}
function createParagraphNear(append) {
    if (append === void 0) { append = true; }
    return function (state, dispatch) {
        var paragraph = state.schema.nodes.paragraph;
        if (!paragraph) {
            return false;
        }
        var insertPos;
        if (state.selection instanceof prosemirror_state_1.TextSelection) {
            if (topLevelNodeIsEmptyTextBlock(state)) {
                return false;
            }
            insertPos = getInsertPosFromTextBlock(state, append);
        }
        else {
            insertPos = getInsertPosFromNonTextBlock(state, append);
        }
        var tr = state.tr.insert(insertPos, paragraph.createAndFill());
        tr.setSelection(prosemirror_state_1.TextSelection.create(tr.doc, insertPos + 1));
        dispatch(tr);
        return true;
    };
}
exports.createParagraphNear = createParagraphNear;
function getInsertPosFromTextBlock(state, append) {
    var _a = state.selection, $from = _a.$from, $to = _a.$to;
    var pos;
    if (!append) {
        pos = $from.start(0);
    }
    else {
        pos = $to.end(0);
    }
    return pos;
}
function getInsertPosFromNonTextBlock(state, append) {
    var _a = state.selection, $from = _a.$from, $to = _a.$to;
    var nodeAtSelection = state.selection instanceof prosemirror_state_1.NodeSelection &&
        state.doc.nodeAt(state.selection.$anchor.pos);
    var isMediaSelection = nodeAtSelection && nodeAtSelection.type.name === 'mediaGroup';
    var pos;
    if (!append) {
        // The start position is different with text block because it starts from 0
        pos = $from.start($from.depth);
        // The depth is different with text block because it starts from 0
        pos = $from.depth > 0 && !isMediaSelection ? pos - 1 : pos;
    }
    else {
        pos = $to.end($to.depth);
        pos = $to.depth > 0 && !isMediaSelection ? pos + 1 : pos;
    }
    return pos;
}
function topLevelNodeIsEmptyTextBlock(state) {
    var topLevelNode = state.selection.$from.node(1);
    return (topLevelNode.isTextblock &&
        topLevelNode.type !== state.schema.nodes.codeBlock &&
        topLevelNode.nodeSize === 2);
}
exports.removeEmptyHeadingAtStartOfDocument = function (state, dispatch) {
    var $cursor = state.selection.$cursor;
    if ($cursor &&
        !$cursor.nodeBefore &&
        !$cursor.nodeAfter &&
        $cursor.pos === 1) {
        if ($cursor.parent.type === state.schema.nodes.heading) {
            return setNormalText()(state, dispatch);
        }
    }
    return false;
};
function createParagraphAtEnd() {
    return function (state, dispatch) {
        var doc = state.doc, tr = state.tr, nodes = state.schema.nodes;
        if (doc.lastChild &&
            !(doc.lastChild.type === nodes.paragraph &&
                doc.lastChild.content.size === 0)) {
            tr.insert(doc.content.size, nodes.paragraph.createAndFill());
        }
        tr.setSelection(prosemirror_state_1.TextSelection.create(tr.doc, tr.doc.content.size - 1));
        tr.scrollIntoView();
        dispatch(tr);
        return true;
    };
}
exports.createParagraphAtEnd = createParagraphAtEnd;
//# sourceMappingURL=index.js.map