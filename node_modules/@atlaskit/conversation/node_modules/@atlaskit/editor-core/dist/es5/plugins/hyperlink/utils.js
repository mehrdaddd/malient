"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_model_1 = require("prosemirror-model");
var LinkifyIt = require("linkify-it");
exports.LINK_REGEXP = /(https?|ftp):\/\/[^\s]+/;
var linkify = LinkifyIt();
linkify.add('sourcetree:', 'http:');
var tlds = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');
var tlds2Char = 'a[cdefgilmnoqrtuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrtuvwxyz]|n[acefgilopruz]|om|p[aefghkmnrtw]|qa|r[eosuw]|s[abcdegijklmnrtuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';
tlds.push(tlds2Char);
linkify.tlds(tlds, false);
function getLinkMatch(str) {
    if (!str) {
        return null;
    }
    var match = exports.linkifyMatch(str);
    if (!match.length) {
        match = linkify.match(str);
    }
    return match && match[0];
}
exports.getLinkMatch = getLinkMatch;
/**
 * Instance of class LinkMatcher are used in autoformatting in place of Regex.
 * Hence it has been made similar to regex with an exec method.
 * Extending it directly from class Regex was introducing some issues, thus that has been avoided.
 */
var LinkMatcher = /** @class */ (function () {
    function LinkMatcher() {
    }
    LinkMatcher.prototype.exec = function (str) {
        if (str.endsWith(' ')) {
            var chunks = str.slice(0, str.length - 1).split(' ');
            var lastChunk = chunks[chunks.length - 1];
            var links = linkify.match(lastChunk);
            if (links && links.length > 0) {
                var lastLink = links[links.length - 1];
                lastLink.input = lastChunk;
                lastLink.length = lastLink.lastIndex - lastLink.index + 1;
                return [lastLink];
            }
        }
        return null;
    };
    return LinkMatcher;
}());
exports.LinkMatcher = LinkMatcher;
/**
 * Adds protocol to url if needed.
 */
function normalizeUrl(url) {
    if (exports.LINK_REGEXP.test(url)) {
        return url;
    }
    var match = getLinkMatch(url);
    return (match && match.url) || url;
}
exports.normalizeUrl = normalizeUrl;
function linkifyContent(schema, slice) {
    var fragment = linkinfyFragment(schema, slice.content);
    if (fragment) {
        return new prosemirror_model_1.Slice(fragment, slice.openStart, slice.openEnd);
    }
}
exports.linkifyContent = linkifyContent;
function linkinfyFragment(schema, fragment) {
    var linkified = [];
    var _loop_1 = function (i, len) {
        var child = fragment.child(i);
        if (child.type === schema.nodes.table) {
            return { value: void 0 };
        }
        if (child.isText) {
            var text = child.textContent;
            var link_1 = child.type.schema.marks['link'];
            var matches = findLinkMatches(text);
            var pos_1 = 0;
            matches.forEach(function (match) {
                if (match.start > 0) {
                    linkified.push(child.cut(pos_1, match.start));
                }
                linkified.push(child
                    .cut(match.start, match.end)
                    .mark(link_1
                    .create({ href: normalizeUrl(match.href) })
                    .addToSet(child.marks)));
                pos_1 = match.end;
            });
            if (pos_1 < text.length) {
                linkified.push(child.cut(pos_1));
            }
        }
        else {
            linkified.push(child.copy(linkinfyFragment(schema, child.content)));
        }
    };
    for (var i = 0, len = fragment.childCount; i < len; i++) {
        var state_1 = _loop_1(i, len);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return prosemirror_model_1.Fragment.fromArray(linkified);
}
function findLinkMatches(text) {
    var matches = [];
    var linkMatches = text && linkify.match(text);
    if (linkMatches && linkMatches.length > 0) {
        linkMatches.forEach(function (match) {
            matches.push({
                start: match.index,
                end: match.lastIndex,
                title: match.raw,
                href: match.url,
            });
        });
    }
    return matches;
}
exports.linkifyMatch = function (text) {
    var matches = [];
    if (!exports.LINK_REGEXP.test(text)) {
        return matches;
    }
    var startpos = 0;
    var substr;
    while ((substr = text.substr(startpos))) {
        var link = (substr.match(exports.LINK_REGEXP) || [''])[0];
        if (link) {
            var index = substr.search(exports.LINK_REGEXP);
            var start = index >= 0 ? index + startpos : index;
            var end = start + link.length;
            matches.push({
                index: start,
                lastIndex: end,
                raw: link,
                url: link,
                text: link,
                schema: '',
            });
            startpos += end;
        }
        else {
            break;
        }
    }
    return matches;
};
//# sourceMappingURL=utils.js.map