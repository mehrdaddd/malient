"use strict";
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prosemirror_transform_1 = require("prosemirror-transform");
var editor_common_1 = require("@atlaskit/editor-common");
var service_1 = require("../../../analytics/service");
var input_rules_1 = require("../../../utils/input-rules");
var media_common_1 = require("./media-common");
exports.insertLinks = function (view, stateManager, handleMediaState, linkRanges, linkCreateContext, collection) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var state, $to, trQueue;
    return tslib_1.__generator(this, function (_a) {
        if (!linkRanges || linkRanges.length <= 0 || !collection) {
            return [2 /*return*/];
        }
        state = view.state;
        $to = state.selection.$to;
        if (editor_common_1.unsupportedNodeTypesForMediaCards.has($to.parent.type.name)) {
            service_1.default.trackEvent('atlassian.editor.media.file.unsupported.node');
            return [2 /*return*/];
        }
        trQueue = new Array();
        return [2 /*return*/, Promise.all(linkRanges.map(function (_a) {
                var href = _a.href, pos = _a.pos;
                return new Promise(function (resolve) {
                    var state = view.state, dispatch = view.dispatch;
                    var posAtTheEndOfDoc = state.doc.nodeSize - 4;
                    var tr = state.tr;
                    var id = "temporary:" + input_rules_1.uuid() + ":" + href;
                    var node = state.schema.nodes.media.create({
                        id: id,
                        type: 'link',
                        collection: collection,
                    });
                    stateManager.on(id, handleMediaState);
                    // If there's multiple replace steps, make sure subsequent transactions are mapped onto new positions
                    trQueue.forEach(function (tr) { return (pos = tr.mapping.map(pos)); });
                    var $latestPos = tr.doc.resolve(pos > posAtTheEndOfDoc ? posAtTheEndOfDoc : pos);
                    var insertPos = media_common_1.posOfMediaGroupBelow(state, $latestPos, false) ||
                        media_common_1.posOfParentMediaGroup(state, $latestPos, false) ||
                        media_common_1.endPositionForMedia(state, $latestPos);
                    // Insert an empty paragraph in case we've reached the end of the document
                    if (insertPos === state.doc.nodeSize - 2) {
                        tr.insert(insertPos, state.schema.nodes.paragraph.create());
                    }
                    tr.replaceWith(insertPos, insertPos, node);
                    trQueue.push(tr);
                    dispatch(tr);
                    service_1.default.trackEvent('atlassian.editor.media.link');
                    var updateStateWithError = function (error) {
                        return stateManager.updateState(id, {
                            id: id,
                            status: 'error',
                            error: error,
                        }) || resolve();
                    };
                    var isAppWithoutURL = function (metadata) {
                        return metadata &&
                            metadata.resources &&
                            metadata.resources.app &&
                            !metadata.resources.app.url;
                    };
                    // Unfurl URL using media API
                    linkCreateContext
                        .getUrlPreviewProvider(href)
                        .observable()
                        .subscribe(function (metadata) {
                        // Workaround for problem with missing fields preventing Twitter links from working
                        if (isAppWithoutURL(metadata)) {
                            metadata.resources.app.url = metadata.url;
                        }
                        linkCreateContext
                            .addLinkItem(href, collection, metadata)
                            .then(function (publicId) {
                            return stateManager.updateState(id, {
                                id: id,
                                publicId: publicId,
                                status: 'ready',
                            }) || resolve(publicId);
                        })
                            .catch(updateStateWithError);
                    }, updateStateWithError);
                });
            }))];
    });
}); };
exports.detectLinkRangesInSteps = function (tr, link, offset) {
    return tr.steps.reduce(function (linkRanges, step) {
        var rangeWithUrls;
        if (step instanceof prosemirror_transform_1.AddMarkStep) {
            rangeWithUrls = findRangesWithUrlsInAddMarkStep(step, link);
        }
        else if (step instanceof prosemirror_transform_1.ReplaceStep) {
            rangeWithUrls = findRangesWithUrlsInReplaceStep(step, link, offset);
        }
        return linkRanges.concat(rangeWithUrls || []);
    }, []);
};
var findRangesWithUrlsInAddMarkStep = function (step, link) {
    var mark = step.mark; // TODO: Stop using internal API
    if (link.isInSet([mark]) && mark.attrs.href) {
        return [
            {
                href: mark.attrs.href,
                pos: step.from,
            },
        ];
    }
};
var findRangesWithUrlsInReplaceStep = function (step, link, offset) {
    var urls = new Array();
    step.slice.content.descendants(function (child, pos, parent) {
        // TODO: Stop using internal API
        var linkMark = link.isInSet(child.marks);
        if (linkMark && linkMark.attrs.href) {
            urls.push({
                href: linkMark.attrs.href,
                pos: pos + offset,
            });
        }
    });
    return urls;
};
//# sourceMappingURL=media-links.js.map