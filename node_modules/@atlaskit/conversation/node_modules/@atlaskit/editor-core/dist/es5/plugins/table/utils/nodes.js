"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_model_1 = require("prosemirror-model");
var prosemirror_tables_1 = require("prosemirror-tables");
var prosemirror_utils_1 = require("prosemirror-utils");
exports.createTableNode = function (rows, columns, schema) {
    var _a = schema.nodes, table = _a.table, tableRow = _a.tableRow, tableCell = _a.tableCell, tableHeader = _a.tableHeader;
    var rowNodes = [];
    for (var i = 0; i < rows; i++) {
        var cell = i === 0 ? tableHeader : tableCell;
        var cellNodes = [];
        for (var j = 0; j < columns; j++) {
            cellNodes.push(cell.createAndFill());
        }
        rowNodes.push(tableRow.create(undefined, prosemirror_model_1.Fragment.from(cellNodes)));
    }
    return table.create(undefined, prosemirror_model_1.Fragment.from(rowNodes));
};
exports.isIsolating = function (node) {
    return !!node.type.spec.isolating;
};
exports.canInsertTable = function (state) {
    var $from = state.selection.$from, _a = state.schema, code = _a.marks.code, codeBlock = _a.nodes.codeBlock;
    for (var i = $from.depth; i > 0; i--) {
        var node = $from.node(i);
        // inline code and codeBlock are excluded
        if (node.type === codeBlock ||
            (code && $from.marks().some(function (mark) { return mark.type === code; }))) {
            return false;
        }
    }
    return true;
};
exports.containsTable = function (state, slice) {
    var table = state.schema.nodes.table;
    var contains = false;
    slice.content.forEach(function (node) {
        if (node.type === table) {
            contains = true;
        }
    });
    return contains;
};
exports.containsTableHeader = function (state, table) {
    var tableHeader = state.schema.nodes.tableHeader;
    var contains = false;
    table.content.forEach(function (row) {
        if (row.firstChild.type === tableHeader) {
            contains = true;
        }
    });
    return contains;
};
exports.checkIfHeaderRowEnabled = function (state) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (!table) {
        return false;
    }
    var map = prosemirror_tables_1.TableMap.get(table.node);
    for (var i = 0; i < map.width; i++) {
        var cell = table.node.nodeAt(map.map[i]);
        if (cell && cell.type !== state.schema.nodes.tableHeader) {
            return false;
        }
    }
    return true;
};
exports.checkIfHeaderColumnEnabled = function (state) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (!table) {
        return false;
    }
    var map = prosemirror_tables_1.TableMap.get(table.node);
    for (var i = 0; i < map.height; i++) {
        // if number column is enabled, second column becomes header (next to the number column)
        var column = table.node.attrs.isNumberColumnEnabled ? 1 : 0;
        var cell = table.node.nodeAt(map.map[column + i * map.width]);
        if (cell && cell.type !== state.schema.nodes.tableHeader) {
            return false;
        }
    }
    return true;
};
exports.checkIfNumberColumnEnabled = function (state) {
    var table = prosemirror_utils_1.findTable(state.selection);
    return !!(table && table.node.attrs.isNumberColumnEnabled);
};
//# sourceMappingURL=nodes.js.map