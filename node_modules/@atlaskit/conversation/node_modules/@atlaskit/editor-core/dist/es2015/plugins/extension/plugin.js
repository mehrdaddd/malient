import * as tslib_1 from "tslib";
import { Plugin, PluginKey, NodeSelection } from 'prosemirror-state';
import ExtensionNodeView from './nodeviews/extension';
import { findParentNodeOfType, findDomRefAtPos } from 'prosemirror-utils';
import { closestElement } from '../../utils';
export var pluginKey = new PluginKey('extensionPlugin');
export default function (dispatch, providerFactory, extensionHandlers) {
    return new Plugin({
        state: {
            init: function () { return ({
                element: null,
            }); },
            apply: function (tr, state, prevState, nextState) {
                var meta = tr.getMeta(pluginKey);
                if (meta) {
                    var newState = tslib_1.__assign({}, state, meta);
                    dispatch(pluginKey, newState);
                    return newState;
                }
                return state;
            },
        },
        view: function () {
            return {
                update: function (view) {
                    var state = view.state;
                    var element = pluginKey.getState(state).element;
                    var _a = state.schema.nodes, extension = _a.extension, inlineExtension = _a.inlineExtension, bodiedExtension = _a.bodiedExtension;
                    /** Check whether selection has an extension */
                    var selectedExtNode = findParentNodeOfType([
                        extension,
                        inlineExtension,
                        bodiedExtension,
                    ])(state.selection);
                    var domAtPos = view.domAtPos.bind(view);
                    var stickToolbarToBottom = true;
                    if (selectedExtNode && selectedExtNode.node.attrs.parameters) {
                        stickToolbarToBottom =
                            typeof selectedExtNode.node.attrs.parameters
                                .stickToolbarToBottom === 'undefined'
                                ? true
                                : selectedExtNode.node.attrs.parameters.stickToolbarToBottom;
                    }
                    var selectedExtDomNode = selectedExtNode &&
                        findDomRefAtPos(selectedExtNode.pos, domAtPos);
                    /** If a node is selected, get position of that instead
                     * The check will be refactored once we have isNodeOfTypeSelected from PM-utils
                     */
                    if (state.selection instanceof NodeSelection &&
                        (state.selection.node.type === state.schema.nodes.bodiedExtension ||
                            state.selection.node.type === state.schema.nodes.extension ||
                            state.selection.node.type === state.schema.nodes.inlineExtension)) {
                        selectedExtNode = {
                            node: state.selection.node,
                            pos: state.selection.$head.pos,
                        };
                        selectedExtDomNode = findDomRefAtPos(selectedExtNode.pos, domAtPos);
                    }
                    /** No-op, extensions not even in the picture */
                    if (!selectedExtNode && !element) {
                        return;
                    }
                    var newElement = closestElement(selectedExtDomNode, '.extension-container') ||
                        selectedExtDomNode;
                    if (selectedExtNode) {
                        /** Update with new element */
                        if (element !== newElement) {
                            var tr = state.tr.setMeta(pluginKey, { element: newElement });
                            view.dispatch(tr);
                        }
                        /** We still want to re-render the toolbar for any size-adjustments */
                        dispatch(pluginKey, {
                            element: newElement,
                            stickToolbarToBottom: stickToolbarToBottom,
                        });
                    }
                    else if (!selectedExtNode && element !== null) {
                        /** case 2: selection has no extension, but element is alive and kicking */
                        var tr = state.tr.setMeta(pluginKey, { element: null });
                        view.dispatch(tr);
                    }
                },
            };
        },
        key: pluginKey,
        props: {
            nodeViews: {
                extension: ExtensionNodeView(providerFactory, extensionHandlers),
                bodiedExtension: ExtensionNodeView(providerFactory, extensionHandlers),
                inlineExtension: ExtensionNodeView(providerFactory, extensionHandlers),
            },
        },
    });
};
//# sourceMappingURL=plugin.js.map