import * as tslib_1 from "tslib";
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import TableComponent from './TableComponent';
import ContentNodeView from '../../../nodeviews/contentNodeView';
import { parseDOMColumnWidths } from '../utils';
import { akEditorFullPageMaxWidth } from '@atlaskit/editor-common';
var TableView = /** @class */ (function (_super) {
    tslib_1.__extends(TableView, _super);
    function TableView(props) {
        var _this = _super.call(this, props.node, props.view, 'tbody') || this;
        _this.props = props;
        _this.node = props.node;
        _this.domRef = document.createElement('div');
        _this.render();
        return _this;
    }
    Object.defineProperty(TableView.prototype, "dom", {
        get: function () {
            return this.domRef;
        },
        enumerable: true,
        configurable: true
    });
    TableView.prototype.update = function (node, decorations) {
        if (node.attrs.isNumberColumnEnabled !==
            this.node.attrs.isNumberColumnEnabled ||
            node.type !== this.node.type) {
            return false;
        }
        this.node = node;
        this.render();
        return true;
    };
    TableView.prototype.render = function () {
        var _this = this;
        ReactDOM.render(React.createElement(TableComponent, tslib_1.__assign({}, this.props, { node: this.node, contentDOM: this.handleRef })), this.domRef, function () {
            // When we get a table with an 'auto' attribute, we want to:
            // 1. render with table-layout: auto
            // 2. capture the column widths
            // 3. set the column widths as attributes, and remove the 'auto' attribute,
            //    so the table renders the same, but is now fixed-width
            //
            // This can be used to migrate table appearances from other sources that are
            // usually rendered with 'auto'.
            //
            // We use this when migrating TinyMCE tables for Confluence, for example:
            // https://pug.jira-dev.com/wiki/spaces/AEC/pages/3362882215/How+do+we+map+TinyMCE+tables+to+Fabric+tables
            var _a = _this.props.view, state = _a.state, dispatch = _a.dispatch;
            var tr = state.tr;
            if (_this.node.attrs.__autoSize) {
                var basePos_1 = _this.props.getPos();
                if (typeof basePos_1 === 'undefined') {
                    return;
                }
                var colWidths_1 = parseDOMColumnWidths(_this.contentDOM);
                // overflow tables require all columns to be fixed width
                var tableWidth = colWidths_1.dividedWidths.reduce(function (sum, val) { return sum + val; }, 0);
                var isOverflowTable_1 = tableWidth > akEditorFullPageMaxWidth;
                _this.node.forEach(function (rowNode, rowOffset, i) {
                    rowNode.forEach(function (colNode, colOffset, j) {
                        var pos = rowOffset + colOffset + basePos_1 + 2;
                        tr.setNodeMarkup(pos, undefined, tslib_1.__assign({}, colNode.attrs, { colwidth: colWidths_1
                                .width(j, colNode.attrs.colspan, !isOverflowTable_1)
                                .map(Math.round) }));
                    });
                });
                // clear autosizing on the table node
                tr.setNodeMarkup(basePos_1, undefined, tslib_1.__assign({}, _this.node.attrs, { __autoSize: false }));
                dispatch(tr.setMeta('addToHistory', false));
            }
        });
    };
    TableView.prototype.ignoreMutation = function (record) {
        return true;
    };
    TableView.prototype.destroy = function () {
        ReactDOM.unmountComponentAtNode(this.domRef);
        this.domRef = null;
    };
    return TableView;
}(ContentNodeView));
export default TableView;
//# sourceMappingURL=table.js.map