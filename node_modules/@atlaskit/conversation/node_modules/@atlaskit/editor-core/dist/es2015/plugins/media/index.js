import * as tslib_1 from "tslib";
import * as React from 'react';
import { media, mediaGroup, mediaSingle } from '@atlaskit/editor-common';
import { nodeViewFactory } from '../../nodeviews';
import WithPluginState from '../../ui/WithPluginState';
import { pluginKey as widthPluginKey } from '../width';
import { stateKey as pluginKey, createPlugin, DefaultMediaStateManager, } from './pm-plugins/main';
import keymapMediaSinglePlugin from './pm-plugins/keymap-media-single';
import keymapPlugin from './pm-plugins/keymap';
import ToolbarMedia from './ui/ToolbarMedia';
import MediaSingleEdit from './ui/MediaSingleEdit';
import ReactMediaGroupNode from './nodeviews/media-group';
import ReactMediaNode from './nodeviews/media';
import ReactMediaSingleNode from './nodeviews/media-single';
export { DefaultMediaStateManager, };
var mediaPlugin = function (options) { return ({
    nodes: function () {
        return [
            { name: 'mediaGroup', node: mediaGroup, rank: 1700 },
            { name: 'mediaSingle', node: mediaSingle, rank: 1750 },
            { name: 'media', node: media, rank: 1800 },
        ].filter(function (node) {
            var _a = options || {}, _b = _a.allowMediaGroup, allowMediaGroup = _b === void 0 ? true : _b, _c = _a.allowMediaSingle, allowMediaSingle = _c === void 0 ? false : _c;
            if (node.name === 'mediaGroup') {
                return allowMediaGroup;
            }
            if (node.name === 'mediaSingle') {
                return allowMediaSingle;
            }
            return true;
        });
    },
    pmPlugins: function () {
        return [
            {
                rank: 1200,
                plugin: function (_a) {
                    var schema = _a.schema, props = _a.props, dispatch = _a.dispatch, eventDispatcher = _a.eventDispatcher, providerFactory = _a.providerFactory, errorReporter = _a.errorReporter;
                    return createPlugin(schema, {
                        providerFactory: providerFactory,
                        nodeViews: {
                            mediaGroup: nodeViewFactory(providerFactory, {
                                mediaGroup: ReactMediaGroupNode,
                                media: ReactMediaNode,
                            }),
                            mediaSingle: nodeViewFactory(providerFactory, {
                                mediaSingle: function (_a) {
                                    var view = _a.view, node = _a.node, props = tslib_1.__rest(_a, ["view", "node"]);
                                    return (React.createElement(WithPluginState, { editorView: view, eventDispatcher: eventDispatcher, plugins: {
                                            width: widthPluginKey,
                                        }, render: function (_a) {
                                            var width = _a.width;
                                            return (React.createElement(ReactMediaSingleNode, tslib_1.__assign({ view: view, node: node, width: width }, props)));
                                        } }));
                                },
                                media: ReactMediaNode,
                            }),
                        },
                        errorReporter: errorReporter,
                        uploadErrorHandler: props.uploadErrorHandler,
                        waitForMediaUpload: props.waitForMediaUpload,
                        customDropzoneContainer: options && options.customDropzoneContainer,
                        customMediaPicker: options && options.customMediaPicker,
                    }, dispatch, props.appearance);
                },
            },
            { rank: 1220, plugin: function (_a) {
                    var schema = _a.schema;
                    return keymapPlugin(schema);
                } },
        ].concat(options && options.allowMediaSingle
            ? {
                rank: 1250,
                plugin: function (_a) {
                    var schema = _a.schema;
                    return keymapMediaSinglePlugin(schema);
                },
            }
            : []);
    },
    contentComponent: function (_a) {
        var editorView = _a.editorView;
        if (!options) {
            return null;
        }
        var allowMediaSingle = options.allowMediaSingle;
        var disableLayout;
        if (typeof allowMediaSingle === 'object') {
            disableLayout = allowMediaSingle.disableLayout;
        }
        if ((typeof allowMediaSingle === 'boolean' && allowMediaSingle === false) ||
            (typeof disableLayout === 'boolean' && disableLayout === true)) {
            return null;
        }
        var pluginState = pluginKey.getState(editorView.state);
        return React.createElement(MediaSingleEdit, { pluginState: pluginState });
    },
    secondaryToolbarComponent: function (_a) {
        var editorView = _a.editorView, disabled = _a.disabled;
        return (React.createElement(ToolbarMedia, { editorView: editorView, pluginKey: pluginKey, isDisabled: disabled, isReducedSpacing: true }));
    },
}); };
export default mediaPlugin;
//# sourceMappingURL=index.js.map