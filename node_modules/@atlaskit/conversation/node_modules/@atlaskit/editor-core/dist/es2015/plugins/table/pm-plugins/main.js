import * as tslib_1 from "tslib";
import { Plugin, PluginKey, Selection, TextSelection, } from 'prosemirror-state';
import { deleteTable, deleteColumn, deleteRow, TableMap, toggleHeaderRow, } from 'prosemirror-tables';
import { findTable, findParentDomRefOfType, findParentNodeOfType, selectRow, hasParentNodeOfType, } from 'prosemirror-utils';
import { DecorationSet } from 'prosemirror-view';
import { isElementInTableCell, setNodeSelection, isLastItemMediaGroup, closestElement, } from '../../../utils/';
import { analyticsService } from '../../../analytics';
import TableNode from '../nodeviews/table';
import { resetHoverSelection, clearSelection } from '../actions';
import { isHeaderRowSelected, getCellSelection, createControlsDecorationSet, getSelectedColumn, getSelectedRow, containsTableHeader, canInsertTable, } from '../utils';
var TableState = /** @class */ (function () {
    function TableState(state, eventDispatcher, pluginConfig) {
        var _this = this;
        this.editorFocused = false;
        this.tableHidden = false;
        this.tableDisabled = false;
        this.tableActive = false;
        this.set = DecorationSet.empty;
        this.allowColumnResizing = false;
        this.allowMergeCells = false;
        this.allowNumberColumn = false;
        this.allowBackgroundColor = false;
        this.allowHeaderRow = false;
        this.allowHeaderColumn = false;
        this.stickToolbarToBottom = false;
        this.isHeaderRowRequired = false;
        this.removeTable = function () {
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            deleteTable(state, dispatch);
            _this.focusEditor();
            analyticsService.trackEvent('atlassian.editor.format.table.delete.button');
        };
        this.remove = function () {
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            var cellSelection = getCellSelection(state);
            if (!cellSelection) {
                return;
            }
            var tableNode = cellSelection.$anchorCell.node(-1);
            var isRowSelected = cellSelection.isRowSelection();
            var isColumnSelected = cellSelection.isColSelection();
            // the whole table
            if (isRowSelected && isColumnSelected) {
                deleteTable(state, dispatch);
                _this.focusEditor();
                analyticsService.trackEvent('atlassian.editor.format.table.delete.button');
            }
            else if (isColumnSelected) {
                analyticsService.trackEvent('atlassian.editor.format.table.delete_column.button');
                // move the cursor in the column to the left of the deleted column(s)
                var map = TableMap.get(tableNode);
                var _b = getSelectedColumn(_this.view.state), anchor = _b.anchor, head = _b.head;
                var column = Math.min(anchor, head);
                var nextPos = map.positionAt(0, column > 0 ? column - 1 : 0, tableNode);
                deleteColumn(state, dispatch);
                _this.moveCursorTo(nextPos);
            }
            else if (isRowSelected) {
                var _c = _this.view.state.schema.nodes, tableHeader = _c.tableHeader, tableCell = _c.tableCell;
                var parent_1 = findParentNodeOfType([tableHeader, tableCell])(_this.view.state.selection);
                var event_1 = parent_1 && parent_1.node.type === tableHeader
                    ? 'delete_header_row'
                    : 'delete_row';
                analyticsService.trackEvent("atlassian.editor.format.table." + event_1 + ".button");
                var headerRowSelected = isHeaderRowSelected(_this.view.state);
                // move the cursor to the beginning of the next row, or prev row if deleted row was the last row
                var _d = getSelectedRow(_this.view.state), anchor = _d.anchor, head = _d.head;
                var map = TableMap.get(tableNode);
                var minRow = Math.min(anchor, head);
                var maxRow = Math.max(anchor, head);
                var isRemovingLastRow = maxRow === map.height - 1;
                deleteRow(state, dispatch);
                if (headerRowSelected && _this.isHeaderRowRequired) {
                    _this.convertFirstRowToHeader();
                }
                var nextPos = map.positionAt(isRemovingLastRow ? minRow - 1 : minRow, 0, tableNode);
                _this.moveCursorTo(nextPos);
            }
        };
        this.convertFirstRowToHeader = function () {
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            dispatch(selectRow(0)(state.tr));
            toggleHeaderRow(state, dispatch);
        };
        this.isRequiredToAddHeader = function () { return _this.isHeaderRowRequired; };
        this.addHeaderToTableNodes = function (slice, selectionStart) {
            var table = _this.view.state.schema.nodes.table;
            slice.content.forEach(function (node, offset) {
                if (node.type === table && !containsTableHeader(_this.view.state, node)) {
                    var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
                    var tr = state.tr, doc = state.doc;
                    var $anchor = doc.resolve(selectionStart + offset);
                    dispatch(tr.setSelection(new TextSelection($anchor)));
                    _this.convertFirstRowToHeader();
                }
            });
        };
        this.setTableLayout = function (layout) {
            var tableNode = findTable(_this.view.state.selection);
            if (!tableNode) {
                return false;
            }
            var _a = _this.view.state, schema = _a.schema, tr = _a.tr;
            _this.view.dispatch(tr.setNodeMarkup(tableNode.pos - 1, schema.nodes.table, tslib_1.__assign({}, tableNode.node.attrs, { layout: layout })));
            _this.tableLayout = layout;
            return true;
        };
        this.isLayoutSupported = function () {
            var _a = _this.view.state, selection = _a.selection, schema = _a.schema;
            return (!hasParentNodeOfType(schema.nodes.layoutSection)(selection) &&
                !hasParentNodeOfType(schema.nodes.bodiedExtension)(selection));
        };
        var _a = state.schema.nodes, table = _a.table, tableCell = _a.tableCell, tableRow = _a.tableRow, tableHeader = _a.tableHeader;
        this.tableHidden = !table || !tableCell || !tableRow || !tableHeader;
        this.isHeaderRowRequired = !!pluginConfig.isHeaderRowRequired;
        this.allowColumnResizing = !!pluginConfig.allowColumnResizing;
        this.allowMergeCells = !!pluginConfig.allowMergeCells;
        this.allowNumberColumn = !!pluginConfig.allowNumberColumn;
        this.allowBackgroundColor = !!pluginConfig.allowBackgroundColor;
        this.allowHeaderRow = !!pluginConfig.allowHeaderRow;
        this.allowHeaderColumn = !!pluginConfig.allowHeaderColumn;
        this.stickToolbarToBottom = !!pluginConfig.stickToolbarToBottom;
        this.eventDispatcher = eventDispatcher;
        this.permittedLayouts = pluginConfig.permittedLayouts || [];
    }
    TableState.prototype.updateEditorFocused = function (editorFocused) {
        this.editorFocused = editorFocused;
    };
    TableState.prototype.update = function () {
        var controlsDirty = this.updateSelection();
        var state = this.view.state;
        var table = state.schema.nodes.table, selection = state.selection;
        var domAtPos = this.view.domAtPos.bind(this.view);
        var parent = findParentDomRefOfType(table, domAtPos)(selection);
        var tableElement = parent ? parent.parentNode : undefined;
        if (tableElement !== this.tableElement) {
            this.tableElement = tableElement;
        }
        var tableNode = findTable(state.selection);
        if (tableNode && tableNode.node !== this.tableNode) {
            this.tableNode = tableNode.node;
            controlsDirty = true;
        }
        var tableActive = this.editorFocused && !!tableElement;
        if (tableActive !== this.tableActive) {
            this.tableActive = tableActive;
            controlsDirty = true;
        }
        var tableDisabled = !canInsertTable(state);
        if (tableDisabled !== this.tableDisabled) {
            this.tableDisabled = tableDisabled;
        }
        if (tableNode) {
            var tableLayout = tableNode.node.attrs.layout;
            if (tableLayout !== this.tableLayout) {
                this.tableLayout = tableLayout;
                controlsDirty = true;
            }
        }
        if (controlsDirty) {
            this.view.dispatch(state.tr.setMeta(stateKey, {
                set: tableActive ? createControlsDecorationSet(this.view) : null,
            }));
        }
        return controlsDirty;
    };
    TableState.prototype.setView = function (view) {
        this.view = view;
    };
    // we keep track of selection changes because
    // 1) we want to mark toolbar buttons as active when the whole row/col is selected
    // 2) we want to drop selection if editor looses focus
    TableState.prototype.updateSelection = function () {
        var _a = this.view, state = _a.state, dispatch = _a.dispatch;
        var cellSelection = getCellSelection(state);
        if (cellSelection) {
            if (cellSelection !== this.cellSelection) {
                this.cellSelection = cellSelection;
                return true;
            }
            // drop selection if editor looses focus
            if (!this.editorFocused) {
                clearSelection(state, dispatch);
                return true;
            }
        }
        else if (this.cellSelection) {
            this.cellSelection = undefined;
            return true;
        }
        return false;
    };
    TableState.prototype.focusEditor = function () {
        if (!this.view.hasFocus()) {
            this.view.focus();
        }
    };
    TableState.prototype.moveCursorInsideTableTo = function (pos) {
        this.focusEditor();
        var tr = this.view.state.tr;
        tr.setSelection(Selection.near(tr.doc.resolve(pos)));
        this.view.dispatch(tr);
    };
    TableState.prototype.moveCursorTo = function (pos) {
        var table = findTable(this.view.state.selection);
        if (table) {
            this.moveCursorInsideTableTo(pos + table.pos);
        }
    };
    return TableState;
}());
export { TableState };
export var stateKey = new PluginKey('tablePlugin');
export var createPlugin = function (dispatch, eventDispatcher, pluginConfig) {
    return new Plugin({
        state: {
            init: function (config, state) {
                return new TableState(state, eventDispatcher, pluginConfig);
            },
            apply: function (tr, state) {
                var meta = tr.getMeta(stateKey);
                if (meta) {
                    state.set = meta.set || DecorationSet.empty;
                    return state;
                }
                return state;
            },
        },
        key: stateKey,
        view: function (editorView) {
            var pluginState = stateKey.getState(editorView.state);
            pluginState.setView(editorView);
            return {
                update: function (view, prevState) {
                    var dirty = pluginState.update();
                    if (dirty) {
                        dispatch(stateKey, tslib_1.__assign({}, pluginState));
                    }
                },
            };
        },
        props: {
            decorations: function (state) { return stateKey.getState(state).set; },
            nodeViews: {
                table: function (node, view, getPos) {
                    var allowColumnResizing = stateKey.getState(view.state).allowColumnResizing;
                    return new TableNode({
                        node: node,
                        view: view,
                        allowColumnResizing: allowColumnResizing,
                        eventDispatcher: eventDispatcher,
                        getPos: getPos,
                    });
                },
            },
            handleClick: function (view, pos, event) {
                resetHoverSelection(view.state, view.dispatch);
                return false;
            },
            handleDOMEvents: {
                focus: function (view, event) {
                    var pluginState = stateKey.getState(view.state);
                    pluginState.updateEditorFocused(true);
                    var dirty = pluginState.update();
                    if (dirty) {
                        dispatch(stateKey, tslib_1.__assign({}, pluginState));
                    }
                    return false;
                },
                click: function (view, event) {
                    var element = event.target;
                    var table = findTable(view.state.selection);
                    /**
                     * Check if the table cell with an image is clicked
                     * and its not the image itself
                     */
                    var matches = element.matches ? 'matches' : 'msMatchesSelector';
                    if (!table ||
                        !isElementInTableCell(element) ||
                        element[matches]('table .image, table p, table .image div')) {
                        return false;
                    }
                    var map = TableMap.get(table.node);
                    /** Getting the offset of current item clicked */
                    var colElement = (closestElement(element, 'td') ||
                        closestElement(element, 'th'));
                    var colIndex = colElement && colElement.cellIndex;
                    var rowElement = closestElement(element, 'tr');
                    var rowIndex = rowElement && rowElement.rowIndex;
                    var cellIndex = map.width * rowIndex + colIndex;
                    var posInTable = map.map[cellIndex + 1] - 1;
                    var dispatch = view.dispatch, _a = view.state, tr = _a.tr, paragraph = _a.schema.nodes.paragraph;
                    var editorElement = table.node.nodeAt(map.map[cellIndex]);
                    /** Only if the last item is media group, insert a paragraph */
                    if (isLastItemMediaGroup(editorElement)) {
                        tr.insert(posInTable + table.pos, paragraph.create());
                        dispatch(tr);
                        setNodeSelection(view, posInTable + table.pos);
                    }
                    return true;
                },
                blur: function (view, event) {
                    var pluginState = stateKey.getState(view.state);
                    pluginState.updateEditorFocused(false);
                    var dirty = pluginState.update();
                    if (dirty) {
                        dispatch(stateKey, tslib_1.__assign({}, pluginState));
                    }
                    resetHoverSelection(view.state, view.dispatch);
                    return false;
                },
            },
        },
    });
};
//# sourceMappingURL=main.js.map