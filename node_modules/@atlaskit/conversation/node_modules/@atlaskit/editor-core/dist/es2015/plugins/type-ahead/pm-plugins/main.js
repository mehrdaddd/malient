import * as tslib_1 from "tslib";
import { Plugin, PluginKey } from 'prosemirror-state';
import { dismissCommand } from '../commands/dismiss';
import { itemsListUpdated } from '../commands/items-list-updated';
import { isQueryActive } from '../utils/is-query-active';
export var pluginKey = new PluginKey('typeAheadPlugin');
export var ACTIONS = {
    SELECT_PREV: 'SELECT_PREV',
    SELECT_NEXT: 'SELECT_NEXT',
    SELECT_CURRENT: 'SELECT_CURRENT',
    ITEMS_LIST_UPDATED: 'ITEMS_LIST_UPDATED',
};
export function createInitialPluginState(prevActiveState) {
    if (prevActiveState === void 0) { prevActiveState = false; }
    return {
        active: false,
        prevActiveState: prevActiveState,
        query: '',
        trigger: null,
        typeAheadHandler: null,
        currentIndex: 0,
        items: [],
        itemsLoader: null,
    };
}
export function createPlugin(dispatch, typeAhead) {
    return new Plugin({
        key: pluginKey,
        state: {
            init: function () {
                return createInitialPluginState();
            },
            apply: function (tr, pluginState, oldState, state) {
                var action = (tr.getMeta(pluginKey) || {}).action;
                switch (action) {
                    case ACTIONS.SELECT_PREV:
                        return selectPrevActionHandler({ dispatch: dispatch, pluginState: pluginState, tr: tr });
                    case ACTIONS.SELECT_NEXT:
                        return selectNextActionHandler({ dispatch: dispatch, pluginState: pluginState, tr: tr });
                    case ACTIONS.ITEMS_LIST_UPDATED:
                        return itemsListUpdatedActionHandler({ dispatch: dispatch, pluginState: pluginState, tr: tr });
                    case ACTIONS.SELECT_CURRENT:
                        return selectCurrentActionHandler({ dispatch: dispatch, pluginState: pluginState, tr: tr });
                    default:
                        return defaultActionHandler({
                            dispatch: dispatch,
                            typeAhead: typeAhead,
                            state: state,
                            pluginState: pluginState,
                        });
                }
            },
        },
        view: function () {
            return {
                update: function (editorView) {
                    var pluginState = pluginKey.getState(editorView.state);
                    if (!pluginState) {
                        return;
                    }
                    var dispatch = editorView.dispatch;
                    var state = editorView.state;
                    var doc = state.doc, selection = state.selection;
                    var from = selection.from, to = selection.to;
                    var typeAheadQuery = state.schema.marks.typeAheadQuery;
                    // Disable type ahead query when removing trigger.
                    if (pluginState.active && !pluginState.query) {
                        var nodeBefore = selection.$from.nodeBefore;
                        if (nodeBefore && !(nodeBefore.text || '').replace(/\s/g, '')) {
                            dismissCommand()(state, dispatch);
                            return;
                        }
                    }
                    // Optimization to not call dismissCommand if plugin is in an inactive state.
                    if (!pluginState.active && pluginState.prevActiveState) {
                        if (!doc.rangeHasMark(from - 1, to, typeAheadQuery)) {
                            dismissCommand()(state, dispatch);
                            return;
                        }
                    }
                    // Fetch type ahead items if handler returned a promise.
                    if (pluginState.active && pluginState.itemsLoader) {
                        pluginState.itemsLoader.promise.then(function (items) {
                            return itemsListUpdated(items)(editorView.state, dispatch);
                        });
                    }
                },
            };
        },
    });
}
export function createItemsLoader(promiseOfItems) {
    var canceled = false;
    return {
        promise: new Promise(function (resolve, reject) {
            promiseOfItems
                .then(function (result) { return !canceled && resolve(result); })
                .catch(function (error) { return !canceled && reject(error); });
        }),
        cancel: function () {
            canceled = true;
        },
    };
}
export function defaultActionHandler(_a) {
    var dispatch = _a.dispatch, typeAhead = _a.typeAhead, pluginState = _a.pluginState, state = _a.state;
    var typeAheadQuery = state.schema.marks.typeAheadQuery;
    var doc = state.doc, selection = state.selection;
    var from = selection.from, to = selection.to;
    var isActive = isQueryActive(typeAheadQuery, doc, from - 1, to);
    var nodeBefore = selection.$from.nodeBefore;
    if (!isActive || !nodeBefore || !pluginState) {
        var newPluginState_1 = createInitialPluginState(pluginState ? pluginState.active : false);
        if (!pluginState || pluginState.active) {
            dispatch(pluginKey, newPluginState_1);
        }
        return newPluginState_1;
    }
    var typeAheadMark = typeAheadQuery.isInSet(nodeBefore.marks || []);
    if (!typeAheadMark || !typeAheadMark.attrs.trigger) {
        return pluginState;
    }
    var trigger = typeAheadMark.attrs.trigger.replace(/([^\x00-\xFF]|[\s\n])+/g, '');
    var query = (nodeBefore.textContent || '')
        .replace(trigger, '')
        .replace(/^([^\x00-\xFF]|[\s\n])+/g, '');
    var typeAheadHandler = typeAhead.find(function (t) { return t.trigger === trigger; });
    var typeAheadItems = [];
    var itemsLoader = null;
    try {
        typeAheadItems = typeAheadHandler.getItems(query, state);
        if (pluginState.itemsLoader) {
            pluginState.itemsLoader.cancel();
        }
        if (typeAheadItems.then) {
            itemsLoader = createItemsLoader(typeAheadItems);
            typeAheadItems = pluginState.items;
        }
    }
    catch (e) { }
    var newPluginState = {
        query: query,
        trigger: trigger,
        typeAheadHandler: typeAheadHandler,
        active: true,
        prevActiveState: pluginState.active,
        items: typeAheadItems,
        itemsLoader: itemsLoader,
        currentIndex: pluginState.currentIndex,
    };
    dispatch(pluginKey, newPluginState);
    return newPluginState;
}
export function selectPrevActionHandler(_a) {
    var dispatch = _a.dispatch, pluginState = _a.pluginState;
    var newIndex = pluginState.currentIndex - 1;
    var newPluginState = tslib_1.__assign({}, pluginState, { currentIndex: newIndex < 0 ? pluginState.items.length - 1 : newIndex });
    dispatch(pluginKey, newPluginState);
    return newPluginState;
}
export function selectNextActionHandler(_a) {
    var dispatch = _a.dispatch, pluginState = _a.pluginState;
    var newIndex = pluginState.currentIndex + 1;
    var newPluginState = tslib_1.__assign({}, pluginState, { currentIndex: newIndex > pluginState.items.length - 1 ? 0 : newIndex });
    dispatch(pluginKey, newPluginState);
    return newPluginState;
}
export function itemsListUpdatedActionHandler(_a) {
    var dispatch = _a.dispatch, pluginState = _a.pluginState, tr = _a.tr;
    var newPluginState = tslib_1.__assign({}, pluginState, { itemsLoader: null, items: tr.getMeta(pluginKey).items });
    dispatch(pluginKey, newPluginState);
    return newPluginState;
}
export function selectCurrentActionHandler(_a) {
    var dispatch = _a.dispatch, pluginState = _a.pluginState;
    var newPluginState = createInitialPluginState(pluginState.active);
    dispatch(pluginKey, newPluginState);
    return newPluginState;
}
//# sourceMappingURL=main.js.map