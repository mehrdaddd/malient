import { Plugin, PluginKey } from 'prosemirror-state';
import { setParentNodeMarkup, findParentDomRefOfType, findParentNodeOfType, removeParentNodeOfType, } from 'prosemirror-utils';
import { analyticsService } from '../../../analytics';
import { panelNodeView } from '../nodeviews/panel';
export var availablePanelType = [
    { panelType: 'info' },
    { panelType: 'note' },
    { panelType: 'success' },
    { panelType: 'warning' },
    { panelType: 'error' },
];
var PanelState = /** @class */ (function () {
    function PanelState(state) {
        this.changeHandlers = [];
        this.editorFocused = false;
        this.changeHandlers = [];
        this.state = state;
        this.toolbarVisible = false;
    }
    PanelState.prototype.updateEditorFocused = function (editorFocused) {
        this.editorFocused = editorFocused;
    };
    PanelState.prototype.changePanelType = function (view, _a) {
        var panelType = _a.panelType;
        analyticsService.trackEvent("atlassian.editor.format." + panelType + ".button");
        var _b = view.state, tr = _b.tr, schema = _b.schema, dispatch = view.dispatch;
        dispatch(setParentNodeMarkup(schema.nodes.panel, null, { panelType: panelType })(tr));
    };
    PanelState.prototype.removePanel = function (view) {
        var _a = view.state, tr = _a.tr, schema = _a.schema, dispatch = view.dispatch;
        dispatch(removeParentNodeOfType(schema.nodes.panel)(tr));
    };
    PanelState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    PanelState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    PanelState.prototype.update = function (state, domAtPos, domEvent) {
        var _this = this;
        if (domEvent === void 0) { domEvent = false; }
        this.state = state;
        var newPanel = this.getActivePanel();
        if ((domEvent && newPanel) || this.activeNode !== newPanel) {
            var newElement = newPanel && this.getDomElement(domAtPos);
            this.activeNode = newPanel;
            this.toolbarVisible =
                this.editorFocused &&
                    !!newPanel &&
                    (domEvent || this.element !== newElement);
            this.element = newElement;
            this.activePanelType = newPanel && newPanel.attrs['panelType'];
            this.changeHandlers.forEach(function (cb) { return cb(_this); });
        }
    };
    PanelState.prototype.getActivePanel = function () {
        var _a = this.state, selection = _a.selection, panel = _a.schema.nodes.panel;
        var parent = findParentNodeOfType(panel)(selection);
        if (parent) {
            return parent.node;
        }
    };
    PanelState.prototype.getDomElement = function (domAtPos) {
        var _a = this.state, selection = _a.selection, panel = _a.schema.nodes.panel;
        var node = findParentDomRefOfType(panel, domAtPos)(selection);
        if (node) {
            // getting panel nodeView wrapper
            while (!node.attributes['data-panel-type']) {
                node = node.parentNode;
            }
            return node;
        }
    };
    return PanelState;
}());
export { PanelState };
export var stateKey = new PluginKey('panelPlugin');
// TODO: Fix types (ED-2987)
export var createPlugin = function () {
    return new Plugin({
        state: {
            init: function (config, state) {
                return new PanelState(state);
            },
            apply: function (tr, pluginState, oldState, newState) {
                var stored = tr.getMeta(stateKey);
                if (stored) {
                    pluginState.update(newState, stored.docView, stored.domEvent);
                }
                return pluginState;
            },
        },
        key: stateKey,
        view: function (view) {
            return {
                update: function (view, prevState) {
                    stateKey
                        .getState(view.state)
                        .update(view.state, view.domAtPos.bind(view));
                },
            };
        },
        props: {
            nodeViews: {
                panel: panelNodeView,
            },
            handleClick: function (view, event) {
                stateKey
                    .getState(view.state)
                    .update(view.state, view.domAtPos.bind(view), true);
                return false;
            },
            handleDOMEvents: {
                focus: function (view, event) {
                    stateKey.getState(view.state).updateEditorFocused(true);
                    return false;
                },
                blur: function (view, event) {
                    var pluginState = stateKey.getState(view.state);
                    pluginState.updateEditorFocused(false);
                    pluginState.update(view.state, view.domAtPos.bind(view), true);
                    return false;
                },
            },
        },
    });
};
//# sourceMappingURL=main.js.map