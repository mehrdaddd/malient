import * as React from 'react';
import * as ReactDOM from 'react-dom';
import ReactPMNode from './ui/prosemirror-node';
import { EventDispatcher } from '../event-dispatcher';
import connect from './connect';
var createTemporaryContainer = function (node) {
    return document.createElement(node.type.isBlock ? 'div' : 'span');
};
var NodeViewElem = /** @class */ (function () {
    function NodeViewElem(node, view, getPos, providerFactory, reactNodeViewComponents) {
        this.nodeTypeName = node.type.name;
        this.view = view;
        this.getPos = getPos;
        this.providerFactory = providerFactory;
        this.reactNodeViewComponents = reactNodeViewComponents;
        this.domRef = createTemporaryContainer(node);
        this.eventDispatcher = new EventDispatcher();
        this.setDomAttrs(node);
        this.renderReactComponent(node);
        /**
         * Create temporary containers for children since we are not using contentDOM
         * Without this PM will throw, @see ED-4235
         */
        if (node.content.size) {
            var fragment_1 = document.createDocumentFragment();
            node.content.forEach(function (child) {
                fragment_1.appendChild(createTemporaryContainer(child));
            });
            this.domRef.appendChild(fragment_1);
        }
    }
    Object.defineProperty(NodeViewElem.prototype, "dom", {
        get: function () {
            return this.domRef;
        },
        enumerable: true,
        configurable: true
    });
    NodeViewElem.prototype.update = function (node) {
        // @see https://github.com/ProseMirror/prosemirror/issues/648
        var isValidUpdate = this.nodeTypeName === node.type.name;
        if (isValidUpdate) {
            if (this.domRef) {
                this.setDomAttrs(node);
                this.eventDispatcher.emit('change', { node: node });
            }
            else {
                this.renderReactComponent(node);
            }
        }
        return isValidUpdate;
    };
    NodeViewElem.prototype.destroy = function () {
        ReactDOM.unmountComponentAtNode(this.domRef);
        this.eventDispatcher.destroy();
        this.domRef = undefined;
    };
    NodeViewElem.prototype.setDomAttrs = function (node) {
        var _this = this;
        Object.keys(node.attrs || {}).forEach(function (attr) {
            if (_this.domRef) {
                _this.domRef.setAttribute(attr, node.attrs[attr]);
            }
        });
    };
    NodeViewElem.prototype.renderReactComponent = function (node) {
        var _a = this, getPos = _a.getPos, providerFactory = _a.providerFactory, reactNodeViewComponents = _a.reactNodeViewComponents, view = _a.view, eventDispatcher = _a.eventDispatcher;
        var ConnectedReactPMNode = connect(ReactPMNode, eventDispatcher);
        ReactDOM.render(React.createElement(ConnectedReactPMNode, { node: node, getPos: getPos, view: view, providerFactory: providerFactory, components: reactNodeViewComponents }), this.domRef);
    };
    return NodeViewElem;
}());
export default function nodeViewFactory(providerFactory, reactNodeViewComponents) {
    return function (node, view, getPos) {
        return new NodeViewElem(node, view, getPos, providerFactory, reactNodeViewComponents);
    };
}
//# sourceMappingURL=factory.js.map