import * as tslib_1 from "tslib";
import { NodeSelection, Plugin, PluginKey, } from 'prosemirror-state';
import { safeInsert } from 'prosemirror-utils';
import { analyticsService } from '../../../analytics';
import { isPastedFile } from '../../../utils/clipboard';
var DEFAULT_OPTIONS = {
    maxFileSizeInBytes: 10000000,
    supportedImageTypes: ['jpg', 'jpeg', 'png', 'gif', 'svg'],
};
function isDroppedFile(e) {
    return (Array.prototype.slice.call(e.dataTransfer.types).indexOf('Files') !== -1);
}
export var createMediaNode = function (url, schema) {
    var _a = schema.nodes, media = _a.media, mediaSingle = _a.mediaSingle;
    if (!media || !mediaSingle) {
        return null;
    }
    var mediaNode = media.create({
        type: 'external',
        url: url,
    });
    return mediaSingle.create({}, mediaNode);
};
var ImageUploadState = /** @class */ (function () {
    function ImageUploadState(state, options) {
        var _this = this;
        this.active = false;
        this.enabled = false;
        this.hidden = false;
        this.src = undefined;
        this.element = undefined;
        this.changeHandlers = [];
        this.handleProvider = function (name, provider) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!provider) return [3 /*break*/, 5];
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = this;
                        return [4 /*yield*/, provider];
                    case 2:
                        _a.uploadHandler = _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _b.sent();
                        this.uploadHandler = undefined;
                        return [3 /*break*/, 4];
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        this.uploadHandler = undefined;
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        }); };
        this.changeHandlers = [];
        this.state = state;
        this.config = tslib_1.__assign({}, DEFAULT_OPTIONS, options);
        this.hidden = !state.schema.nodes.media || !state.schema.nodes.mediaSingle;
        this.enabled = this.canInsertImage();
        if (options && options.providerFactory) {
            options.providerFactory.subscribe('imageUploadProvider', this.handleProvider);
        }
    }
    ImageUploadState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    ImageUploadState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    // TODO: Fix types (ED-2987)
    ImageUploadState.prototype.update = function (state, docView, dirty) {
        var _this = this;
        if (dirty === void 0) { dirty = false; }
        this.state = state;
        var newActive = this.isImageSelected();
        if (newActive !== this.active) {
            this.active = newActive;
            dirty = true;
        }
        var newEnabled = this.canInsertImage();
        if (newEnabled !== this.enabled) {
            this.enabled = newEnabled;
            dirty = true;
        }
        var newElement = newActive
            ? this.getActiveImageElement(docView)
            : undefined;
        if (newElement !== this.element) {
            this.element = newElement;
            dirty = true;
        }
        if (dirty) {
            this.changeHandlers.forEach(function (cb) { return cb(_this); });
        }
    };
    ImageUploadState.prototype.handleImageUpload = function (view, event) {
        var uploadHandler = this.uploadHandler;
        if (!uploadHandler) {
            return false;
        }
        uploadHandler(event, this.addImage(view));
        return true;
    };
    ImageUploadState.prototype.addImage = function (view) {
        var _this = this;
        return function (options) {
            var state = _this.state;
            if (_this.enabled && options.src) {
                var mediaNode = createMediaNode(options.src, state.schema);
                if (mediaNode) {
                    view.dispatch(safeInsert(mediaNode, state.selection.$to.pos)(state.tr).scrollIntoView());
                }
            }
        };
    };
    // TODO: Fix types (ED-2987)
    ImageUploadState.prototype.getActiveImageElement = function (docView) {
        var $from = this.state.selection.$from;
        var _a = docView.domFromPos($from.pos), node = _a.node, offset = _a.offset;
        if (node.childNodes.length === 0) {
            return node.parentElement;
        }
        return node.childNodes[offset];
    };
    ImageUploadState.prototype.canInsertImage = function () {
        var state = this.state;
        var mediaSingle = state.schema.nodes.mediaSingle;
        var $to = state.selection.$to;
        if (mediaSingle) {
            for (var d = $to.depth; d >= 0; d--) {
                var index = $to.index(d);
                if ($to.node(d).canReplaceWith(index, index, mediaSingle)) {
                    return true;
                }
            }
        }
        return false;
    };
    ImageUploadState.prototype.isImageSelected = function () {
        var selection = this.state.selection;
        return (selection instanceof NodeSelection &&
            selection.node.type === this.state.schema.nodes.media);
    };
    return ImageUploadState;
}());
export { ImageUploadState };
export var stateKey = new PluginKey('imageUploadPlugin');
export var createPlugin = function (schema, options) {
    return new Plugin({
        state: {
            init: function (config, state) {
                return new ImageUploadState(state, options);
            },
            apply: function (tr, pluginState, oldState, newState) {
                return pluginState;
            },
        },
        key: stateKey,
        view: function (view) {
            var pluginState = stateKey.getState(view.state);
            pluginState.update(view.state, view.docView, true);
            return {
                update: function (view, prevState) {
                    pluginState.update(view.state, view.docView);
                },
                destroy: function () {
                    if (options && options.providerFactory) {
                        options.providerFactory.unsubscribe('imageUploadProvider', pluginState.handleProvider);
                    }
                },
            };
        },
        props: {
            handleDOMEvents: {
                drop: function (view, event) {
                    var pluginState = stateKey.getState(view.state);
                    if (!isDroppedFile(event) || !pluginState.enabled) {
                        return false;
                    }
                    analyticsService.trackEvent('atlassian.editor.image.drop');
                    event.preventDefault();
                    event.stopPropagation();
                    pluginState.handleImageUpload(view, event);
                    return true;
                },
                paste: function (view, event) {
                    var pluginState = stateKey.getState(view.state);
                    if (!isPastedFile(event) || !pluginState.enabled) {
                        return false;
                    }
                    analyticsService.trackEvent('atlassian.editor.image.paste');
                    event.preventDefault();
                    event.stopPropagation();
                    pluginState.handleImageUpload(view, event);
                    return true;
                },
            },
        },
    });
};
//# sourceMappingURL=main.js.map