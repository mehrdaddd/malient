import { Node, Fragment } from 'prosemirror-model';
/**
 * Checks if node is an empty paragraph.
 */
export function isEmptyParagraph(node) {
    return (!node ||
        (node.type.name === 'paragraph' && !node.textContent && !node.childCount));
}
/**
 * Returns false if node contains only empty inline nodes and hardBreaks.
 */
export function hasVisibleContent(node) {
    var isInlineNodeHasVisibleContent = function (inlineNode) {
        return inlineNode.isText
            ? !!inlineNode.textContent.trim()
            : inlineNode.type.name !== 'hardBreak';
    };
    if (node.isInline) {
        return isInlineNodeHasVisibleContent(node);
    }
    else if (node.isBlock && node.isLeaf) {
        return true;
    }
    else if (!node.childCount) {
        return false;
    }
    for (var index = 0; index < node.childCount; index++) {
        var child = node.child(index);
        if (hasVisibleContent(child)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if a node has any content. Ignores node that only contain emoty block nodes.
 */
export function isEmptyNode(node) {
    if (node && node.textContent) {
        return false;
    }
    if (!node ||
        !node.childCount ||
        (node.childCount === 1 && isEmptyParagraph(node.firstChild))) {
        return true;
    }
    var block = [];
    var nonBlock = [];
    node.forEach(function (child) {
        child.isInline ? nonBlock.push(child) : block.push(child);
    });
    return (!nonBlock.length &&
        !block.filter(function (childNode) {
            return (!!childNode.childCount &&
                !(childNode.childCount === 1 && isEmptyParagraph(childNode.firstChild))) ||
                childNode.isAtom;
        }).length);
}
/**
 * Checks if a node looks like an empty document
 */
export function isEmptyDocument(node) {
    var nodeChild = node.content.firstChild;
    if (node.childCount !== 1 || !nodeChild) {
        return false;
    }
    return (nodeChild.type.name === 'paragraph' &&
        !nodeChild.childCount &&
        nodeChild.nodeSize === 2);
}
export var preprocessDoc = function (schema, origDoc) {
    if (!origDoc) {
        return;
    }
    var content = [];
    origDoc.content.forEach(function (node, index) {
        var _a = schema.nodes, taskList = _a.taskList, decisionList = _a.decisionList;
        if (!(node.type.name === 'paragraph' &&
            node.content.size === 0 &&
            index === origDoc.childCount - 1 &&
            origDoc.childCount > 1) &&
            ((node.type !== taskList && node.type !== decisionList) ||
                node.textContent)) {
            content.push(node);
        }
    });
    return schema.nodes.doc.create({}, Fragment.fromArray(content));
};
export function processRawValue(schema, value) {
    if (!value) {
        return;
    }
    var node;
    if (typeof value === 'string') {
        try {
            node = JSON.parse(value);
        }
        catch (e) {
            // tslint:disable-next-line:no-console
            console.error("Error processing value: " + value + " isn't a valid JSON");
            return;
        }
    }
    else {
        node = value;
    }
    if (Array.isArray(node)) {
        // tslint:disable-next-line:no-console
        console.error("Error processing value: " + node + " is an array, but it must be an object.");
        return;
    }
    try {
        var parsedDoc = Node.fromJSON(schema, node);
        // throws an error if the document is invalid
        parsedDoc.check();
        return parsedDoc;
    }
    catch (e) {
        // tslint:disable-next-line:no-console
        console.error("Error processing value: " + node + " \u2013 " + e.message);
        return;
    }
}
//# sourceMappingURL=document.js.map