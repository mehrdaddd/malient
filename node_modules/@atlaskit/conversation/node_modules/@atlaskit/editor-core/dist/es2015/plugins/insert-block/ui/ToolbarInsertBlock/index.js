import * as tslib_1 from "tslib";
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import AddIcon from '@atlaskit/icon/glyph/editor/add';
import ExpandIcon from '@atlaskit/icon/glyph/chevron-down';
import TableIcon from '@atlaskit/icon/glyph/editor/table';
import EditorImageIcon from '@atlaskit/icon/glyph/editor/image';
import CodeIcon from '@atlaskit/icon/glyph/editor/code';
import InfoIcon from '@atlaskit/icon/glyph/editor/info';
import MentionIcon from '@atlaskit/icon/glyph/editor/mention';
import QuoteIcon from '@atlaskit/icon/glyph/quote';
import EditorMoreIcon from '@atlaskit/icon/glyph/editor/more';
import LinkIcon from '@atlaskit/icon/glyph/editor/link';
import EmojiIcon from '@atlaskit/icon/glyph/editor/emoji';
import DateIcon from '@atlaskit/icon/glyph/editor/date';
import PlaceholderTextIcon from '@atlaskit/icon/glyph/media-services/text';
import HorizontalRuleIcon from '@atlaskit/icon/glyph/editor/horizontal-rule';
import { EmojiPicker as AkEmojiPicker, } from '@atlaskit/emoji';
import { Popup } from '@atlaskit/editor-common';
import { analyticsService as analytics, analyticsDecorator, } from '../../../../analytics';
import { toggleTable, tooltip, findKeymapByDescription, addLink, } from '../../../../keymaps';
import DropdownMenu from '../../../../ui/DropdownMenu';
import ToolbarButton from '../../../../ui/ToolbarButton';
import { Wrapper, ButtonGroup, ExpandIconWrapper } from '../../../../ui/styles';
import tableCommands from '../../../table/commands';
import { insertDate, openDatePicker } from '../../../date/actions';
import { showPlaceholderFloatingToolbar } from '../../../placeholder-text/actions';
import { createHorizontalRule } from '../../../rule/pm-plugins/input-rule';
import { TriggerWrapper } from './styles';
import { insertLayoutColumns } from '../../../layout/actions';
var blockTypeIcons = {
    codeblock: CodeIcon,
    panel: InfoIcon,
    blockquote: QuoteIcon,
};
/**
 * Checks if an element is detached (i.e. not in the current document)
 */
var isDetachedElement = function (el) { return !document.body.contains(el); };
var noop = function () { };
var ToolbarInsertBlock = /** @class */ (function (_super) {
    tslib_1.__extends(ToolbarInsertBlock, _super);
    function ToolbarInsertBlock() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            isOpen: false,
            emojiPickerOpen: false,
        };
        _this.onOpenChange = function (attrs) {
            var state = { isOpen: attrs.isOpen };
            if (_this.state.emojiPickerOpen && !attrs.open) {
                state.emojiPickerOpen = false;
            }
            _this.setState(state);
        };
        _this.handleTriggerClick = function () {
            var isOpen = _this.state.isOpen;
            _this.onOpenChange({ isOpen: !isOpen });
        };
        _this.toggleEmojiPicker = function () {
            var emojiPickerOpen = !_this.state.emojiPickerOpen;
            _this.setState({ emojiPickerOpen: emojiPickerOpen });
        };
        _this.handleButtonRef = function (ref) {
            var buttonRef = ref || null;
            if (buttonRef) {
                _this.button = ReactDOM.findDOMNode(buttonRef);
            }
        };
        _this.handleDropDownButtonRef = function (ref, items) {
            items.forEach(function (item) { return item.handleRef && item.handleRef(ref); });
        };
        _this.onPickerRef = function (ref) {
            if (ref) {
                document.addEventListener('click', _this.handleClickOutside);
            }
            else {
                document.removeEventListener('click', _this.handleClickOutside);
            }
            _this.pickerRef = ref;
        };
        _this.handleClickOutside = function (e) {
            var picker = ReactDOM.findDOMNode(_this.pickerRef);
            // Ignore click events for detached elements.
            // Workaround for FS-1322 - where two onClicks fire - one when the upload button is
            // still in the document, and one once it's detached. Does not always occur, and
            // may be a side effect of a react render optimisation
            if (!picker ||
                (!isDetachedElement(e.target) && !picker.contains(e.target))) {
                _this.toggleEmojiPicker();
            }
        };
        _this.createItems = function () {
            var _a = _this.props, tableHidden = _a.tableHidden, tableSupported = _a.tableSupported, mediaUploadsEnabled = _a.mediaUploadsEnabled, mediaSupported = _a.mediaSupported, imageUploadSupported = _a.imageUploadSupported, imageUploadEnabled = _a.imageUploadEnabled, mentionsEnabled = _a.mentionsEnabled, mentionsSupported = _a.mentionsSupported, availableWrapperBlockTypes = _a.availableWrapperBlockTypes, macroProvider = _a.macroProvider, linkSupported = _a.linkSupported, linkDisabled = _a.linkDisabled, emojiDisabled = _a.emojiDisabled, emojiProvider = _a.emojiProvider, insertMenuItems = _a.insertMenuItems, dateEnabled = _a.dateEnabled, placeholderTextEnabled = _a.placeholderTextEnabled, horizontalRuleEnabled = _a.horizontalRuleEnabled, layoutSectionEnabled = _a.layoutSectionEnabled;
            var items = [];
            if (linkSupported) {
                items.push({
                    content: 'Add link',
                    value: { name: 'link' },
                    isDisabled: linkDisabled,
                    tooltipDescription: tooltip(addLink),
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(LinkIcon, { label: "Add link" }),
                });
            }
            if (mediaSupported && mediaUploadsEnabled) {
                items.push({
                    content: 'Files and images',
                    value: { name: 'media' },
                    tooltipDescription: 'Files and Images',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(EditorImageIcon, { label: "Insert files and images" }),
                });
            }
            if (imageUploadSupported) {
                items.push({
                    content: 'Insert image',
                    value: { name: 'image upload' },
                    isDisabled: !imageUploadEnabled,
                    tooltipDescription: 'Insert image',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(EditorImageIcon, { label: "Insert image" }),
                });
            }
            if (mentionsSupported) {
                items.push({
                    content: 'Mention',
                    value: { name: 'mention' },
                    isDisabled: !mentionsEnabled,
                    tooltipDescription: 'Mention a person (@)',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(MentionIcon, { label: "Add mention" }),
                });
            }
            if (emojiProvider) {
                items.push({
                    content: 'Emoji',
                    value: { name: 'emoji' },
                    isDisabled: emojiDisabled,
                    tooltipDescription: 'Insert emoji (:)',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(EmojiIcon, { label: "Insert emoji" }),
                    handleRef: _this.handleButtonRef,
                });
            }
            if (tableSupported) {
                items.push({
                    content: 'Table',
                    value: { name: 'table' },
                    isDisabled: tableHidden,
                    tooltipDescription: tooltip(toggleTable),
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(TableIcon, { label: "Insert table" }),
                });
            }
            if (availableWrapperBlockTypes) {
                availableWrapperBlockTypes.forEach(function (blockType) {
                    var BlockTypeIcon = blockTypeIcons[blockType.name];
                    items.push({
                        content: blockType.title,
                        value: blockType,
                        tooltipDescription: tooltip(findKeymapByDescription(blockType.title)),
                        tooltipPosition: 'right',
                        elemBefore: React.createElement(BlockTypeIcon, { label: "Insert " + blockType + " block" }),
                    });
                });
            }
            if (horizontalRuleEnabled &&
                _this.props.editorView.state.schema.nodes.rule) {
                items.push({
                    content: 'Horizontal Rule',
                    value: { name: 'horizontalrule' },
                    tooltipDescription: 'Insert horizontal rule',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(HorizontalRuleIcon, { label: "Insert horizontal rule" }),
                });
            }
            if (dateEnabled) {
                items.push({
                    content: 'Date',
                    value: { name: 'date' },
                    tooltipDescription: 'Insert date',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(DateIcon, { label: "Insert date" }),
                });
            }
            if (placeholderTextEnabled) {
                items.push({
                    content: 'Placeholder Text',
                    value: { name: 'placeholder text' },
                    tooltipDescription: 'Add placeholder text',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(PlaceholderTextIcon, { label: "Add placeholder text" }),
                });
            }
            if (layoutSectionEnabled) {
                items.push({
                    content: 'Columns',
                    value: { name: 'layout' },
                    tooltipDescription: 'Insert columns',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(PlaceholderTextIcon, { label: "Insert columns" }),
                });
            }
            if (insertMenuItems) {
                items = items.concat(insertMenuItems);
                // keeping this here for backwards compatibility so confluence
                // has time to implement this button before it disappears.
                // Should be safe to delete soon. If in doubt ask Leandro Lemos (llemos)
            }
            else if (typeof macroProvider !== 'undefined' && macroProvider) {
                items.push({
                    content: 'View more',
                    value: { name: 'macro' },
                    tooltipDescription: 'View more',
                    tooltipPosition: 'right',
                    elemBefore: React.createElement(EditorMoreIcon, { label: "View more" }),
                });
            }
            return items;
        };
        _this.toggleLinkPanel = function () {
            var _a = _this.props, showLinkPanel = _a.showLinkPanel, editorView = _a.editorView;
            showLinkPanel(editorView);
            return true;
        };
        _this.insertMention = function () {
            var insertMentionQuery = _this.props.insertMentionQuery;
            insertMentionQuery();
            return true;
        };
        _this.createTable = function () {
            var editorView = _this.props.editorView;
            tableCommands.createTable()(editorView.state, editorView.dispatch);
            return true;
        };
        _this.createDate = function () {
            var editorView = _this.props.editorView;
            insertDate()(editorView.state, editorView.dispatch);
            openDatePicker(editorView.domAtPos.bind(editorView))(editorView.state, editorView.dispatch);
            return true;
        };
        _this.createPlaceholderText = function () {
            var editorView = _this.props.editorView;
            showPlaceholderFloatingToolbar(editorView.state, editorView.dispatch);
            return true;
        };
        _this.insertLayoutColumns = function () {
            var editorView = _this.props.editorView;
            insertLayoutColumns(editorView.state, editorView.dispatch);
            return true;
        };
        _this.openMediaPicker = function () {
            var onShowMediaPicker = _this.props.onShowMediaPicker;
            onShowMediaPicker();
            return true;
        };
        _this.insertHorizontalRule = function () {
            var editorView = _this.props.editorView;
            editorView.dispatch(createHorizontalRule(editorView.state, editorView.state.selection.from, editorView.state.selection.to));
            return true;
        };
        _this.handleSelectedEmoji = function (emojiId, emoji) {
            _this.props.insertEmoji(emojiId);
            _this.toggleEmojiPicker();
            return true;
        };
        _this.onItemActivated = function (_a) {
            var item = _a.item;
            var _b = _this.props, editorView = _b.editorView, editorActions = _b.editorActions, onInsertBlockType = _b.onInsertBlockType, onInsertMacroFromMacroBrowser = _b.onInsertMacroFromMacroBrowser, macroProvider = _b.macroProvider, handleImageUpload = _b.handleImageUpload;
            switch (item.value.name) {
                case 'link':
                    _this.toggleLinkPanel();
                    break;
                case 'table':
                    _this.createTable();
                    break;
                case 'image upload':
                    if (handleImageUpload) {
                        handleImageUpload(editorView);
                    }
                    break;
                case 'media':
                    _this.openMediaPicker();
                    break;
                case 'mention':
                    _this.insertMention();
                    break;
                case 'emoji':
                    _this.toggleEmojiPicker();
                    break;
                case 'codeblock':
                case 'blockquote':
                case 'panel':
                    analytics.trackEvent("atlassian.editor.format." + item.value.name + ".button");
                    onInsertBlockType(item.value.name, editorView);
                    break;
                case 'horizontalrule':
                    _this.insertHorizontalRule();
                    break;
                case 'macro':
                    analytics.trackEvent("atlassian.editor.format." + item.value.name + ".button");
                    onInsertMacroFromMacroBrowser(macroProvider)(editorView);
                    break;
                case 'date':
                    _this.createDate();
                    break;
                case 'placeholder text':
                    _this.createPlaceholderText();
                    break;
                case 'layout':
                    _this.insertLayoutColumns();
                    break;
                default:
                    if (item && item.onClick) {
                        item.onClick(editorActions);
                        break;
                    }
            }
            _this.setState({ isOpen: false });
        };
        return _this;
    }
    ToolbarInsertBlock.prototype.componentWillReceiveProps = function (nextProps) {
        // If number of visible buttons changed, close emoji picker
        if (nextProps.buttons !== this.props.buttons) {
            this.setState({ emojiPickerOpen: false });
        }
    };
    ToolbarInsertBlock.prototype.renderPopup = function () {
        var emojiPickerOpen = this.state.emojiPickerOpen;
        var _a = this.props, popupsMountPoint = _a.popupsMountPoint, popupsBoundariesElement = _a.popupsBoundariesElement, popupsScrollableElement = _a.popupsScrollableElement, emojiProvider = _a.emojiProvider;
        if (!emojiPickerOpen || !this.button || !emojiProvider) {
            return null;
        }
        return (React.createElement(Popup, { target: this.button, fitHeight: 350, fitWidth: 350, offset: [0, 3], mountTo: popupsMountPoint, boundariesElement: popupsBoundariesElement, scrollableElement: popupsScrollableElement },
            React.createElement(AkEmojiPicker, { emojiProvider: emojiProvider, onSelection: this.handleSelectedEmoji, onPickerRef: this.onPickerRef })));
    };
    ToolbarInsertBlock.prototype.render = function () {
        var _this = this;
        var isOpen = this.state.isOpen;
        var _a = this.props, popupsMountPoint = _a.popupsMountPoint, popupsBoundariesElement = _a.popupsBoundariesElement, popupsScrollableElement = _a.popupsScrollableElement, isDisabled = _a.isDisabled, numberOfButtons = _a.buttons, isReducedSpacing = _a.isReducedSpacing;
        var items = this.createItems();
        var buttons = items.slice(0, numberOfButtons);
        var dropdownItems = items.slice(numberOfButtons);
        if (items.length === 0) {
            return null;
        }
        var toolbarButtonFactory = function (disabled, items) { return (React.createElement(ToolbarButton, { ref: function (el) { return _this.handleDropDownButtonRef(el, items); }, selected: isOpen, disabled: disabled, onClick: _this.handleTriggerClick, spacing: isReducedSpacing ? 'none' : 'default', iconBefore: React.createElement(TriggerWrapper, null,
                React.createElement(AddIcon, { label: "Open or close insert block dropdown" }),
                React.createElement(ExpandIconWrapper, null,
                    React.createElement(ExpandIcon, { label: "Open or close insert block dropdown" }))) })); };
        return (React.createElement(ButtonGroup, { width: isReducedSpacing ? 'small' : 'large' },
            buttons.map(function (btn) { return (React.createElement(ToolbarButton, { ref: btn.handleRef || noop, key: btn.content, spacing: isReducedSpacing ? 'none' : 'default', disabled: isDisabled || btn.isDisabled, iconBefore: btn.elemBefore, selected: btn.isActive, title: btn.content, onClick: function () { return _this.onItemActivated({ item: btn }); } })); }),
            React.createElement(Wrapper, null,
                this.renderPopup(),
                dropdownItems.length > 0 &&
                    (!isDisabled ? (React.createElement(DropdownMenu, { items: [{ items: dropdownItems }], onItemActivated: this.onItemActivated, onOpenChange: this.onOpenChange, mountTo: popupsMountPoint, boundariesElement: popupsBoundariesElement, scrollableElement: popupsScrollableElement, isOpen: isOpen, fitHeight: 188, fitWidth: 175 }, toolbarButtonFactory(false, dropdownItems))) : (React.createElement("div", null, toolbarButtonFactory(true, dropdownItems)))))));
    };
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.hyperlink.button')
    ], ToolbarInsertBlock.prototype, "toggleLinkPanel", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.fabric.mention.picker.trigger.button')
    ], ToolbarInsertBlock.prototype, "insertMention", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.table.button')
    ], ToolbarInsertBlock.prototype, "createTable", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.date.button')
    ], ToolbarInsertBlock.prototype, "createDate", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.placeholder.button')
    ], ToolbarInsertBlock.prototype, "createPlaceholderText", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.layout.button')
    ], ToolbarInsertBlock.prototype, "insertLayoutColumns", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.media.button')
    ], ToolbarInsertBlock.prototype, "openMediaPicker", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.format.horizontalrule.button')
    ], ToolbarInsertBlock.prototype, "insertHorizontalRule", void 0);
    tslib_1.__decorate([
        analyticsDecorator('atlassian.editor.emoji.button')
    ], ToolbarInsertBlock.prototype, "handleSelectedEmoji", void 0);
    return ToolbarInsertBlock;
}(React.PureComponent));
export default ToolbarInsertBlock;
//# sourceMappingURL=index.js.map