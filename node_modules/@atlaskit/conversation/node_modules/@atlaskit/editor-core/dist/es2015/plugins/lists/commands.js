import { Fragment, NodeRange, Slice, } from 'prosemirror-model';
import { TextSelection } from 'prosemirror-state';
import { liftTarget, ReplaceAroundStep } from 'prosemirror-transform';
import * as commands from '../../commands';
import { isEmptyNode, hasVisibleContent } from '../../utils/document';
import { chainCommands } from 'prosemirror-commands';
import { filter, isEmptySelectionAtStart, isFirstChildOfParent, isNthParentOfType, findCutBefore, } from '../../utils/commands';
/**
 * Function will lift list item following selection to level-1.
 */
export function liftFollowingList(state, from, to, rootListDepth, tr) {
    var listItem = state.schema.nodes.listItem;
    var lifted = false;
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (!lifted && node.type === listItem && pos > from) {
            lifted = true;
            var listDepth = rootListDepth + 3;
            while (listDepth > rootListDepth + 2) {
                var start = tr.doc.resolve(tr.mapping.map(pos));
                listDepth = start.depth;
                var end = tr.doc.resolve(tr.mapping.map(pos + node.textContent.length));
                var sel = new TextSelection(start, end);
                tr = liftListItem(state, sel, tr);
            }
        }
    });
    return tr;
}
/**
 * Lift list item.
 */
function liftListItem(state, selection, tr) {
    var $from = selection.$from, $to = selection.$to;
    var nodeType = state.schema.nodes.listItem;
    var range = $from.blockRange($to, function (node) { return node.childCount && node.firstChild.type === nodeType; });
    if (!range ||
        range.depth < 2 ||
        $from.node(range.depth - 1).type !== nodeType) {
        return tr;
    }
    var end = range.end;
    var endOfList = $to.end(range.depth);
    if (end < endOfList) {
        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(nodeType.create(undefined, range.parent.copy())), 1, 0), 1, true));
        range = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), range.depth);
    }
    return tr.lift(range, liftTarget(range)).scrollIntoView();
}
export var enterKeyCommand = function (state, dispatch) {
    var selection = state.selection;
    if (selection.empty) {
        var $from = selection.$from;
        var listItem = state.schema.nodes.listItem;
        var node = $from.node($from.depth);
        var wrapper = $from.node($from.depth - 1);
        if (wrapper && wrapper.type === listItem) {
            /** Check if the wrapper has any visible content */
            var wrapperHasContent = hasVisibleContent(wrapper);
            if (isEmptyNode(node) || !wrapperHasContent) {
                return commands.outdentList()(state, dispatch);
            }
            else {
                return splitListItem(listItem)(state, dispatch);
            }
        }
    }
    return false;
};
var deletePreviousEmptyListItem = function (state, dispatch) {
    var $from = state.selection.$from;
    var listItem = state.schema.nodes.listItem;
    var $cut = findCutBefore($from);
    if (!$cut || !$cut.nodeBefore || !($cut.nodeBefore.type === listItem)) {
        return false;
    }
    var previousListItemEmpty = $cut.nodeBefore.childCount === 1 &&
        $cut.nodeBefore.firstChild.nodeSize <= 2;
    if (previousListItemEmpty) {
        var tr = state.tr;
        dispatch(tr
            .delete($cut.pos - $cut.nodeBefore.nodeSize, $from.pos)
            .scrollIntoView());
        return true;
    }
    return false;
};
var joinPToPreviousListItem = function (state, dispatch) {
    var $from = state.selection.$from;
    var _a = state.schema.nodes, paragraph = _a.paragraph, bulletList = _a.bulletList, orderedList = _a.orderedList;
    var $cut = findCutBefore($from);
    if (!$cut) {
        return false;
    }
    // see if the containing node is a list
    if ($cut.nodeBefore &&
        [bulletList, orderedList].indexOf($cut.nodeBefore.type) > -1) {
        // and the node after this is a paragraph
        if ($cut.nodeAfter && $cut.nodeAfter.type === paragraph) {
            // find the nearest paragraph that precedes this node
            var $lastNode = $cut.doc.resolve($cut.pos - 1);
            while ($lastNode.parent.type !== paragraph) {
                $lastNode = state.doc.resolve($lastNode.pos - 1);
            }
            // take the text content of the paragraph and insert after the paragraph up until before the the cut
            var tr = state.tr.step(new ReplaceAroundStep($lastNode.pos, $cut.pos + $cut.nodeAfter.nodeSize, $cut.pos + 1, $cut.pos + $cut.nodeAfter.nodeSize - 1, state.tr.doc.slice($lastNode.pos, $cut.pos), 0, true));
            // find out if there's now another list following and join them
            // as in, [list, p, list] => [list with p, list], and we want [joined list]
            var $postCut = tr.doc.resolve(tr.mapping.map($cut.pos + $cut.nodeAfter.nodeSize));
            if ($postCut.nodeBefore &&
                $postCut.nodeAfter &&
                $postCut.nodeBefore.type === $postCut.nodeAfter.type &&
                [bulletList, orderedList].indexOf($postCut.nodeBefore.type) > -1) {
                tr = tr.join($postCut.pos);
            }
            dispatch(tr.scrollIntoView());
            return true;
        }
    }
    return false;
};
export var backspaceKeyCommand = chainCommands(
// if we're at the start of a list item, we need to either backspace
// directly to an empty list item above, or outdent this node
filter([
    isEmptySelectionAtStart,
    // list items might have multiple paragraphs; only do this at the first one
    isFirstChildOfParent,
    isNthParentOfType('listItem', 1),
], chainCommands(deletePreviousEmptyListItem, commands.outdentList())), 
// if we're just inside a paragraph node and backspace, then try to join
// the text to the previous list item, if one exists
filter([isEmptySelectionAtStart, isNthParentOfType('paragraph', 0)], joinPToPreviousListItem));
export var toggleList = function (state, dispatch, view, listType) {
    var selection = state.selection;
    var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, listItem = _a.listItem;
    var fromNode = selection.$from.node(selection.$from.depth - 2);
    var endNode = selection.$to.node(selection.$to.depth - 2);
    if (!fromNode ||
        fromNode.type.name !== listType ||
        (!endNode || endNode.type.name !== listType)) {
        return commands.toggleList(listType)(state, dispatch, view);
    }
    else {
        var rootListDepth = void 0;
        for (var i = selection.$to.depth - 1; i > 0; i--) {
            var node = selection.$to.node(i);
            if (node.type === bulletList || node.type === orderedList) {
                rootListDepth = i;
            }
            if (node.type !== bulletList &&
                node.type !== orderedList &&
                node.type !== listItem) {
                break;
            }
        }
        var tr = liftFollowingList(state, selection.$to.pos, selection.$to.end(rootListDepth), rootListDepth, state.tr);
        tr = liftSelectionList(state, tr);
        dispatch(tr);
        return true;
    }
};
/**
 * Implemetation taken and modified for our needs from PM
 * @param itemType Node
 * Splits the list items, specific implementation take from PM
 */
function splitListItem(itemType) {
    return function (state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var node = ref.node;
        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {
            return false;
        }
        var grandParent = $from.node(-1);
        if (grandParent.type !== itemType) {
            return false;
        }
        /** --> The following line changed from the original PM implementation to allow list additions with multiple paragraphs */
        if (grandParent.content.content.length <= 1 &&
            $from.parent.content.size === 0 &&
            !(grandParent.content.size === 0)) {
            // In an empty block. If this is a nested list, the wrapping
            // list item should be split. Otherwise, bail out and let next
            // command handle lifting.
            if ($from.depth === 2 ||
                $from.node(-3).type !== itemType ||
                $from.index(-2) !== $from.node(-2).childCount - 1) {
                return false;
            }
            if (dispatch) {
                var wrap = Fragment.empty;
                var keepItem = $from.index(-1) > 0;
                // Build a fragment containing empty versions of the structure
                // from the outer list item to the parent node of the cursor
                for (var d = $from.depth - (keepItem ? 1 : 2); d >= $from.depth - 3; d--) {
                    wrap = Fragment.from($from.node(d).copy(wrap));
                }
                // Add a second list item with an empty default start node
                wrap = wrap.append(Fragment.from(itemType.createAndFill()));
                var tr$1 = state.tr.replace($from.before(keepItem ? null : -1), $from.after(-3), new Slice(wrap, keepItem ? 3 : 2, 2));
                tr$1.setSelection(state.selection.constructor.near(tr$1.doc.resolve($from.pos + (keepItem ? 3 : 2))));
                dispatch(tr$1.scrollIntoView());
            }
            return true;
        }
        var nextType = $to.pos === $from.end() ? grandParent.defaultContentType(0) : null;
        var tr = state.tr.delete($from.pos, $to.pos);
        var types = nextType && [null, { type: nextType }];
        if (dispatch) {
            dispatch(tr.split($from.pos, 2, types).scrollIntoView());
        }
        return true;
    };
}
/**
 * The function will list paragraphs in selection out to level 1 below root list.
 */
function liftSelectionList(state, tr) {
    var _a = state.selection, from = _a.from, to = _a.to;
    var paragraph = state.schema.nodes.paragraph;
    var listCol = [];
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (node.type === paragraph) {
            listCol.push({ node: node, pos: pos });
        }
    });
    for (var i = listCol.length - 1; i >= 0; i--) {
        var paragraph_1 = listCol[i];
        var start = tr.doc.resolve(tr.mapping.map(paragraph_1.pos));
        if (start.depth > 0) {
            var end = void 0;
            if (paragraph_1.node.textContent && paragraph_1.node.textContent.length > 0) {
                end = tr.doc.resolve(tr.mapping.map(paragraph_1.pos + paragraph_1.node.textContent.length));
            }
            else {
                end = tr.doc.resolve(tr.mapping.map(paragraph_1.pos + 1));
            }
            var range = start.blockRange(end);
            tr.lift(range, listLiftTarget(state.schema, start));
        }
    }
    return tr;
}
/**
 * This will return (depth - 1) for root list parent of a list.
 */
function listLiftTarget(schema, resPos) {
    var target = resPos.depth;
    var _a = schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, listItem = _a.listItem;
    for (var i = resPos.depth; i > 0; i--) {
        var node = resPos.node(i);
        if (node.type === bulletList || node.type === orderedList) {
            target = i;
        }
        if (node.type !== bulletList &&
            node.type !== orderedList &&
            node.type !== listItem) {
            break;
        }
    }
    return target - 1;
}
//# sourceMappingURL=commands.js.map