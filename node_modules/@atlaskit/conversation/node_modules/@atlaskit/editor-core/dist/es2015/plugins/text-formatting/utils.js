export var nodeLen = function (node) {
    return node.nodeType === 3 && node.nodeValue
        ? node.nodeValue.length
        : node.childNodes.length;
};
export var isIgnorable = function (dom) {
    return dom.pmViewDesc && dom.pmViewDesc.size === 0;
};
export var isBlockNode = function (dom) {
    var desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
};
export var domIndex = function (node) {
    if (node) {
        for (var index = 0;; index++) {
            node = node.previousSibling;
            if (!node) {
                return index;
            }
        }
    }
};
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
export var removeIgnoredNodesLeft = function (view) {
    var sel = view.root.getSelection();
    var node = sel.anchorNode;
    var offset = sel.anchorOffset;
    var removeNode;
    // TODO: un-ignore it
    // @ts-ignore
    var removeOffset;
    if (!node) {
        return;
    }
    for (;;) {
        if (offset > 0) {
            if (node.nodeType !== 1) {
                // zero-width non-breaking space
                if (node.nodeType === 3 &&
                    node.nodeValue.charAt(offset - 1) === '\ufeff') {
                    removeNode = node;
                    removeOffset = --offset;
                }
                else {
                    break;
                }
            }
            else {
                var before = node.childNodes[offset - 1];
                if (isIgnorable(before)) {
                    removeNode = before;
                    removeOffset = --offset;
                }
                else if (before.nodeType === 3) {
                    node = before;
                    offset = node.nodeValue.length;
                }
                else {
                    break;
                }
            }
        }
        else if (isBlockNode(node)) {
            break;
        }
        else {
            var prev = node.previousSibling;
            while (prev && isIgnorable(prev)) {
                removeNode = node.parentNode;
                removeOffset = domIndex(prev);
                prev = prev.previousSibling;
            }
            if (!prev) {
                node = node.parentNode;
                if (node === view.dom) {
                    break;
                }
                offset = 0;
            }
            else {
                node = prev;
                offset = nodeLen(node);
            }
        }
    }
    if (removeNode) {
        removeNode.parentNode.removeChild(removeNode);
    }
};
export var hasCode = function (state, pos) {
    var code = state.schema.marks.code;
    var node = pos >= 0 && state.doc.nodeAt(pos);
    if (node) {
        return !!node.marks.filter(function (mark) { return mark.type === code; }).length;
    }
    return false;
};
//# sourceMappingURL=utils.js.map