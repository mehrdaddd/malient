import * as tslib_1 from "tslib";
import * as React from 'react';
import { Component } from 'react';
import { isRowSelected, selectRow, isTableSelected } from 'prosemirror-utils';
import { RowInner, RowContainer, RowControlsButtonWrap, HeaderButton, } from './styles';
import InsertRowButton from './InsertRowButton';
import { getLineMarkerWidth, findRowSelection } from '../utils';
import DeleteRowButton from './DeleteRowButton';
var RowControls = /** @class */ (function (_super) {
    tslib_1.__extends(RowControls, _super);
    function RowControls() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { dangerRows: [] };
        _this.selectRow = function (row) {
            var _a = _this.props.editorView, state = _a.state, dispatch = _a.dispatch;
            dispatch(selectRow(row)(state.tr));
            _this.resetHoverSelection();
        };
        _this.hoverRows = function (rows, danger) {
            var _a = _this.props.editorView, state = _a.state, dispatch = _a.dispatch;
            _this.setState({ dangerRows: danger ? rows : [] });
            _this.props.hoverRows(rows, danger)(state, dispatch);
        };
        _this.resetHoverSelection = function () {
            var _a = _this.props.editorView, state = _a.state, dispatch = _a.dispatch;
            _this.setState({ dangerRows: [] });
            _this.props.resetHoverSelection(state, dispatch);
        };
        _this.insertRow = function (row) {
            var _a = _this.props.editorView, state = _a.state, dispatch = _a.dispatch;
            _this.props.insertRow(row)(state, dispatch);
            _this.resetHoverSelection();
        };
        return _this;
    }
    RowControls.prototype.createDeleteRowButton = function (selection, offsetHeight, selectionHeight) {
        var _this = this;
        var selectedRowIdxs = [];
        for (var i = 0; i < selection.count; i++) {
            selectedRowIdxs.push(selection.startIdx + i);
        }
        return (React.createElement(DeleteRowButton, { key: "delete", onClick: function () {
                _this.props.remove();
                _this.resetHoverSelection();
            }, onMouseEnter: function () {
                _this.hoverRows(selectedRowIdxs, true);
                _this.props.updateScroll();
            }, onMouseLeave: function () { return _this.hoverRows(selectedRowIdxs); }, style: {
                top: offsetHeight + selectionHeight / 2 + 2,
            } }));
    };
    RowControls.prototype.createDeleteRowButtonForSelection = function (selection, rows) {
        // find the offset before
        var selectionGroupOffset = 0;
        var selectionGroupHeight = 0;
        for (var i = 0; i < selection.startIdx; i++) {
            selectionGroupOffset += rows[i].offsetHeight;
        }
        // find the height of the selected rows
        for (var i = selection.startIdx; i <= selection.endIdx; i++) {
            selectionGroupHeight += rows[i].offsetHeight;
        }
        return this.createDeleteRowButton(selection, selectionGroupOffset, selectionGroupHeight);
    };
    RowControls.prototype.render = function () {
        var _this = this;
        var _a = this.props, tableElement = _a.tableElement, state = _a.editorView.state, isTableHovered = _a.isTableHovered, scroll = _a.scroll, isTableInDanger = _a.isTableInDanger;
        if (!tableElement) {
            return null;
        }
        var tbody = tableElement.querySelector('tbody');
        if (!tbody) {
            return null;
        }
        var rows = tbody.getElementsByTagName('tr');
        var nodes = [];
        var lineMarkerWidth = getLineMarkerWidth(tableElement, scroll);
        var prevRowHeights = 0;
        var selection = findRowSelection(state, rows);
        var _loop_1 = function (i, len) {
            var onlyThisRowSelected = selection.inSelection(i) &&
                !isTableSelected(state.selection) &&
                !selection.hasMultipleSelection;
            var classNames = isTableHovered || isRowSelected(i)(state.selection) ? ['active'] : [''];
            if (this_1.state.dangerRows.indexOf(i) !== -1 || isTableInDanger) {
                classNames.push('danger');
            }
            nodes.push(React.createElement(RowControlsButtonWrap, { key: i, className: classNames.join(' ') + " table-row", style: { height: rows[i].offsetHeight + 1 } },
                React.createElement(HeaderButton, { onClick: function () { return _this.selectRow(i); }, onMouseOver: function () { return _this.hoverRows([i]); }, onMouseOut: this_1.resetHoverSelection }),
                !(selection.hasMultipleSelection && selection.frontOfSelection(i)) ? (React.createElement(InsertRowButton, { onClick: function () { return _this.insertRow(i + 1); }, lineMarkerWidth: lineMarkerWidth, onMouseOver: this_1.props.updateScroll })) : null), onlyThisRowSelected
                ? this_1.createDeleteRowButton(selection, prevRowHeights, rows[i].offsetHeight)
                : null);
            prevRowHeights += rows[i].offsetHeight;
        };
        var this_1 = this;
        for (var i = 0, len = rows.length; i < len; i++) {
            _loop_1(i, len);
        }
        // in the case for a multiple selection, draw a single button at the end instead
        if (selection.hasMultipleSelection && !isTableSelected(state.selection)) {
            nodes.push(this.createDeleteRowButtonForSelection(selection, rows));
        }
        return (React.createElement(RowContainer, null,
            React.createElement(RowInner, null, nodes)));
    };
    return RowControls;
}(Component));
export default RowControls;
//# sourceMappingURL=index.js.map