import * as tslib_1 from "tslib";
import * as React from 'react';
import { PureComponent } from 'react';
import styled from 'styled-components';
import OpenIcon from '@atlaskit/icon/glyph/editor/open';
import UnlinkIcon from '@atlaskit/icon/glyph/editor/unlink';
import { removeFakeTextCursor } from '../../../fake-text-cursor/cursor';
import PanelTextInput from '../../../../ui/PanelTextInput';
import UiToolbarButton from '../../../../ui/ToolbarButton';
import UiFloatingToolbar from '../../../../ui/FloatingToolbar';
import UiSeparator from '../../../../ui/Separator';
import { normalizeUrl } from '../../utils';
import RecentSearch from '../RecentSearch';
var TEXT_NODE = 3;
// `line-height: 1` to fix extra 1px height from toolbar wrapper
var FloatingToolbar = styled(UiFloatingToolbar)(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n  max-height: 350px;\n  min-height: 32px;\n  height: initial;\n  & > div {\n    line-height: 1;\n  }\n  & > div > button:last-child {\n    margin-right: 0;\n  }\n  .normal& input {\n    min-width: 244px;\n    margin-right: 2px;\n  }\n  .recent-search& {\n    padding: 8px 0 0;\n    input {\n      padding: 0 8px 8px;\n    }\n  }\n"], ["\n  max-height: 350px;\n  min-height: 32px;\n  height: initial;\n  & > div {\n    line-height: 1;\n  }\n  & > div > button:last-child {\n    margin-right: 0;\n  }\n  .normal& input {\n    min-width: 244px;\n    margin-right: 2px;\n  }\n  .recent-search& {\n    padding: 8px 0 0;\n    input {\n      padding: 0 8px 8px;\n    }\n  }\n"])));
// `a&` because `Button` uses it and it produces a more specific selector `a.xyz`
var ToolbarButton = styled(UiToolbarButton)(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject(["\n  width: 24px;\n  padding: 0;\n  margin: 0 2px;\n  a& {\n    width: 24px;\n    margin: 0 2px;\n  }\n"], ["\n  width: 24px;\n  padding: 0;\n  margin: 0 2px;\n  a& {\n    width: 24px;\n    margin: 0 2px;\n  }\n"])));
// Need fixed height because parent has height inherit and `height: 100%` doesn't work because of that
var Separator = styled(UiSeparator)(templateObject_3 || (templateObject_3 = tslib_1.__makeTemplateObject(["\n  margin: 2px 6px;\n  height: 20px;\n"], ["\n  margin: 2px 6px;\n  height: 20px;\n"])));
var HyperlinkEdit = /** @class */ (function (_super) {
    tslib_1.__extends(HyperlinkEdit, _super);
    function HyperlinkEdit() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            unlinkable: true,
            editorFocused: false,
            inputActive: false,
            active: false,
            showToolbarPanel: false,
        };
        _this.setInputActive = function () {
            _this.setState({
                inputActive: true,
            });
        };
        _this.resetInputActive = function () {
            _this.setState({
                inputActive: false,
            });
            if (!_this.state.editorFocused) {
                var editorView = _this.props.editorView;
                removeFakeTextCursor(editorView.state, editorView.dispatch);
            }
        };
        _this.posHasMark = function (pos, markType) {
            return pos.marks().some(function (mark) { return mark.type === markType; });
        };
        /**
         * Dynamic offsets for hyperlink editing popup
         * because we need to show it next to cursor even without clear target for popup.
         */
        _this.adjustPosition = function (position) {
            var pluginState = _this.props.pluginState;
            if (!pluginState.active) {
                var editorRoot = _this.getOffsetParent();
                if (!editorRoot) {
                    return position;
                }
                var coordinates = pluginState.getCoordinates(_this.props.editorView, editorRoot);
                if (position.left) {
                    position.left = Math.round(coordinates.left);
                }
                if (position.top) {
                    position.top = Math.round(coordinates.top);
                }
                if (position.bottom) {
                    position.bottom = Math.round(coordinates.bottom);
                }
                if (position.right) {
                    position.right = Math.round(coordinates.right);
                }
            }
            return position;
        };
        // ED-1323 `onBlur` covers all the use cases (click outside, tab, etc) for this issue
        _this.handleOnBlur = function () {
            var _a = _this.props, editorView = _a.editorView, pluginState = _a.pluginState;
            var _b = _this.state, href = _b.href, text = _b.text;
            if (editorView.state.selection.empty && !pluginState.active) {
                pluginState.hideLinkPanel(editorView.state, editorView.dispatch);
            }
            else if (!href || href.length === 0) {
                pluginState.removeLink(editorView);
            }
            else {
                if (text && pluginState.text !== text) {
                    pluginState.updateLinkText(text, editorView);
                    _this.setState({ text: '' });
                }
                if (href && pluginState.href !== href) {
                    pluginState.updateLink({ href: href }, editorView);
                }
            }
            _this.resetInputActive();
        };
        _this.handleUnlink = function () {
            _this.props.pluginState.removeLink(_this.props.editorView);
        };
        _this.handlePluginStateChange = function (pluginState) {
            var inputActive = _this.state.inputActive;
            var hrefNotPreset = pluginState.active &&
                (!pluginState.href || pluginState.href.length === 0);
            _this.setState({
                active: pluginState.active,
                target: pluginState.element,
                activeElement: pluginState.activeElement,
                href: pluginState.href,
                oldText: pluginState.text,
                oldHref: pluginState.href,
                textInputValue: pluginState.text,
                editorFocused: pluginState.editorFocused,
                inputActive: hrefNotPreset || inputActive,
                showToolbarPanel: pluginState.showToolbarPanel,
            });
        };
        _this.updateHref = function (href) {
            _this.setState({ href: href });
        };
        _this.updateText = function (text) {
            _this.setState({ text: text });
        };
        _this.updateLinkText = function (text) {
            if (text && text.length > 0 && text !== _this.state.oldText) {
                var _a = _this.props, editorView = _a.editorView, pluginState = _a.pluginState;
                pluginState.updateLinkText(text, editorView);
                _this.setState({ text: '' });
            }
        };
        _this.updateLinkHref = function (href) {
            var _a = _this.props, editorView = _a.editorView, pluginState = _a.pluginState;
            if (_this.state.oldHref) {
                pluginState.updateLink({ href: href }, editorView);
            }
            else {
                pluginState.addLink({ href: href }, editorView);
            }
            editorView.focus();
        };
        return _this;
    }
    HyperlinkEdit.prototype.componentDidMount = function () {
        this.props.pluginState.subscribe(this.handlePluginStateChange);
    };
    HyperlinkEdit.prototype.componentWillUnmount = function () {
        this.props.pluginState.unsubscribe(this.handlePluginStateChange);
    };
    HyperlinkEdit.prototype.getOffsetParent = function () {
        return this.props.popupsMountPoint
            ? this.props.popupsMountPoint.offsetParent
            : this.props.editorView.dom.offsetParent;
    };
    HyperlinkEdit.prototype.getPopupTarget = function () {
        var editorView = this.props.editorView;
        var state = editorView.state;
        var node;
        var _a = state.selection, empty = _a.empty, $from = _a.$from, $to = _a.$to;
        var link = state.schema.marks.link;
        if (!empty && !this.posHasMark($from, link)) {
            for (var i = $from.pos; i <= $to.pos; i++) {
                if (this.posHasMark(state.doc.resolve(i), link)) {
                    node = editorView.domAtPos(i).node;
                }
            }
        }
        if (!node) {
            // Current position is fake cursor so we will look for the DOM right after our selection
            // Since putting cursor at the end of the link doesn't show the popup so it's safe
            node = editorView.domAtPos(state.selection.$from.pos).node;
        }
        var activeElement = node;
        return activeElement.nodeType === TEXT_NODE
            ? activeElement.parentElement
            : activeElement;
    };
    HyperlinkEdit.prototype.render = function () {
        var _a = this.state, href = _a.href, oldHref = _a.oldHref, unlinkable = _a.unlinkable, active = _a.active, editorFocused = _a.editorFocused, inputActive = _a.inputActive, showToolbarPanel = _a.showToolbarPanel;
        var _b = this.props, popupsBoundariesElement = _b.popupsBoundariesElement, popupsMountPoint = _b.popupsMountPoint, activityProvider = _b.activityProvider;
        var renderRecentSearch = activityProvider && !oldHref;
        if ((active || showToolbarPanel) && (editorFocused || inputActive)) {
            var popupTarget = this.getPopupTarget();
            if (!popupTarget) {
                return null;
            }
            var showOpenButton = !!oldHref;
            var showUnlinkButton = unlinkable && active && oldHref;
            return (React.createElement(FloatingToolbar, { alignX: "left", target: popupTarget, offset: [0, 12], fitHeight: renderRecentSearch ? 350 : 32, onPositionCalculated: this.adjustPosition, popupsBoundariesElement: popupsBoundariesElement, popupsMountPoint: popupsMountPoint, className: renderRecentSearch ? 'recent-search' : 'normal' },
                this.renderInput(),
                (showOpenButton || showUnlinkButton) && React.createElement(Separator, null),
                showOpenButton && (React.createElement(ToolbarButton, { spacing: "compact", href: href, target: "_blank", title: "Open link", iconBefore: React.createElement(OpenIcon, { label: "Open link" }) })),
                showUnlinkButton && (React.createElement(ToolbarButton, { spacing: "compact", onClick: this.handleUnlink, title: "Unlink", iconBefore: React.createElement(UnlinkIcon, { label: "Unlink" }) }))));
        }
        else {
            return null;
        }
    };
    HyperlinkEdit.prototype.renderInput = function () {
        var _a = this.state, href = _a.href, oldHref = _a.oldHref, text = _a.text, oldText = _a.oldText;
        var _b = this.props, editorView = _b.editorView, pluginState = _b.pluginState, activityProvider = _b.activityProvider;
        var normalizedOldText = oldText && normalizeUrl(oldText);
        // insert new link with recently viewed dropdown
        if (activityProvider && !oldHref) {
            return (React.createElement(RecentSearch, { editorView: editorView, pluginState: pluginState, activityProvider: activityProvider }));
        }
        // edit link text
        if (normalizedOldText && href === normalizedOldText) {
            return (React.createElement(PanelTextInput, { placeholder: "Text to display", defaultValue: !text && href === normalizedOldText ? '' : text, onSubmit: this.updateLinkText, onChange: this.updateText, onMouseDown: this.setInputActive, onBlur: this.handleOnBlur, onCancel: this.handleOnBlur }));
        }
        // edit link href when text has not been set
        return (React.createElement(PanelTextInput, { placeholder: "Paste link", autoFocus: !href || href.length === 0, defaultValue: href, onSubmit: this.updateLinkHref, onChange: this.updateHref, onMouseDown: this.setInputActive, onBlur: this.handleOnBlur, onCancel: this.handleOnBlur }));
    };
    return HyperlinkEdit;
}(PureComponent));
export default HyperlinkEdit;
var templateObject_1, templateObject_2, templateObject_3;
//# sourceMappingURL=index.js.map