import * as tslib_1 from "tslib";
import { Selection } from 'prosemirror-state';
import { DecorationSet } from 'prosemirror-view';
import { TableMap, selectionCell } from 'prosemirror-tables';
import { findTable, getCellsInColumn, getCellsInRow, getCellsInTable, addColumnAt, addRowAt, } from 'prosemirror-utils';
import { pluginKey as hoverSelectionPluginKey } from './pm-plugins/hover-selection-plugin';
import { stateKey as tablePluginKey } from './pm-plugins/main';
import { createHoverDecorationSet, getCellSelection, checkIfHeaderRowEnabled, checkIfHeaderColumnEnabled, } from './utils';
import { analyticsService } from '../../analytics';
export var resetHoverSelection = function (state, dispatch) {
    dispatch(state.tr.setMeta(hoverSelectionPluginKey, {
        decorationSet: DecorationSet.empty,
        isTableHovered: false,
    }));
    return true;
};
export var hoverColumns = function (columns, danger) { return function (state, dispatch) {
    var table = findTable(state.selection);
    if (table) {
        var cells = columns.reduce(function (acc, colIdx) {
            var colCells = getCellsInColumn(colIdx)(state.selection);
            return colCells ? acc.concat(colCells) : acc;
        }, []);
        dispatch(state.tr.setMeta(hoverSelectionPluginKey, {
            decorationSet: createHoverDecorationSet(cells, state, danger),
        }));
        return true;
    }
    return false;
}; };
export var hoverRows = function (rows, danger) { return function (state, dispatch) {
    var table = findTable(state.selection);
    if (table) {
        var cells = rows.reduce(function (acc, rowIdx) {
            var rowCells = getCellsInRow(rowIdx)(state.selection);
            return rowCells ? acc.concat(rowCells) : acc;
        }, []);
        dispatch(state.tr.setMeta(hoverSelectionPluginKey, {
            decorationSet: createHoverDecorationSet(cells, state, danger),
        }));
        return true;
    }
    return false;
}; };
export var hoverTable = function (danger) { return function (state, dispatch) {
    var table = findTable(state.selection);
    if (table) {
        var cells = getCellsInTable(state.selection);
        dispatch(state.tr.setMeta(hoverSelectionPluginKey, {
            decorationSet: createHoverDecorationSet(cells, state, danger),
            isTableHovered: true,
            isTableInDanger: danger,
        }));
        return true;
    }
    return false;
}; };
export var clearHoverTable = function (state, dispatch) {
    var table = findTable(state.selection);
    if (table) {
        dispatch(state.tr.setMeta(hoverSelectionPluginKey, {
            decorationSet: DecorationSet.empty,
            isTableHovered: false,
            isTableInDanger: false,
        }));
        return true;
    }
    return false;
};
export var clearSelection = function (state, dispatch) {
    dispatch(state.tr.setSelection(Selection.near(state.selection.$from)));
    return true;
};
export var toggleHeaderRow = function (state, dispatch) {
    var table = findTable(state.selection);
    if (!table) {
        return false;
    }
    var tr = state.tr;
    var map = TableMap.get(table.node);
    var _a = state.schema.nodes, tableHeader = _a.tableHeader, tableCell = _a.tableCell;
    var isNumberColumnEnabled = table.node.attrs.isNumberColumnEnabled;
    var isHeaderRowEnabled = checkIfHeaderRowEnabled(state);
    var isHeaderColumnEnabled = checkIfHeaderColumnEnabled(state);
    var type = isHeaderRowEnabled ? tableCell : tableHeader;
    for (var column = 0; column < table.node.child(0).childCount; column++) {
        // skip header column
        if (isHeaderColumnEnabled &&
            ((isNumberColumnEnabled && column === 1) ||
                (!isNumberColumnEnabled && column === 0))) {
            continue;
        }
        var from = tr.mapping.map(table.pos + map.map[column]);
        var cell = table.node.child(0).child(column);
        // empty first cell of the number column when converting to header row (remove "1")
        if (!isHeaderRowEnabled && isNumberColumnEnabled && column === 0) {
            tr.replaceWith(from, from + cell.nodeSize, tableHeader.createAndFill(cell.attrs));
        }
        else {
            tr.setNodeMarkup(from, type, cell.attrs);
        }
    }
    dispatch(tr);
    return true;
};
export var toggleHeaderColumn = function (state, dispatch) {
    var table = findTable(state.selection);
    if (!table) {
        return false;
    }
    var tr = state.tr;
    var map = TableMap.get(table.node);
    var _a = state.schema.nodes, tableHeader = _a.tableHeader, tableCell = _a.tableCell;
    var type = checkIfHeaderColumnEnabled(state) ? tableCell : tableHeader;
    // skip header row
    var startIndex = checkIfHeaderRowEnabled(state) ? 1 : 0;
    for (var row = startIndex; row < table.node.childCount; row++) {
        var column = table.node.attrs.isNumberColumnEnabled ? 1 : 0;
        var cell = table.node.child(row).child(column);
        tr.setNodeMarkup(table.pos + map.map[column + row * map.width], type, cell.attrs);
    }
    dispatch(tr);
    return true;
};
export var toggleNumberColumn = function (state, dispatch) {
    var tr = state.tr;
    var tableNode = tablePluginKey.getState(state).tableNode;
    var map = TableMap.get(tableNode);
    var start = findTable(state.selection).pos;
    if (tableNode.attrs.isNumberColumnEnabled) {
        // delete existing number column
        var mapStart = tr.mapping.maps.length;
        for (var i = 0, count = tableNode.childCount; i < count; i++) {
            var cell = tableNode.child(i).child(0);
            var pos = map.positionAt(i, 0, tableNode);
            var from = tr.mapping.slice(mapStart).map(start + pos);
            tr.delete(from, from + cell.nodeSize);
        }
        tr.setNodeMarkup(start - 1, state.schema.nodes.table, tslib_1.__assign({}, tableNode.attrs, { isNumberColumnEnabled: false }));
        dispatch(tr);
    }
    else {
        // insert number column
        var index = 1;
        var inserted = false;
        var _a = state.schema.nodes, tableHeader = _a.tableHeader, tableCell = _a.tableCell, paragraph = _a.paragraph;
        var isHeaderRowEnabled = checkIfHeaderRowEnabled(state);
        for (var i = 0, count = tableNode.childCount; i < count; i++) {
            var cell = tableNode.child(i).child(0);
            var from = map.positionAt(i, 0, tableNode);
            var content = cell.type === tableHeader && i === 0
                ? null
                : paragraph.createChecked({}, state.schema.text("" + index++));
            var type = isHeaderRowEnabled && i === 0 ? tableHeader : tableCell;
            if (content) {
                inserted = true;
            }
            tr.insert(tr.mapping.map(start + from), type.create({}, content));
        }
        if (inserted) {
            tr.setNodeMarkup(start - 1, state.schema.nodes.table, tslib_1.__assign({}, tableNode.attrs, { isNumberColumnEnabled: true }));
            dispatch(tr);
        }
    }
    return true;
};
export var setCellAttr = function (name, value) { return function (state, dispatch) {
    var tr = state.tr;
    var cellSelection = getCellSelection(state);
    if (cellSelection) {
        var updated_1 = false;
        cellSelection.forEachCell(function (cell, pos) {
            if (cell.attrs[name] !== value) {
                tr.setNodeMarkup(pos, cell.type, tslib_1.__assign({}, cell.attrs, (_a = {}, _a[name] = value, _a)));
                updated_1 = true;
            }
            var _a;
        });
        if (updated_1) {
            dispatch(tr);
            return true;
        }
    }
    else {
        var cell = selectionCell(state);
        if (cell) {
            dispatch(tr.setNodeMarkup(cell.pos, cell.nodeAfter.type, tslib_1.__assign({}, cell.nodeAfter.attrs, (_a = {}, _a[name] = value, _a))));
            return true;
        }
    }
    return false;
    var _a;
}; };
export var insertColumn = function (column) { return function (state, dispatch) {
    var tr = addColumnAt(column)(state.tr);
    var table = findTable(tr.selection);
    // move the cursor to the newly created column
    var pos = TableMap.get(table.node).positionAt(0, column, table.node);
    dispatch(tr.setSelection(Selection.near(tr.doc.resolve(table.pos + pos))));
    analyticsService.trackEvent('atlassian.editor.format.table.column.button');
    return true;
}; };
export var insertRow = function (row) { return function (state, dispatch) {
    var tr = addRowAt(row)(state.tr);
    var table = findTable(tr.selection);
    // move the cursor to the newly created row
    var pos = TableMap.get(table.node).positionAt(row, 0, table.node);
    dispatch(tr.setSelection(Selection.near(tr.doc.resolve(table.pos + pos))));
    analyticsService.trackEvent('atlassian.editor.format.table.row.button');
    return true;
}; };
//# sourceMappingURL=actions.js.map