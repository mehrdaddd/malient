import * as tslib_1 from "tslib";
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { withAnalytics } from '@atlaskit/analytics';
import { ProviderFactory } from '@atlaskit/editor-common';
import { getUiComponent } from './create-editor';
import EditorActions from './actions';
import { ReactEditorView } from './create-editor';
import EditorContext from './ui/EditorContext';
var Editor = /** @class */ (function (_super) {
    tslib_1.__extends(Editor, _super);
    function Editor(props, context) {
        var _this = _super.call(this, props) || this;
        _this.handleSave = function (view) {
            if (!_this.props.onSave) {
                return;
            }
            // ED-4021: if you type a short amount of content
            // inside a content-editable on Android, Chrome only sends a
            // compositionend when it feels like it.
            //
            // to work around the PM editable being out of sync with
            // the document, force a DOM sync before calling onSave
            // if we've already started typing
            if (view['inDOMChange']) {
                view['inDOMChange'].finish(true);
            }
            return _this.props.onSave(view);
        };
        _this.providerFactory = new ProviderFactory();
        _this.deprecationWarnings(props);
        _this.onEditorCreated = _this.onEditorCreated.bind(_this);
        _this.onEditorDestroyed = _this.onEditorDestroyed.bind(_this);
        _this.editorActions = (context || {}).editorActions || new EditorActions();
        return _this;
    }
    Editor.prototype.componentDidMount = function () {
        this.handleProviders(this.props);
    };
    Editor.prototype.componentWillReceiveProps = function (nextProps) {
        this.handleProviders(nextProps);
    };
    Editor.prototype.componentWillUnmount = function () {
        this.unregisterEditorFromActions();
        this.providerFactory.destroy();
    };
    Editor.prototype.onEditorCreated = function (instance) {
        this.registerEditorForActions(instance.view, instance.eventDispatcher, instance.transformer);
        if (this.props.shouldFocus) {
            if (!instance.view.hasFocus()) {
                instance.view.focus();
            }
        }
    };
    Editor.prototype.deprecationWarnings = function (props) {
        if (props.hasOwnProperty('allowHyperlinks')) {
            // tslint:disable-next-line:no-console
            console.warn("allowHyperlinks property is deprecated. It's safe to remove it because hyperlink plugin is enabled by default.");
        }
        if (props.hasOwnProperty('allowTextFormatting')) {
            // tslint:disable-next-line:no-console
            console.warn('allowTextFormatting property is deprecated. TextFormatting plugin is enabled by default. If you need to pass options to textFormatting plugin use `textFormatting={{ textFormattingOptions }}` [Will be removed in editor-core@63.0.0]');
        }
    };
    Editor.prototype.onEditorDestroyed = function (instance) {
        this.unregisterEditorFromActions();
    };
    Editor.prototype.registerEditorForActions = function (editorView, eventDispatcher, contentTransformer) {
        this.editorActions._privateRegisterEditor(editorView, eventDispatcher, contentTransformer);
    };
    Editor.prototype.unregisterEditorFromActions = function () {
        if (this.editorActions) {
            this.editorActions._privateUnregisterEditor();
        }
    };
    Editor.prototype.handleProviders = function (props) {
        var emojiProvider = props.emojiProvider, mentionProvider = props.mentionProvider, mediaProvider = props.mediaProvider, taskDecisionProvider = props.taskDecisionProvider, contextIdentifierProvider = props.contextIdentifierProvider, collabEditProvider = props.collabEditProvider, activityProvider = props.activityProvider, presenceProvider = props.presenceProvider, macroProvider = props.macroProvider, legacyImageUploadProvider = props.legacyImageUploadProvider, media = props.media, collabEdit = props.collabEdit;
        this.providerFactory.setProvider('emojiProvider', emojiProvider);
        this.providerFactory.setProvider('mentionProvider', mentionProvider);
        this.providerFactory.setProvider('taskDecisionProvider', taskDecisionProvider);
        this.providerFactory.setProvider('contextIdentifierProvider', contextIdentifierProvider);
        this.providerFactory.setProvider('mediaProvider', media && media.provider ? media.provider : mediaProvider);
        this.providerFactory.setProvider('imageUploadProvider', legacyImageUploadProvider);
        this.providerFactory.setProvider('collabEditProvider', collabEdit && collabEdit.provider
            ? collabEdit.provider
            : collabEditProvider);
        this.providerFactory.setProvider('activityProvider', activityProvider);
        this.providerFactory.setProvider('presenceProvider', presenceProvider);
        this.providerFactory.setProvider('macroProvider', macroProvider);
    };
    Editor.prototype.render = function () {
        var _this = this;
        var Component = getUiComponent(this.props.appearance);
        var overriddenEditorProps = tslib_1.__assign({}, this.props, { onSave: this.props.onSave ? this.handleSave : undefined });
        return (React.createElement(EditorContext, { editorActions: this.editorActions },
            React.createElement(ReactEditorView, { editorProps: overriddenEditorProps, providerFactory: this.providerFactory, onEditorCreated: this.onEditorCreated, onEditorDestroyed: this.onEditorDestroyed, render: function (_a) {
                    var editor = _a.editor, view = _a.view, eventDispatcher = _a.eventDispatcher, config = _a.config;
                    return (React.createElement(Component, { disabled: _this.props.disabled, editorActions: _this.editorActions, editorDOMElement: editor, editorView: view, providerFactory: _this.providerFactory, eventDispatcher: eventDispatcher, maxHeight: _this.props.maxHeight, onSave: _this.props.onSave ? _this.handleSave : undefined, onCancel: _this.props.onCancel, popupsMountPoint: _this.props.popupsMountPoint, popupsBoundariesElement: _this.props.popupsBoundariesElement, contentComponents: config.contentComponents, primaryToolbarComponents: config.primaryToolbarComponents, secondaryToolbarComponents: config.secondaryToolbarComponents, insertMenuItems: _this.props.insertMenuItems, customContentComponents: _this.props.contentComponents, customPrimaryToolbarComponents: _this.props.primaryToolbarComponents, customSecondaryToolbarComponents: _this.props.secondaryToolbarComponents, addonToolbarComponents: _this.props.addonToolbarComponents, collabEdit: _this.props.collabEdit }));
                } })));
    };
    Editor.defaultProps = {
        appearance: 'message',
        disabled: false,
        extensionHandlers: {},
    };
    Editor.contextTypes = {
        editorActions: PropTypes.object,
    };
    return Editor;
}(React.Component));
export default Editor;
export var EditorWithAnalytics = withAnalytics(Editor, {}, {}, true);
//# sourceMappingURL=editor.js.map