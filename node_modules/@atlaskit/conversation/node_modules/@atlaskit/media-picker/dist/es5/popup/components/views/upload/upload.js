"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var react_1 = require("react");
var react_redux_1 = require("react-redux");
var media_card_1 = require("@atlaskit/media-card");
var spinner_1 = require("@atlaskit/spinner");
var flag_1 = require("@atlaskit/flag");
var annotate_1 = require("@atlaskit/icon/glyph/media-services/annotate");
var error_1 = require("@atlaskit/icon/glyph/error");
var isImage_1 = require("../../../tools/isImage");
var webgl_1 = require("../../../tools/webgl");
var dropzone_1 = require("./dropzone");
var fileClick_1 = require("../../../actions/fileClick");
var editorShowImage_1 = require("../../../actions/editorShowImage");
var editRemoteImage_1 = require("../../../actions/editRemoteImage");
var phrases_1 = require("../editor/phrases");
var styled_1 = require("./styled");
var createEditCardAction = function (handler) {
    return {
        label: phrases_1.menuEdit,
        handler: handler,
        icon: React.createElement(annotate_1.default, { label: phrases_1.menuEdit, size: "small" }),
    };
};
var cardDimension = { width: 162, height: 108 };
var StatelessUploadView = /** @class */ (function (_super) {
    tslib_1.__extends(StatelessUploadView, _super);
    function StatelessUploadView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            imageIds: [],
            hasPopupBeenVisible: false,
            isWebGLWarningFlagVisible: false,
            shouldDismissWebGLWarningFlag: false,
        };
        _this.loadingView = function () {
            return (React.createElement(styled_1.SpinnerWrapper, null,
                React.createElement(spinner_1.default, { size: "large" })));
        };
        _this.renderWebGLWarningFlag = function () { return (React.createElement(flag_1.FlagGroup, { onDismissed: _this.onFlagDismissed },
            React.createElement(flag_1.default, { shouldDismiss: _this.state.shouldDismissWebGLWarningFlag, description: "Your browser does not support WebGL. Use a WebGL enabled browser to annotate images.", icon: React.createElement(error_1.default, { label: "info" }), id: "webgl-warning-flag", title: "You're unable to annotate this image", actions: [{ content: 'Learn More', onClick: _this.onLearnMoreClicked }] }))); };
        _this.onCardLoadingChanged = function (cardLoadingState) {
            var payload = cardLoadingState.payload;
            var type = cardLoadingState.type;
            if (type === 'complete' && payload && payload.mediaType === 'image') {
                var imageIds = _this.state.imageIds.concat(payload.id);
                _this.setState({ imageIds: imageIds });
            }
        };
        _this.onFlagDismissed = function () {
            _this.setState({ isWebGLWarningFlagVisible: false });
        };
        _this.onLearnMoreClicked = function () {
            _this.setState({ shouldDismissWebGLWarningFlag: true });
            _this.onFlagDismissed();
            window.open('https://get.webgl.org/');
        };
        return _this;
    }
    StatelessUploadView.prototype.render = function () {
        var isLoading = this.props.isLoading;
        var cards = this.renderCards();
        var isEmpty = !isLoading && cards.length === 0;
        var contentPart = null;
        if (isLoading) {
            contentPart = this.loadingView();
        }
        else if (!isEmpty) {
            contentPart = this.recentView(cards);
        }
        return (React.createElement(styled_1.Wrapper, null,
            React.createElement(dropzone_1.Dropzone, { isEmpty: isEmpty, mpBrowser: this.props.mpBrowser }),
            contentPart));
    };
    StatelessUploadView.prototype.recentView = function (cards) {
        return (React.createElement("div", null,
            React.createElement(styled_1.RecentUploadsTitle, null, "Recent Uploads"),
            React.createElement(styled_1.CardsWrapper, null, cards),
            this.state.isWebGLWarningFlagVisible
                ? this.renderWebGLWarningFlag()
                : null));
    };
    StatelessUploadView.prototype.onAnnotateActionClick = function (callback) {
        var _this = this;
        return function () {
            if (webgl_1.isWebGLAvailable()) {
                callback();
            }
            else {
                _this.showWebGLWarningFlag();
            }
        };
    };
    StatelessUploadView.prototype.renderCards = function () {
        var recentFilesCards = this.recentFilesCards();
        var uploadingFilesCards = this.uploadingFilesCards();
        return uploadingFilesCards
            .concat(recentFilesCards)
            .map(function (_a) {
            var key = _a.key, card = _a.el;
            return React.createElement(styled_1.CardWrapper, { key: key }, card);
        });
    };
    StatelessUploadView.prototype.uploadingFilesCards = function () {
        var _this = this;
        var _a = this.props, uploads = _a.uploads, onFileClick = _a.onFileClick, onEditorShowImage = _a.onEditorShowImage;
        var itemsKeys = Object.keys(uploads);
        itemsKeys.sort(function (a, b) {
            return uploads[b].index - uploads[a].index;
        });
        var selectedUploadIds = this.props.selectedItems
            .filter(function (item) { return item.serviceName === 'upload'; })
            .map(function (item) { return item.id; });
        return itemsKeys.map(function (key) {
            var item = _this.props.uploads[key];
            var progress = item.progress, file = item.file;
            var dataURI = file.dataURI;
            var mediaType = isImage_1.isImage(file.metadata.mimeType) ? 'image' : 'unknown';
            var fileMetadata = tslib_1.__assign({}, file.metadata, { mimeType: mediaType });
            // mimeType
            var id = fileMetadata.id;
            var selected = selectedUploadIds.indexOf(id) > -1;
            var status = progress !== null ? 'uploading' : 'complete';
            var onClick = function () { return onFileClick(fileMetadata, 'upload'); };
            var actions = [];
            if (mediaType === 'image' && dataURI) {
                actions.push(createEditCardAction(_this.onAnnotateActionClick(function () {
                    return onEditorShowImage(fileMetadata, dataURI);
                })));
            }
            var metadata = tslib_1.__assign({}, file.metadata, { mediaType: mediaType });
            return {
                key: id,
                el: (React.createElement(media_card_1.CardView, { status: status, progress: progress || undefined, mediaItemType: 'file', metadata: metadata, dimensions: cardDimension, selectable: true, selected: selected, dataURI: dataURI, onClick: onClick, actions: actions })),
            };
        });
    };
    StatelessUploadView.prototype.recentFilesCards = function () {
        var _this = this;
        var _a = this.props, context = _a.context, recents = _a.recents, recentsCollection = _a.recentsCollection, selectedItems = _a.selectedItems, onFileClick = _a.onFileClick, onEditRemoteImage = _a.onEditRemoteImage;
        var items = recents.items;
        var selectedRecentFiles = selectedItems
            .filter(function (item) { return item.serviceName === 'recent_files'; })
            .map(function (item) { return item.id; });
        var onClick = function (_a) {
            var mediaItemDetails = _a.mediaItemDetails;
            var fileDetails = mediaItemDetails;
            if (fileDetails) {
                onFileClick({
                    id: fileDetails.id,
                    name: fileDetails.name || '',
                    mimeType: fileDetails.mimeType || '',
                    size: fileDetails.size || 0,
                }, 'recent_files');
            }
        };
        var onLoadingChange = this.onCardLoadingChanged;
        var editHandler = function (mediaItem) {
            if (mediaItem.type === 'file') {
                var _a = mediaItem.details, id = _a.id, name_1 = _a.name;
                if (webgl_1.isWebGLAvailable()) {
                    onEditRemoteImage({
                        id: id,
                        name: name_1 || '',
                    }, recentsCollection);
                }
                else {
                    // WebGL not available - show warning flag
                    _this.showWebGLWarningFlag();
                }
            }
        };
        return items.map(function (item) {
            var id = item.id, occurrenceKey = item.occurrenceKey;
            var selected = selectedRecentFiles.indexOf(id) > -1;
            var actions = [];
            if (_this.state.imageIds.indexOf(id) > -1) {
                actions.push(createEditCardAction(editHandler));
            }
            return {
                key: occurrenceKey + "-" + id,
                el: (React.createElement(media_card_1.Card, { context: context, identifier: {
                        mediaItemType: 'file',
                        id: id,
                        collectionName: recentsCollection,
                    }, dimensions: cardDimension, selectable: true, selected: selected, onClick: onClick, actions: actions, onLoadingChange: onLoadingChange })),
            };
        });
    };
    StatelessUploadView.prototype.showWebGLWarningFlag = function () {
        this.setState({ isWebGLWarningFlagVisible: true });
    };
    return StatelessUploadView;
}(react_1.Component));
exports.StatelessUploadView = StatelessUploadView;
var mapStateToProps = function (state) { return ({
    isLoading: state.view.isLoading,
    recents: state.recents,
    uploads: state.uploads,
    selectedItems: state.selectedItems,
    apiUrl: state.apiUrl,
}); };
var mapDispatchToProps = function (dispatch) { return ({
    onFileClick: function (_a, serviceName) {
        var id = _a.id, mimeType = _a.mimeType, name = _a.name, size = _a.size;
        return dispatch(fileClick_1.fileClick({
            date: 0,
            id: id,
            mimeType: mimeType,
            name: name,
            size: size,
        }, serviceName));
    },
    onEditorShowImage: function (file, dataUri) {
        return dispatch(editorShowImage_1.editorShowImage(dataUri, file));
    },
    onEditRemoteImage: function (file, collectionName) {
        return dispatch(editRemoteImage_1.editRemoteImage(file, collectionName));
    },
}); };
exports.default = react_redux_1.connect(mapStateToProps, mapDispatchToProps)(StatelessUploadView);
//# sourceMappingURL=upload.js.map