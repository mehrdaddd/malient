// TODO: Create a PR for herment, so we wouldn't need to have the library here â€” FIL-2022
var utils = {
    internalStorage: {
        storage: {},
        getItem: function (key) {
            return this.storage[key];
        },
        setItem: function (key, value) {
            this.storage[key] = value;
        },
        clear: function () {
            this.storage = {};
        },
    },
    getLocalStorage: function () {
        return window.localStorage;
    },
    getSessionStorage: function () {
        return window.sessionStorage;
    },
    getInternalStorage: function () {
        return this.internalStorage;
    },
    getStorage: function () {
        try {
            var localStorage_1 = this.getLocalStorage();
            if (localStorage_1) {
                return localStorage_1;
            }
            var sessionStorage_1 = this.getSessionStorage();
            if (sessionStorage_1) {
                return sessionStorage_1;
            }
        }
        catch (err) {
            return this.getInternalStorage();
        }
    },
    isCORSRequest: function (url) {
        var parser = document.createElement('a');
        parser.href = url;
        return parser.host !== window.location.host;
    },
    getCookieValue: function (name) {
        var nameEQ = name + '=';
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    },
};
var HermentImpl = /** @class */ (function () {
    function HermentImpl(options) {
        var _this = this;
        this.STORAGE_KEY_PREAMBLE = 'herment';
        this.MAXEVENTS = 100;
        this.PUBLISH_INTERVAL = 5000;
        this.SAVE_INTERVAL = 1000;
        this.isStarted = false;
        this.config = this.parseConfig(options);
        this.storage = utils.getStorage();
        window.addEventListener('unload', function () { return _this.moveQueueToStorage(); });
    }
    /**
     * Retrieves the __atl_path cookie value
     */
    HermentImpl.prototype.getAtlPath = function () {
        return utils.getCookieValue('__atl_path');
    };
    /**
     * Identifies the server name by the url and returns
     * Called in publish
     */
    HermentImpl.prototype.getServerName = function () {
        return document.location.hostname;
    };
    /**
     * Computes server name based on the serverName
     * Called in publish
     */
    HermentImpl.prototype.getProductNameFromServerName = function (localServerName) {
        if (localServerName !== undefined) {
            return localServerName
                .replace('.com', '')
                .replace('.net', '')
                .replace('.org', '')
                .replace('.au', '')
                .replace('.io', '');
        }
        return '-';
    };
    /**
     * Extracts sub-domain or '-'
     * Called in addEventsToArray
     */
    HermentImpl.prototype.getSubdomain = function (fullServerName) {
        var domain = fullServerName.match(/^([a-z0-9\.]*)[\-\.]{1}([a-z0-9]+)+\.([a-z]{2,6})$/i);
        if (domain) {
            var parts = fullServerName.split('.');
            if (parts[parts.length - 1].length === 2) {
                parts = parts.slice(0, parts.length - 3);
            }
            else {
                parts = parts.slice(0, parts.length - 2);
            }
            if (parts.length !== 0) {
                return parts.join('.');
            }
        }
        return '-';
    };
    /**
     * Generate random number that's
     *  - unique
     *  - limited to 20 characters
     */
    HermentImpl.prototype.generateRandomStorageKey = function () {
        var stringSliceIndex1 = 2;
        var stringSliceIndex2 = 12;
        var firstHalf = (Math.random() + '').slice(stringSliceIndex1, stringSliceIndex2);
        var secondHalf = (Math.random() + '').slice(stringSliceIndex1, stringSliceIndex2);
        return firstHalf.concat(secondHalf);
    };
    /**
     * ajax simple no-jquery post with fixed headers
     */
    HermentImpl.prototype.ajaxPost = function (postUrl, postBody) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', postUrl, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.setRequestHeader('Accept', 'application/json, text/javascript, */*;');
        xhr.send(postBody);
    };
    HermentImpl.prototype.parseConfig = function (options) {
        if (options === void 0) { options = {}; }
        var castedWindow = window;
        var ajsQueue = castedWindow.AJS ? castedWindow.AJS.EventQueue : [];
        var queue = options.queue || ajsQueue;
        var gasScheme = options.analyticsscheme || 'https';
        var gasServer = options.analyticsserver || 'analytics.atlassian.com';
        var gasUrl = options.analyticsurl || '/analytics/events';
        var serverName = options.server || this.getServerName();
        var productName = options.product || this.getProductNameFromServerName(serverName);
        var subProductName = options.subproduct || this.getSubdomain(serverName) || '-';
        var version = options.version;
        var session = options.session;
        var sen = options.sen;
        var sourceIP = options.sourceIP;
        var atlPath = options.atlpath || this.getAtlPath();
        var ajax = options.ajax || this.ajaxPost;
        var maxevents = options.maxevents || this.MAXEVENTS;
        var storageKey = options.storage_key ||
            this.STORAGE_KEY_PREAMBLE +
                this.generateRandomStorageKey() +
                this.generateRandomStorageKey();
        var user = options.user || 'default';
        var publishInterval = options.publish_interval || this.PUBLISH_INTERVAL;
        var saveInterval = options.save_interval || this.SAVE_INTERVAL;
        return {
            queue: queue,
            gasScheme: gasScheme,
            gasServer: gasServer,
            gasUrl: gasUrl,
            serverName: serverName,
            productName: productName,
            subProductName: subProductName,
            version: version,
            session: session,
            sen: sen,
            sourceIP: sourceIP,
            atlPath: atlPath,
            post: ajax,
            maxevents: maxevents,
            storageKey: storageKey,
            user: user,
            publishInterval: publishInterval,
            saveInterval: saveInterval,
        };
    };
    /**
     * Does the actual ajax call to the server
     */
    HermentImpl.prototype.pushToServer = function (events, ajaxCall) {
        var _a = this.config, gasScheme = _a.gasScheme, gasServer = _a.gasServer, gasUrl = _a.gasUrl;
        var ajax = ajaxCall || this.config.post;
        var postTo = gasScheme + '://' + gasServer + gasUrl;
        var postString = JSON.stringify({ events: events });
        ajax(postTo, postString);
    };
    /**
     * Supplementary function; Adds all events from a given array, to the destination one.
     * Adds a few common parameters to each of the events
     */
    HermentImpl.prototype.addEventsToArray = function (inputEvents, resultingArray, state) {
        if (!state ||
            !state.server ||
            !state.product ||
            !state.subproduct ||
            !state.user) {
            return;
        }
        for (var i in inputEvents) {
            if (inputEvents.hasOwnProperty(i)) {
                var e = inputEvents[i];
                if (resultingArray.length >= this.config.maxevents) {
                    return;
                }
                if (e.name && e.properties) {
                    // check and update event contents
                    var event_1 = {
                        name: e.name,
                        properties: e.properties,
                        serverTime: e.time || new Date().getTime(),
                        server: state.server,
                        user: state.user,
                        product: state.product,
                        subproduct: state.subproduct,
                        version: state.version,
                        session: state.session,
                        sen: state.sen,
                        sourceIP: state.sourceIP,
                        atlPath: state.atlPath,
                    };
                    resultingArray.push(event_1);
                }
            }
        }
    };
    /**
     * Does trawl through the queue events and if finds any packages them up
     * and calls SenderNS.pushToServer for ajax post
     */
    HermentImpl.prototype.publishFromQueueAndStorage = function (pushServer) {
        try {
            var pushEvents = pushServer || this.pushToServer.bind(this);
            var events = [];
            if (this.config.queue.length < 1 &&
                (typeof this.storage === 'undefined' || this.storage.length < 1)) {
                return;
            }
            var state = {
                server: this.config.serverName,
                user: this.config.user,
                product: this.config.productName,
                subproduct: this.config.subProductName,
                version: this.config.version,
                session: this.config.session,
                sen: this.config.sen,
                sourceIP: this.config.sourceIP,
                atlPath: this.config.atlPath,
            };
            this.addEventsToArray(this.config.queue, events, state);
            var storedEvents = this.popEventsFromStorage();
            this.addEventsToArray(storedEvents, events, state);
            this.config.queue.length = 0;
            // POST events to the server
            if (events && events.length) {
                pushEvents(events);
            }
        }
        catch (e) {
            /*do nothing*/
        }
    };
    /**
     * Serialises events list to a string.
     */
    HermentImpl.prototype.serialiseEventsToString = function (events) {
        return JSON.stringify(events);
    };
    /**
     * De-serialises string to a JSON.
     */
    HermentImpl.prototype.deserialiseEvents = function (eventsString) {
        return JSON.parse(eventsString);
    };
    /**
     * Stores events from the parameter to the sessionStorage
     */
    HermentImpl.prototype.storeEvents = function (events) {
        if (!this.storage) {
            return;
        }
        try {
            if (this.storage[this.config.storageKey]) {
                var olderEvents = this.deserialiseEvents(this.storage[this.config.storageKey]) || [];
                if (olderEvents.length < this.config.maxevents) {
                    olderEvents.push.apply(olderEvents, events);
                }
                events = olderEvents;
            }
            this.storage.setItem(this.config.storageKey, this.serialiseEventsToString(events));
        }
        catch (e) {
            /*do nothing*/
        }
    };
    /**
     * Takes all events from the sessionStorage, removes them from sessionStorage and returns them
     * @returns {*} events Array
     */
    HermentImpl.prototype.popEventsFromStorage = function () {
        if (!this.storage) {
            return [];
        }
        try {
            if (this.storage[this.config.storageKey]) {
                var events = this.deserialiseEvents(this.storage[this.config.storageKey]);
                this.storage[this.config.storageKey] = this.serialiseEventsToString([]);
                return events;
            }
        }
        catch (e) {
            /*do nothing*/
        }
        return [];
    };
    /**
     * Moves all of the events from the queue to the sessionStorage
     */
    HermentImpl.prototype.moveQueueToStorage = function () {
        if (this.config.queue.length === 0 || !this.storage) {
            return;
        }
        this.storeEvents(this.config.queue);
        this.config.queue.length = 0;
    };
    /**
     * Called when this script is sourced. Creates a timer to call SenderNS.publishFromQueueAndStorage in intervals.
     * Also calls moveQueueToStorage each 1000ms to move any queued events to the storage, so to preserve any
     * events in the queue in case user navigates away
     */
    HermentImpl.prototype.start = function () {
        var _this = this;
        this.isStarted = true;
        var arrayPush = Array.prototype.push;
        this.config.queue.push = function (obj) {
            obj.time = new Date().getTime();
            arrayPush.call(_this.config.queue, obj);
        };
        // first publish a second later
        this.initialSaveTimeout = setTimeout(this.publishFromQueueAndStorage.bind(this), this.config.saveInterval);
        // Snapshot to storage every 1s and post to server every 5s
        this.publishInterval = setInterval(this.publishFromQueueAndStorage.bind(this), this.config.publishInterval);
        this.saveInterval = setInterval(this.moveQueueToStorage.bind(this), this.config.saveInterval);
    };
    /**
     * Publishes saved events and resets intervals
     */
    HermentImpl.prototype.stop = function () {
        this.isStarted = false;
        // publish all saved events and stop intervals/timeouts
        this.publishFromQueueAndStorage();
        clearTimeout(this.initialSaveTimeout);
        clearInterval(this.saveInterval);
        clearInterval(this.publishInterval);
    };
    HermentImpl.prototype.destroy = function () {
        this.stop();
    };
    return HermentImpl;
}());
var hermentClient;
var herment = (function () {
    var init = function (config) {
        if (!hermentClient) {
            hermentClient = new HermentImpl(config);
            return hermentClient;
        }
        hermentClient.stop();
        hermentClient.config = hermentClient.parseConfig(config);
    };
    return init;
})();
export default herment;
//# sourceMappingURL=herment.js.map