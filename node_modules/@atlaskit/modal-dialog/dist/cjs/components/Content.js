'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _rafSchd = require('raf-schd');

var _rafSchd2 = _interopRequireDefault(_rafSchd);

var _layerManager = require('@atlaskit/layer-manager');

var _Footer = require('./Footer');

var _Footer2 = _interopRequireDefault(_Footer);

var _Header = require('./Header');

var _Header2 = _interopRequireDefault(_Header);

var _Content = require('../styled/Content');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getInitialState() {
  return {
    showFooterKeyline: false,
    showHeaderKeyline: false,
    tabbableElements: []
  };
}

var Content = function (_Component) {
  (0, _inherits3.default)(Content, _Component);

  function Content(props, context) {
    (0, _classCallCheck3.default)(this, Content);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Content.__proto__ || (0, _getPrototypeOf2.default)(Content)).call(this, props, context));

    _this.escapeIsHeldDown = false;
    _this._isMounted = false;
    _this.state = getInitialState();

    _this.determineKeylines = function () {
      if (!_this.scrollContainer) return;

      var _this$scrollContainer = _this.scrollContainer,
          scrollTop = _this$scrollContainer.scrollTop,
          scrollHeight = _this$scrollContainer.scrollHeight,
          clientHeight = _this$scrollContainer.clientHeight;

      var scrollableDistance = scrollHeight - clientHeight;
      var showHeaderKeyline = scrollTop > _Content.keylineHeight;
      var showFooterKeyline = scrollTop <= scrollableDistance - _Content.keylineHeight;

      _this.setState({ showHeaderKeyline: showHeaderKeyline, showFooterKeyline: showFooterKeyline });
    };

    _this.getScrollContainer = function (ref) {
      if (!ref) return;
      _this.scrollContainer = ref;
    };

    _this.handleKeyUp = function () {
      _this.escapeIsHeldDown = false;
    };

    _this.handleKeyDown = function (event) {
      var _this$props = _this.props,
          onClose = _this$props.onClose,
          shouldCloseOnEscapePress = _this$props.shouldCloseOnEscapePress,
          _this$props$stackInde = _this$props.stackIndex,
          stackIndex = _this$props$stackInde === undefined ? 0 : _this$props$stackInde;

      // avoid consumers accidently closing multiple modals if they hold escape.

      if (_this.escapeIsHeldDown) return;
      if (event.key === 'Escape') _this.escapeIsHeldDown = true;

      // only the foremost modal should be interactive.
      if (!_this._isMounted || stackIndex > 0) return;

      switch (event.key) {
        case 'Escape':
          if (shouldCloseOnEscapePress) onClose(event);
          break;
        default:
      }
    };

    _this.handleStackChange = function (stackIndex) {
      var onStackChange = _this.props.onStackChange;

      if (onStackChange) onStackChange(stackIndex);
    };

    _this.determineKeylines = (0, _rafSchd2.default)(_this.determineKeylines);
    return _this;
  }

  (0, _createClass3.default)(Content, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._isMounted = true;

      // $FlowFixMe
      document.addEventListener('keydown', this.handleKeyDown, false);
      document.addEventListener('keyup', this.handleKeyUp, false);

      if (this.scrollContainer) {
        var capturedScrollContainer = this.scrollContainer;
        window.addEventListener('resize', this.determineKeylines, false);
        capturedScrollContainer.addEventListener('scroll', this.determineKeylines, false);
        this.determineKeylines();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var stackIndex = this.props.stackIndex;

      // update focus scope and let consumer know when stack index has changed

      if (nextProps.stackIndex && nextProps.stackIndex !== stackIndex) {
        this.handleStackChange(nextProps.stackIndex);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._isMounted = false;

      // $FlowFixMe
      document.removeEventListener('keydown', this.handleKeyDown, false);
      document.removeEventListener('keyup', this.handleKeyUp, false);

      if (this.scrollContainer) {
        var capturedScrollContainer = this.scrollContainer;
        window.removeEventListener('resize', this.determineKeylines, false);
        capturedScrollContainer.removeEventListener('scroll', this.determineKeylines, false);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          actions = _props.actions,
          appearance = _props.appearance,
          ModalBody = _props.body,
          children = _props.children,
          footer = _props.footer,
          header = _props.header,
          heading = _props.heading,
          onClose = _props.onClose,
          isChromeless = _props.isChromeless,
          isHeadingMultiline = _props.isHeadingMultiline,
          shouldScroll = _props.shouldScroll;
      var _state = this.state,
          showFooterKeyline = _state.showFooterKeyline,
          showHeaderKeyline = _state.showHeaderKeyline;


      if (isChromeless) {
        return _react2.default.createElement(
          _Content.Wrapper,
          null,
          children,
          _react2.default.createElement(_layerManager.ScrollLock, null)
        );
      }

      return _react2.default.createElement(
        _Content.Wrapper,
        null,
        _react2.default.createElement(_Header2.default, {
          appearance: appearance,
          component: header,
          heading: heading,
          onClose: onClose,
          isHeadingMultiline: isHeadingMultiline,
          showKeyline: showHeaderKeyline
        }),
        _react2.default.createElement(
          ModalBody,
          {
            innerRef: this.getScrollContainer,
            shouldScroll: shouldScroll
          },
          children
        ),
        _react2.default.createElement(_Footer2.default, {
          actions: actions,
          appearance: appearance,
          component: footer,
          onClose: onClose,
          showKeyline: showFooterKeyline
        }),
        _react2.default.createElement(_layerManager.ScrollLock, null)
      );
    }
  }]);
  return Content;
}(_react.Component);

Content.defaultProps = {
  autoFocus: false,
  isChromeless: false,
  stackIndex: 0,
  body: _Content.Body,
  isHeadingMultiline: true
};
Content.contextTypes = {
  /** available when invoked within @atlaskit/layer-manager */
  appId: _propTypes2.default.string
};
exports.default = Content;