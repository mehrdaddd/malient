import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import rafSchedule from 'raf-schd';
import { ScrollLock } from '@atlaskit/layer-manager';

import Footer from './Footer';
import Header from './Header';

import { Body, keylineHeight, Wrapper } from '../styled/Content';

function getInitialState() {
  return {
    showFooterKeyline: false,
    showHeaderKeyline: false,
    tabbableElements: []
  };
}

var Content = function (_Component) {
  _inherits(Content, _Component);

  function Content(props, context) {
    _classCallCheck(this, Content);

    var _this = _possibleConstructorReturn(this, (Content.__proto__ || _Object$getPrototypeOf(Content)).call(this, props, context));

    _this.escapeIsHeldDown = false;
    _this._isMounted = false;
    _this.state = getInitialState();

    _this.determineKeylines = function () {
      if (!_this.scrollContainer) return;

      var _this$scrollContainer = _this.scrollContainer,
          scrollTop = _this$scrollContainer.scrollTop,
          scrollHeight = _this$scrollContainer.scrollHeight,
          clientHeight = _this$scrollContainer.clientHeight;

      var scrollableDistance = scrollHeight - clientHeight;
      var showHeaderKeyline = scrollTop > keylineHeight;
      var showFooterKeyline = scrollTop <= scrollableDistance - keylineHeight;

      _this.setState({ showHeaderKeyline: showHeaderKeyline, showFooterKeyline: showFooterKeyline });
    };

    _this.getScrollContainer = function (ref) {
      if (!ref) return;
      _this.scrollContainer = ref;
    };

    _this.handleKeyUp = function () {
      _this.escapeIsHeldDown = false;
    };

    _this.handleKeyDown = function (event) {
      var _this$props = _this.props,
          onClose = _this$props.onClose,
          shouldCloseOnEscapePress = _this$props.shouldCloseOnEscapePress,
          _this$props$stackInde = _this$props.stackIndex,
          stackIndex = _this$props$stackInde === undefined ? 0 : _this$props$stackInde;

      // avoid consumers accidently closing multiple modals if they hold escape.

      if (_this.escapeIsHeldDown) return;
      if (event.key === 'Escape') _this.escapeIsHeldDown = true;

      // only the foremost modal should be interactive.
      if (!_this._isMounted || stackIndex > 0) return;

      switch (event.key) {
        case 'Escape':
          if (shouldCloseOnEscapePress) onClose(event);
          break;
        default:
      }
    };

    _this.handleStackChange = function (stackIndex) {
      var onStackChange = _this.props.onStackChange;

      if (onStackChange) onStackChange(stackIndex);
    };

    _this.determineKeylines = rafSchedule(_this.determineKeylines);
    return _this;
  }

  _createClass(Content, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._isMounted = true;

      // $FlowFixMe
      document.addEventListener('keydown', this.handleKeyDown, false);
      document.addEventListener('keyup', this.handleKeyUp, false);

      if (this.scrollContainer) {
        var capturedScrollContainer = this.scrollContainer;
        window.addEventListener('resize', this.determineKeylines, false);
        capturedScrollContainer.addEventListener('scroll', this.determineKeylines, false);
        this.determineKeylines();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var stackIndex = this.props.stackIndex;

      // update focus scope and let consumer know when stack index has changed

      if (nextProps.stackIndex && nextProps.stackIndex !== stackIndex) {
        this.handleStackChange(nextProps.stackIndex);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._isMounted = false;

      // $FlowFixMe
      document.removeEventListener('keydown', this.handleKeyDown, false);
      document.removeEventListener('keyup', this.handleKeyUp, false);

      if (this.scrollContainer) {
        var capturedScrollContainer = this.scrollContainer;
        window.removeEventListener('resize', this.determineKeylines, false);
        capturedScrollContainer.removeEventListener('scroll', this.determineKeylines, false);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          actions = _props.actions,
          appearance = _props.appearance,
          ModalBody = _props.body,
          children = _props.children,
          footer = _props.footer,
          header = _props.header,
          heading = _props.heading,
          onClose = _props.onClose,
          isChromeless = _props.isChromeless,
          isHeadingMultiline = _props.isHeadingMultiline,
          shouldScroll = _props.shouldScroll;
      var _state = this.state,
          showFooterKeyline = _state.showFooterKeyline,
          showHeaderKeyline = _state.showHeaderKeyline;


      if (isChromeless) {
        return React.createElement(
          Wrapper,
          null,
          children,
          React.createElement(ScrollLock, null)
        );
      }

      return React.createElement(
        Wrapper,
        null,
        React.createElement(Header, {
          appearance: appearance,
          component: header,
          heading: heading,
          onClose: onClose,
          isHeadingMultiline: isHeadingMultiline,
          showKeyline: showHeaderKeyline
        }),
        React.createElement(
          ModalBody,
          {
            innerRef: this.getScrollContainer,
            shouldScroll: shouldScroll
          },
          children
        ),
        React.createElement(Footer, {
          actions: actions,
          appearance: appearance,
          component: footer,
          onClose: onClose,
          showKeyline: showFooterKeyline
        }),
        React.createElement(ScrollLock, null)
      );
    }
  }]);

  return Content;
}(Component);

Content.defaultProps = {
  autoFocus: false,
  isChromeless: false,
  stackIndex: 0,
  body: Body,
  isHeadingMultiline: true
};
Content.contextTypes = {
  /** available when invoked within @atlaskit/layer-manager */
  appId: PropTypes.string
};
export default Content;