import * as tslib_1 from "tslib";
/* tslint:disable:variable-name */
import * as React from 'react';
import { Component } from 'react';
import { isError, isCollectionNotFoundError, } from '@atlaskit/media-core';
import { TransitionGroup, CSSTransition } from 'react-transition-group';
import { defaultImageCardDimensions, defaultSmallCardDimensions, } from '../utils';
import { LazyContent } from '../utils/lazyContent';
import { MediaCard, CardView } from '../root';
import { InfiniteScroll } from './infiniteScroll';
import { CardListItemWrapper, Spinner } from './styled';
// FIXME: these aren't "components", they're actually "elements"... we should rename these or change the signature to be a "component" e.g. () => (<Spinner.../>);. Will clean up the tests a bit too.
var LoadingComponent = (React.createElement(Spinner, { className: "spinner", style: { width: '100%', height: '100%' } }, "loading..."));
var EmptyComponent = React.createElement("div", null, "No items");
var ErrorComponent = React.createElement("div", null, "ERROR");
var CardList = /** @class */ (function (_super) {
    tslib_1.__extends(CardList, _super);
    function CardList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            loading: true,
            shouldAnimate: false,
        };
        _this.providersByMediaItemId = {};
        _this.handleInfiniteScrollThresholdReached = function () {
            _this.loadNextPage();
        };
        _this.loadNextPage = function () {
            return _this.state.loadNextPage && _this.state.loadNextPage();
        };
        return _this;
    }
    CardList.prototype.unsubscribe = function () {
        var subscription = this.state.subscription;
        if (subscription) {
            subscription.unsubscribe();
        }
    };
    CardList.prototype.handleNextItems = function (nextProps) {
        var _this = this;
        var collectionName = nextProps.collectionName, context = nextProps.context;
        return function (value) {
            if (isError(value)) {
                _this.setState({ collection: undefined, error: value, loading: false });
            }
            else {
                var firstItemKey = _this.state.firstItemKey;
                var newFirstItemKey = value.items[0]
                    ? _this.getItemKey(value.items[0])
                    : undefined;
                var shouldAnimate = !!firstItemKey && firstItemKey !== newFirstItemKey;
                _this.providersByMediaItemId = {};
                value.items.forEach(function (mediaItem) {
                    if (!mediaItem.details) {
                        return;
                    }
                    _this.providersByMediaItemId[mediaItem.details.id] = context.getMediaItemProvider(mediaItem.details.id, mediaItem.type, collectionName, mediaItem);
                });
                _this.setState({
                    collection: value,
                    shouldAnimate: shouldAnimate,
                    loading: false,
                    firstItemKey: newFirstItemKey,
                    error: undefined,
                });
            }
        };
    };
    CardList.prototype.subscribe = function (nextProps) {
        var collectionName = nextProps.collectionName, context = nextProps.context;
        var pageSize = this.props.pageSize || CardList.defaultPageSize;
        var provider = context.getMediaCollectionProvider(collectionName, pageSize);
        var subscription = provider.observable().subscribe({
            next: this.handleNextItems(nextProps),
        });
        this.setState({ subscription: subscription });
    };
    CardList.prototype.shouldUpdateState = function (nextProps) {
        return (nextProps.collectionName !== this.props.collectionName ||
            nextProps.context !== this.props.context ||
            nextProps.pageSize !== this.props.pageSize);
    };
    CardList.prototype.updateState = function (nextProps) {
        var _this = this;
        var collectionName = nextProps.collectionName, context = nextProps.context;
        var pageSize = this.props.pageSize || CardList.defaultPageSize;
        var provider = context.getMediaCollectionProvider(collectionName, pageSize);
        this.unsubscribe();
        this.dataURIService = context.getDataUriService(collectionName);
        // Setting the subscription after the state has been applied
        this.setState({
            loadNextPage: function () { return provider.loadNextPage(); },
            error: undefined,
            collection: undefined,
            firstItemKey: undefined,
        }, function () { return _this.subscribe(nextProps); });
    };
    CardList.prototype.componentDidMount = function () {
        this.updateState(this.props);
    };
    CardList.prototype.componentWillReceiveProps = function (nextProps) {
        if (this.shouldUpdateState(nextProps)) {
            this.updateState(nextProps);
        }
    };
    CardList.prototype.componentWillUnmount = function () {
        this.unsubscribe();
    };
    CardList.prototype.render = function () {
        var height = this.props.height;
        var _a = this.state, loading = _a.loading, error = _a.error, collection = _a.collection;
        var emptyComponent = this.props.emptyComponent || EmptyComponent;
        var loadingComponent = this.props.loadingComponent || LoadingComponent;
        var errorComponent = this.props.errorComponent || ErrorComponent;
        if (loading) {
            return loadingComponent;
        }
        if (error) {
            if (isCollectionNotFoundError(error)) {
                return emptyComponent;
            }
            else {
                return errorComponent;
            }
        }
        if (!collection) {
            return loadingComponent;
        }
        if (this.useInfiniteScroll) {
            return (React.createElement(InfiniteScroll, { height: height, onThresholdReached: this.handleInfiniteScrollThresholdReached }, this.renderList()));
        }
        return this.renderList();
    };
    CardList.prototype.renderList = function () {
        var _this = this;
        var _a = this.state, collection = _a.collection, shouldAnimate = _a.shouldAnimate;
        var _b = this, cardWidth = _b.cardWidth, dimensions = _b.dimensions, providersByMediaItemId = _b.providersByMediaItemId, dataURIService = _b.dataURIService, handleCardClick = _b.handleCardClick, placeholder = _b.placeholder;
        var _c = this.props, cardAppearance = _c.cardAppearance, shouldLazyLoadCards = _c.shouldLazyLoadCards;
        var actions = this.props.actions || [];
        var cardActions = function (collectionItem) {
            return actions.map(function (action) {
                return {
                    label: action.label,
                    handler: function (item, event) {
                        if (collection) {
                            action.handler(collectionItem, collection, event);
                        }
                    },
                };
            });
        };
        var cards = collection
            ? collection.items.filter(function (item) { return item.type === 'file'; }).map(function (mediaItem) {
                var key = _this.getItemKey(mediaItem);
                var cardListItem = (React.createElement(CSSTransition, { key: key, classNames: "card-list-item", timeout: { enter: 750 }, exit: false, component: "div", className: "card-list" },
                    React.createElement(CardListItemWrapper, { shouldAnimate: shouldAnimate, cardWidth: cardWidth },
                        React.createElement(MediaCard, { provider: providersByMediaItemId[mediaItem.details.id], dataURIService: dataURIService, appearance: cardAppearance, dimensions: dimensions, onClick: handleCardClick.bind(_this, mediaItem), actions: cardActions(mediaItem) }))));
                // We don't want to wrap new items into LazyContent aka lazy load new items
                var useLazyContent = shouldLazyLoadCards && !shouldAnimate;
                return useLazyContent ? (React.createElement(LazyContent, { key: key, placeholder: placeholder }, cardListItem)) : (cardListItem);
            })
            : null;
        return React.createElement(TransitionGroup, null, cards);
    };
    CardList.prototype.handleCardClick = function (oldItem, cardEvent) {
        var _a = this.props, collectionName = _a.collectionName, onCardClick = _a.onCardClick;
        if (!onCardClick) {
            return;
        }
        var event = cardEvent.event, mediaItemDetails = cardEvent.mediaItemDetails;
        // need to merge the new details with the old details (as the old details may be out of date) and we need the occurrenceKey
        var newItem = {
            type: oldItem.type,
            details: tslib_1.__assign({}, oldItem.details, mediaItemDetails),
        };
        var cardListEvent = {
            event: event,
            collectionName: collectionName,
            mediaCollectionItem: newItem,
        };
        onCardClick(cardListEvent);
    };
    Object.defineProperty(CardList.prototype, "cardWidth", {
        /*
          We only want to apply default width (hardcoded value) for normal cards,
          in case of small cards we want them to grow up and use the whole parent width
         */
        get: function () {
            var _a = this.props, cardDimensions = _a.cardDimensions, cardAppearance = _a.cardAppearance;
            if (cardDimensions) {
                return cardDimensions.width;
            }
            if (cardAppearance === 'image') {
                return defaultImageCardDimensions.width;
            }
            if (cardAppearance === 'small') {
                return '100%';
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardList.prototype, "cardHeight", {
        get: function () {
            var _a = this.props, cardDimensions = _a.cardDimensions, cardAppearance = _a.cardAppearance;
            if (cardDimensions && cardDimensions.height) {
                return cardDimensions.height;
            }
            if (cardAppearance === 'image') {
                return defaultImageCardDimensions.height;
            }
            if (cardAppearance === 'small') {
                return defaultSmallCardDimensions.height;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardList.prototype, "useInfiniteScroll", {
        get: function () {
            return this.props.useInfiniteScroll
                ? true
                : !this.isNullOrUndefined(this.props.height);
        },
        enumerable: true,
        configurable: true
    });
    CardList.prototype.isNullOrUndefined = function (value) {
        return value === null || value === undefined;
    };
    CardList.prototype.getItemKey = function (item) {
        return item.details.id + "-" + item.details.occurrenceKey;
    };
    Object.defineProperty(CardList.prototype, "dimensions", {
        get: function () {
            var _a = this, cardWidth = _a.cardWidth, cardHeight = _a.cardHeight;
            return {
                width: cardWidth,
                height: cardHeight,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CardList.prototype, "placeholder", {
        get: function () {
            var _a = this, cardWidth = _a.cardWidth, dimensions = _a.dimensions;
            var cardAppearance = this.props.cardAppearance;
            return (React.createElement(CardListItemWrapper, { cardWidth: cardWidth },
                React.createElement(CardView, { dimensions: dimensions, status: "loading", appearance: cardAppearance })));
        },
        enumerable: true,
        configurable: true
    });
    CardList.defaultPageSize = 10;
    CardList.defaultProps = {
        cardAppearance: 'image',
        pageSize: CardList.defaultPageSize,
        actions: [],
        useInfiniteScroll: true,
        shouldLazyLoadCards: true,
        errorComponent: ErrorComponent,
        loadingComponent: LoadingComponent,
        emptyComponent: EmptyComponent,
    };
    return CardList;
}(Component));
export { CardList };
//# sourceMappingURL=index.js.map