"use strict";
// TODO Kill this file and it's friends as part of MSW-691
// Do not use this class for anything. Use media-store instead
Object.defineProperty(exports, "__esModule", { value: true });
var uuid = require("uuid");
var mediaClient_1 = require("./mediaClient");
var promises_1 = require("../util/promises");
var MediaApi = /** @class */ (function () {
    function MediaApi() {
    }
    MediaApi.prototype.createUpload = function (mediaClient) {
        // Media API may not be able to create the required upload container. If it fails, this function retries
        var numRetries = 5;
        var delay = 1000;
        var delayMultiplier = 2;
        var request = {
            httpMethod: 'POST',
            mediaApiMethod: 'upload',
            parameters: {
                createUpTo: 1,
                safariCacheBuster: uuid.v4(),
            },
        };
        return promises_1.retryTask(function () {
            return mediaClient.call(request, mediaClient_1.addAuthToQueryParameters).then(function (response) {
                var uploads = response.data;
                if (uploads.length === 0) {
                    throw new Error('No uploads were created');
                }
                return uploads[0].id;
            });
        }, numRetries, delay, delayMultiplier);
    };
    MediaApi.prototype.appendChunksToUpload = function (mediaClient, uploadId, chunkIds, offset) {
        var request = {
            httpMethod: 'PUT',
            mediaApiMethod: "upload/" + uploadId + "/chunks",
            data: {
                chunks: chunkIds,
                offset: offset,
            },
        };
        return mediaClient.call(request);
    };
    MediaApi.prototype.createFileFromUpload = function (mediaClient, fileName, mimeType, uploadId, collection) {
        var request = {
            httpMethod: 'POST',
            mediaApiMethod: 'file/upload',
            parameters: collection ? { collection: collection } : {},
            data: {
                name: fileName,
                mimeType: mimeType,
                uploadId: uploadId,
            },
        };
        return mediaClient.call(request).then(function (response) { return response.data.id; });
    };
    MediaApi.prototype.pollForFileMetadata = function (mediaClient, fileId, collection) {
        var numRetries = 10;
        var delay = 1000;
        var delayMultiplier = 2;
        var request = {
            httpMethod: 'GET',
            mediaApiMethod: "file/" + fileId,
            parameters: collection ? { collection: collection } : {},
        };
        return promises_1.retryTask(function () {
            return mediaClient.call(request, mediaClient_1.addAuthToQueryParameters).then(function (response) {
                var data = response.data;
                if (data.processingStatus === 'succeeded' ||
                    data.processingStatus === 'failed') {
                    return data;
                }
                throw new Error('Processing not finished');
            });
        }, numRetries, delay, delayMultiplier);
    };
    MediaApi.prototype.copyFileToCollection = function (mediaClient, sourceFile, collection) {
        var request = {
            httpMethod: 'POST',
            mediaApiMethod: "file/copy/withToken",
            parameters: collection ? { collection: collection } : {},
            data: {
                sourceFile: sourceFile,
            },
        };
        return mediaClient.call(request, mediaClient_1.addAuthToQueryParameters).then(function () { });
    };
    return MediaApi;
}());
exports.MediaApi = MediaApi;
//# sourceMappingURL=mediaApi.js.map