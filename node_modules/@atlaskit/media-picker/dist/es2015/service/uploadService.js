import * as tslib_1 from "tslib";
import * as Resumable from 'resumablejs';
import * as uuid from 'uuid';
import { EventEmitter2 } from 'eventemitter2';
import { handleError } from '../util/handleError';
import { sliceByChunks } from '../util/sliceByChunks';
import { mapAuthToQueryParameters } from '../domain/auth';
import { validateMediaFile } from '../domain/file';
import { SmartMediaProgress } from '../domain/progress';
import { defaultUploadParams } from '../domain/uploadParams';
import { getPreviewFromBlob } from '../util/getPreviewFromBlob';
import { getPreviewFromVideo } from '../util/getPreviewFromVideo';
import { createHasher } from './hashing/hasherCreator';
import { MediaClient, isTokenError } from './mediaClient';
import { MediaClientPool } from './mediaClientPool';
import { MediaApi } from './mediaApi';
import { mapAuthToSourceFileOwner, } from '../popup/domain/source-file';
var MAX_RETRY_COUNT = 1;
var UploadService = /** @class */ (function () {
    function UploadService(url, authProvider, uploadParams, userAuthProvider) {
        var _this = this;
        this.uploads = {};
        this.retry = 0;
        this.emit = function (event, payload) {
            _this.emitter.emit(event, payload);
        };
        // Returns query parameters for a chunk
        this.getQueryParameters = function (file, chunk) {
            var mediaClient = _this.getMediaClient(file);
            var storedAuth = mediaClient.storedAuth;
            if (storedAuth) {
                return tslib_1.__assign({ hash: chunk.hash }, mapAuthToQueryParameters(storedAuth));
            }
            else {
                throw new Error('auth required');
            }
        };
        // Generates URL to upload a chunk
        this.generateTarget = function (rawParams) {
            // Resumablejs reports parameters as an array of strings: [ 'key=value', ... ]
            // We convert it to an object { key: value }
            var params = rawParams.map(function (p) { return p.split('='); }).reduce(function (obj, _a) {
                var key = _a[0], value = _a[1];
                obj[key] = value;
                return obj;
            }, {});
            var hash = params.hash, resumableCurrentChunkSize = params.resumableCurrentChunkSize, client = params.client, issuer = params.issuer, token = params.token;
            var authQueryParameters;
            if (issuer) {
                authQueryParameters = "issuer=" + issuer + "&token=" + token;
            }
            else {
                authQueryParameters = "client=" + client + "&token=" + token;
            }
            return _this.uploadChunkUrl + "/" + hash + "-" + resumableCurrentChunkSize + "?" + authQueryParameters;
        };
        // Handling events from resumable
        this.onFilesAdded = function (resumableFiles) {
            if (resumableFiles.length === 0) {
                return;
            }
            var uploadParams = _this.uploadParams;
            resumableFiles.forEach(function (resumableFile) {
                _this.uploads[resumableFile.uniqueIdentifier] = {
                    creationDate: Date.now(),
                    uploadParams: uploadParams,
                };
            });
            // ResumableJS needs a valid token to make calls. It makes calls by itself, without using MediaClient.
            // To make sure that MediaClient stores a valid token, we refresh it before upload starts.
            var collection = uploadParams.collection;
            var mediaClient = _this.mediaClientPool.getMediaClient(collection);
            var maxFileSizeForPreview = 10e6; // 10 MB
            mediaClient.refreshAuth().then(function () {
                _this.retry = 0;
                var files = resumableFiles.map(function (resumableFile) {
                    var file = _this.mapResumableFileToMediaFile(resumableFile);
                    var mediaType = _this.getMediaTypeFromFile(resumableFile.file);
                    // TODO MSW-396 Replace this check after RFC from ticket has been decided
                    // https://product-fabric.atlassian.net/browse/MSW-396
                    if (file.size < maxFileSizeForPreview && mediaType === 'image') {
                        getPreviewFromBlob(resumableFile.file, mediaType).then(function (preview) {
                            _this.emit('file-preview-update', {
                                file: file,
                                preview: preview,
                            });
                        });
                    }
                    else if (mediaType === 'video') {
                        getPreviewFromVideo(resumableFile.file).then(function (preview) {
                            _this.emit('file-preview-update', {
                                file: file,
                                preview: preview,
                            });
                        });
                    }
                    return file;
                });
                _this.emit('files-added', { files: files });
                _this.resumable.upload();
            }, function () {
                resumableFiles.forEach(function (resumableFile) {
                    return _this.onError(resumableFile, 'token_fetch_fail');
                });
                resumableFiles.forEach(function (resumableFile) { return resumableFile.cancel(); });
                resumableFiles.forEach(_this.cleanupResumableFile);
            });
        };
        this.onChunkingComplete = function (resumableFile) {
            // By default the callback of a chunk aborts all uploads and clears the chunk array in case of error.
            //
            // To prevent this and allow token refresh logic we patch the chunk callback.
            resumableFile.chunks.forEach(function (chunk) {
                var oldCallback = chunk.callback;
                chunk.callback = function (event, message) {
                    if (event === 'error') {
                        _this.retry++;
                        resumableFile.abort();
                        resumableFile.pause(true);
                        _this.resumable.fire('fileError', resumableFile, message || '');
                        return;
                    }
                    if (event === 'success') {
                        _this.retry = 0;
                    }
                    oldCallback(event, message);
                };
            });
        };
        this.onFileProgress = function (resumableFile) {
            var portion = resumableFile.progress();
            var file = _this.mapResumableFileToMediaFile(resumableFile);
            if (portion > 0 && portion < 1) {
                var progress = new SmartMediaProgress(file.size, file.size * portion, file.creationDate, Date.now());
                _this.emit('file-uploading', {
                    file: file,
                    progress: progress,
                });
            }
        };
        this.emitLastUploadingPercentage = function (resumableFile) {
            var file = _this.mapResumableFileToMediaFile(resumableFile);
            var progress = new SmartMediaProgress(file.size, file.size, file.creationDate, Date.now());
            _this.emit('file-uploading', {
                file: file,
                progress: progress,
            });
        };
        this.onFileSuccess = function (resumableFile) {
            _this.emitLastUploadingPercentage(resumableFile);
            _this.finalizeFile(resumableFile);
        };
        this.onFileError = function (resumableFile, message) {
            var mediaClient = _this.getMediaClient(resumableFile);
            _this.onUploadError(resumableFile, 'upload_fail', message, mediaClient)
                .then(function () {
                // Retry to upload the file
                resumableFile._prevProgress = 0;
                resumableFile.pause(false);
                resumableFile.chunks.forEach(function (chunk) {
                    if (chunk.status() === 'error') {
                        chunk.preprocessState = 0;
                        chunk.send();
                    }
                    if (chunk.status() === 'pending' && chunk.preprocessState === 2) {
                        chunk.preprocessState = 0;
                    }
                });
            })
                .catch(function () {
                resumableFile.cancel();
            });
        };
        // Dropzone drop listener
        this.onDrop = function (dragEvent) {
            dragEvent.preventDefault();
            dragEvent.stopPropagation();
            _this.emit('file-dropped', dragEvent);
        };
        this.mapResumableFileToMediaFile = function (resumableFile) {
            var file = {
                id: resumableFile.uniqueIdentifier,
                name: resumableFile.file.name,
                size: resumableFile.file.size,
                type: resumableFile.file.type,
                creationDate: _this.getResumableFileCreationDate(resumableFile),
            };
            validateMediaFile(file);
            return file;
        };
        this.mapResumableFileToPublicMediaFile = function (resumableFile, publicId) {
            return tslib_1.__assign({}, _this.mapResumableFileToMediaFile(resumableFile), { publicId: publicId });
        };
        this.getResumableFileCreationDate = function (resumableFile) {
            return _this.uploads[resumableFile.uniqueIdentifier].creationDate;
        };
        this.getResumableFileUploadParams = function (resumableFile) {
            return _this.uploads[resumableFile.uniqueIdentifier].uploadParams;
        };
        this.cleanupResumableFile = function (resumableFile) {
            delete _this.uploads[resumableFile.uniqueIdentifier];
        };
        this.emitter = new EventEmitter2();
        this.uploadChunkUrl = url + "/chunk";
        this.authProvider = authProvider;
        this.mediaClientPool = new MediaClientPool(url, authProvider);
        if (userAuthProvider) {
            this.userCollectionMediaClient = new MediaClient(url, userAuthProvider, 'recents');
        }
        this.api = new MediaApi();
        this.setUploadParams(uploadParams);
        this.resumable = new Resumable({
            target: this.generateTarget,
            uploadMethod: 'PUT',
            testMethod: 'HEAD',
            chunkSize: 4 * 1024 * 1024,
            chunkRetryInterval: 2500,
            maxChunkRetries: 5,
            simultaneousUploads: 3,
            forceChunkSize: true,
            permanentErrors: [400, 403, 404, 415, 500, 501],
            method: 'octet',
            minFileSize: 0,
            query: this.getQueryParameters,
            preprocess: function (chunk) { return UploadService.hasher.hash(chunk); },
            generateUniqueIdentifier: function () { return uuid.v4(); },
        });
        this.resumable.on('filesAdded', this.onFilesAdded);
        this.resumable.on('chunkingComplete', this.onChunkingComplete);
        this.resumable.on('fileProgress', this.onFileProgress);
        this.resumable.on('fileSuccess', this.onFileSuccess);
        this.resumable.on('fileError', this.onFileError);
    }
    UploadService.prototype.setUploadParams = function (uploadParams) {
        this.uploadParams = tslib_1.__assign({}, defaultUploadParams, uploadParams);
    };
    UploadService.prototype.getUploadParams = function () {
        // for testing
        return this.uploadParams;
    };
    UploadService.prototype.addBrowse = function (element) {
        this.resumable.assignBrowse(element);
    };
    UploadService.prototype.addDropzone = function (element) {
        if (this.dropzoneElement) {
            // dropzone already assigned
            return;
        }
        this.dropzoneElement = element;
        this.dropzoneElement.addEventListener('drop', this.onDrop);
        this.resumable.assignDrop(this.dropzoneElement);
    };
    UploadService.prototype.removeDropzone = function () {
        if (!this.dropzoneElement) {
            // dropzone already unassigned
            return;
        }
        this.dropzoneElement.removeEventListener('drop', this.onDrop);
        this.resumable.unAssignDrop(this.dropzoneElement);
        this.dropzoneElement = undefined;
    };
    UploadService.prototype.addFile = function (file) {
        this.resumable.addFile(file);
    };
    UploadService.prototype.cancel = function (uniqueIdentifier) {
        if (uniqueIdentifier) {
            var resumableFile = this.resumable.getFromUniqueIdentifier(uniqueIdentifier);
            if (resumableFile) {
                resumableFile.cancel();
            }
        }
        else {
            this.resumable.cancel();
        }
    };
    UploadService.prototype.on = function (event, listener) {
        this.emitter.on(event, listener);
    };
    UploadService.prototype.off = function (event, listener) {
        this.emitter.off(event, listener);
    };
    UploadService.prototype.getMediaClient = function (resumableFile) {
        var collection = this.getResumableFileUploadParams(resumableFile).collection;
        return this.mediaClientPool.getMediaClient(collection);
    };
    UploadService.prototype.getMediaTypeFromFile = function (file) {
        var type = file.type;
        if (type.match(/^image\//)) {
            return 'image';
        }
        else if (type.match(/^video\//)) {
            return 'video';
        }
        return 'unknown';
    };
    // Finalizing a file
    UploadService.prototype.finalizeFile = function (resumableFile) {
        var _this = this;
        var fileName = resumableFile.fileName, file = resumableFile.file;
        var collection = this.getResumableFileUploadParams(resumableFile).collection;
        var maxChunks = 1000;
        var chunks = resumableFile.chunks.map(function (chunk) {
            var _a = chunk, hash = _a.hash, endByte = _a.endByte, startByte = _a.startByte;
            return hash + '-' + (endByte - startByte);
        });
        var mediaClient = this.getMediaClient(resumableFile);
        return this.api
            .createUpload(mediaClient)
            .then(function (uploadId) {
            return _this.appendChunksToUpload(mediaClient, uploadId, chunks, maxChunks);
        })
            .then(function (uploadId) {
            return _this.api.createFileFromUpload(mediaClient, fileName, file.type, uploadId, collection);
        })
            .then(function (fileId) {
            _this.copyFileToUsersCollection(fileId, collection).catch(console.error);
            return _this.processFile(mediaClient, fileId, resumableFile);
        })
            .catch(function (error) {
            _this.onError(resumableFile, 'object_create_fail', error);
        });
    };
    UploadService.prototype.appendChunksToUpload = function (mediaClient, uploadId, allChunkIds, maxChunks) {
        var _this = this;
        return sliceByChunks(allChunkIds, maxChunks)
            .map(function (someChunkIds, index) {
            var offset = index * maxChunks;
            return function () {
                return _this.api.appendChunksToUpload(mediaClient, uploadId, someChunkIds, offset);
            };
        })
            .reduce(function (promise, current) {
            return promise.then(current);
        }, Promise.resolve())
            .then(function () { return uploadId; });
    };
    UploadService.prototype.copyFileToUsersCollection = function (sourceFileId, sourceCollection) {
        var _this = this;
        if (!this.userCollectionMediaClient) {
            return Promise.resolve();
        }
        return this.authProvider({ collectionName: sourceCollection }).then(function (auth) {
            var sourceFile = {
                id: sourceFileId,
                collection: sourceCollection,
                owner: tslib_1.__assign({}, mapAuthToSourceFileOwner(auth)),
            };
            return _this.api.copyFileToCollection(_this.userCollectionMediaClient, sourceFile, 'recents');
        });
    };
    UploadService.prototype.processFile = function (mediaClient, fileId, resumableFile) {
        var _this = this;
        return this.pollForFileMetadata(mediaClient, fileId, resumableFile)
            .then(function (metadata) {
            var file = _this.mapResumableFileToPublicMediaFile(resumableFile, metadata.id);
            _this.emit('file-converted', {
                file: file,
                metadata: metadata,
            });
        })
            .catch(function (error) {
            _this.onError(resumableFile, 'metadata_fetch_fail', error);
        });
    };
    UploadService.prototype.pollForFileMetadata = function (mediaClient, publicId, resumableFile) {
        var collection = this.getResumableFileUploadParams(resumableFile).collection;
        this.emit('file-converting', {
            file: this.mapResumableFileToPublicMediaFile(resumableFile, publicId),
        });
        return this.api.pollForFileMetadata(mediaClient, publicId, collection);
    };
    // Error handling
    UploadService.prototype.onUploadError = function (resumableFile, errorName, errorDetails, mediaClient) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var uploadId = resumableFile.uniqueIdentifier;
            // Try to read error from error details
            var error;
            try {
                error = JSON.parse(errorDetails);
            }
            catch (ignored) { }
            if (isTokenError(error) && _this.retry <= MAX_RETRY_COUNT) {
                mediaClient
                    .refreshAuth()
                    .then(function () { return resolve(); })
                    .catch(function () {
                    _this.emit('file-upload-error', {
                        file: _this.mapResumableFileToMediaFile(resumableFile),
                        error: {
                            fileId: uploadId,
                            name: 'token_update_fail',
                            description: errorDetails,
                        },
                    });
                    handleError(errorName, errorDetails);
                    reject();
                });
                return;
            }
            if (error && error.error && error.error.title) {
                errorDetails = error.error.title;
            }
            _this.emit('file-upload-error', {
                file: _this.mapResumableFileToMediaFile(resumableFile),
                error: {
                    fileId: uploadId,
                    name: errorName,
                    description: errorDetails,
                },
            });
            handleError(errorName, errorDetails);
            reject();
        });
    };
    UploadService.prototype.onError = function (resumableFile, errorName, error) {
        var errorDetails;
        if (error && error.error && error.error.title) {
            errorDetails = error.error.title;
        }
        else {
            errorDetails = JSON.stringify(error || {});
        }
        this.emit('file-upload-error', {
            file: this.mapResumableFileToMediaFile(resumableFile),
            error: {
                fileId: resumableFile.uniqueIdentifier,
                name: errorName,
                description: errorDetails,
            },
        });
        handleError(errorName, errorDetails);
    };
    UploadService.hasher = createHasher();
    return UploadService;
}());
export { UploadService };
//# sourceMappingURL=uploadService.js.map