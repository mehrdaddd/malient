"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var js_search_1 = require("js-search");
var types_1 = require("../types");
var XRegExp = require("xregexp/src/xregexp"); // Not using 'xregexp' directly to only include what we use
var XRegExpUnicodeBase = require("xregexp/src/addons/unicode-base");
var XRegExpUnicodeScripts = require("xregexp/src/addons/unicode-scripts");
var XRegExpUnicodeCategories = require("xregexp/src/addons/unicode-categories");
XRegExpUnicodeBase(XRegExp);
XRegExpUnicodeScripts(XRegExp);
XRegExpUnicodeCategories(XRegExp);
// \p{Han} => each chinese character is a separate token
// \p{L}+[\p{Mn}|']*\p{L} => consecutive letters, including non spacing mark and apostrophe are a single token
var tokenizerRegex = XRegExp.cache("\\p{Han}|\\p{L}+[\\p{Mn}|']*\\p{L}*", 'gi');
var nonSpacingMarkRegex = XRegExp.cache('\\p{Mn}', 'gi');
// Order by increasing weight, using a big enough number to put item without an explicit weight
// at the end
var DEFAULT_WEIGHT = 100000;
var Tokenizer = /** @class */ (function () {
    function Tokenizer() {
    }
    Tokenizer.tokenize = function (text) {
        return this.tokenizeAsTokens(text).map(function (token) { return token.token; });
    };
    Tokenizer.tokenizeAsTokens = function (text) {
        var match;
        var tokens = [];
        tokenizerRegex.lastIndex = 0;
        while ((match = tokenizerRegex.exec(text)) !== null) {
            if (match[0]) {
                tokens.push({
                    token: match[0],
                    start: match.index,
                });
            }
        }
        return tokens;
    };
    return Tokenizer;
}());
exports.Tokenizer = Tokenizer;
/**
 * Returns a comparator function for MentionDescription object.
 *
 * @param {Set<string>} inContextUsers
 * @returns {(a: MentionDescription, b: MentionDescription) => number}
 */
function mentionDescriptionComparator(inContextUsers) {
    return function (a, b) {
        var aIsSpecialMention = types_1.isSpecialMention(a);
        var bIsSpecialMention = types_1.isSpecialMention(b);
        if (aIsSpecialMention && !bIsSpecialMention) {
            return -1;
        }
        if (bIsSpecialMention && !aIsSpecialMention) {
            return 1;
        }
        var aInContext = inContextUsers.has(a.id);
        var bInContext = inContextUsers.has(b.id);
        if (aInContext && !bInContext) {
            return -1;
        }
        if (bInContext && !aInContext) {
            return 1;
        }
        var aWeight = a.weight !== undefined ? a.weight : DEFAULT_WEIGHT;
        var bWeight = b.weight !== undefined ? b.weight : DEFAULT_WEIGHT;
        if (aWeight !== bWeight) {
            return aWeight - bWeight;
        }
        if (a.name && b.name) {
            return a.name.localeCompare(b.name);
        }
        return a.id.localeCompare(b.id);
    };
}
exports.mentionDescriptionComparator = mentionDescriptionComparator;
var Highlighter = /** @class */ (function () {
    function Highlighter() {
    }
    Highlighter.find = function (field, query) {
        var highlights = [];
        if (field) {
            var queryTokens = Tokenizer.tokenizeAsTokens(query.toLowerCase());
            queryTokens.sort(function (a, b) { return -1 * a.token.localeCompare(b.token); });
            var lowercaseField = field.toLowerCase();
            var fieldTokens = Tokenizer.tokenizeAsTokens(lowercaseField);
            for (var _i = 0, fieldTokens_1 = fieldTokens; _i < fieldTokens_1.length; _i++) {
                var fieldToken = fieldTokens_1[_i];
                for (var _a = 0, queryTokens_1 = queryTokens; _a < queryTokens_1.length; _a++) {
                    var queryToken = queryTokens_1[_a];
                    if (fieldToken.token.indexOf(queryToken.token) === 0) {
                        var start = fieldToken.start;
                        var end = start + queryToken.token.length - 1;
                        var i = end + 1;
                        var combiningCharacters = 0;
                        // Includes non spacing mark in highlights (e.g. ញុំ  when searching ញ)
                        while (i < fieldToken.token.length &&
                            nonSpacingMarkRegex.test(fieldToken.token[i])) {
                            ++combiningCharacters;
                            ++i;
                            nonSpacingMarkRegex.lastIndex = 0;
                        }
                        highlights.push({
                            start: start,
                            end: end + combiningCharacters,
                        });
                        break;
                    }
                }
            }
            if (highlights.length < queryTokens.length) {
                return [];
            }
        }
        return highlights;
    };
    return Highlighter;
}());
exports.Highlighter = Highlighter;
var SearchIndex = /** @class */ (function () {
    function SearchIndex() {
        this.reset();
    }
    SearchIndex.prototype.search = function (query) {
        var _this = this;
        if (query === void 0) { query = ''; }
        return new Promise(function (resolve) {
            var localResults = _this.index
                .search(query)
                .map(function (mention) {
                return tslib_1.__assign({}, mention, { highlight: {
                        name: Highlighter.find(mention.name, query),
                        mentionName: Highlighter.find(mention.mentionName, query),
                        nickname: Highlighter.find(mention.nickname, query),
                    } });
            })
                .filter(function (mention) {
                if (types_1.isSpecialMention(mention) &&
                    mention.highlight.nickname.length === 0) {
                    return false;
                }
                return true;
            });
            resolve({
                mentions: localResults,
                query: query,
            });
        });
    };
    SearchIndex.prototype.hasDocuments = function () {
        return this.indexedCount > 0;
    };
    SearchIndex.prototype.reset = function () {
        this.index = SearchIndex.createIndex();
        this.indexedCount = 0;
    };
    SearchIndex.prototype.indexResults = function (mentions) {
        this.index.addDocuments(mentions);
        this.indexedCount += mentions.length;
    };
    SearchIndex.createIndex = function () {
        var index = new js_search_1.Search('id');
        index.searchIndex = new js_search_1.UnorderedSearchIndex();
        index.tokenizer = Tokenizer;
        index.addIndex('name');
        index.addIndex('mentionName');
        index.addIndex('nickname');
        return index;
    };
    return SearchIndex;
}());
exports.SearchIndex = SearchIndex;
//# sourceMappingURL=searchIndex.js.map