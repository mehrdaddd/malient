"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var helpers_1 = require("../internal/helpers");
var analytics_1 = require("../analytics");
var types_1 = require("./types");
var AbstractReactionsResource_1 = require("./AbstractReactionsResource");
var requestService = function (baseUrl, path, opts) {
    var url = baseUrl + "/" + path;
    var options = opts;
    return new Promise(function (resolve, reject) {
        fetch(new Request(url, options))
            .then(function (response) {
            if (response.ok) {
                resolve(response.json());
            }
            else {
                reject({
                    code: response.status,
                    reason: response.statusText,
                });
            }
        })
            .catch(reject);
    });
};
var ReactionsResource = /** @class */ (function (_super) {
    tslib_1.__extends(ReactionsResource, _super);
    function ReactionsResource(config) {
        var _this = _super.call(this) || this;
        _this.config = config;
        _this.inFlightDetailsRequests = {};
        if (config.autoPoll) {
            _this.autoPoll(config.autoPoll);
        }
        return _this;
    }
    ReactionsResource.prototype.getHeaders = function () {
        var headers = new Headers();
        headers.append('Accept', 'application/json');
        headers.append('Content-Type', 'application/json');
        if (this.config.sessionToken) {
            headers.append('Authorization', this.config.sessionToken);
        }
        return headers;
    };
    ReactionsResource.prototype.getDetailedReaction = function (reaction) {
        var containerAri = reaction.containerAri, ari = reaction.ari, emojiId = reaction.emojiId;
        analytics_1.analyticsService.trackEvent('reactions.detailed.reaction', {
            containerAri: containerAri,
            ari: ari,
            emojiId: emojiId,
        });
        var reactionId = containerAri + "|" + ari + "|" + emojiId;
        var headers = this.getHeaders();
        headers.delete('Content-Type');
        return requestService(this.config.baseUrl, "reactions?reactionId=" + encodeURIComponent(reactionId), {
            method: 'GET',
            headers: headers,
            credentials: 'include',
        });
    };
    ReactionsResource.prototype.fetchReactionDetails = function (reaction) {
        var _this = this;
        var containerAri = reaction.containerAri, ari = reaction.ari, emojiId = reaction.emojiId;
        analytics_1.analyticsService.trackEvent('reactions.detailed.reaction', {
            containerAri: containerAri,
            ari: ari,
            emojiId: emojiId,
        });
        var reactionId = containerAri + "|" + ari + "|" + emojiId;
        if (!this.inFlightDetailsRequests[reactionId]) {
            this.inFlightDetailsRequests[reactionId] = this.getDetailedReaction(reaction).then(function (reactionDetails) {
                var containerAri = reactionDetails.containerAri, ari = reactionDetails.ari, emojiId = reactionDetails.emojiId;
                var key = _this.objectReactionKey(containerAri, ari);
                if (!_this.cachedReactions[key]) {
                    _this.cachedReactions = tslib_1.__assign({}, _this.cachedReactions, (_a = {}, _a[key] = {
                        status: types_1.ReactionStatus.ready,
                        reactions: [],
                    }, _a));
                }
                var state = _this.cachedReactions[key];
                if (state.status === types_1.ReactionStatus.ready) {
                    var reactionIndex = helpers_1.findIndex(state.reactions, function (r) { return r.emojiId === emojiId; });
                    if (reactionIndex !== -1) {
                        var existingReaction = state.reactions[reactionIndex];
                        if (!existingReaction.optimisticallyUpdated) {
                            state.reactions = helpers_1.updateReadonlyArray(state.reactions, reactionIndex, function (_) { return reactionDetails; });
                            _this.notifyUpdated(containerAri, ari, state);
                        }
                    }
                    delete _this.inFlightDetailsRequests[reactionId];
                }
                return reactionDetails;
                var _a;
            }, function () { return delete _this.inFlightDetailsRequests[reactionId]; });
        }
        return this.inFlightDetailsRequests[reactionId];
    };
    ReactionsResource.prototype.getReactions = function (keys) {
        var _this = this;
        if (keys.length === 0) {
            return Promise.resolve({});
        }
        var aris = keys.map(function (key) { return key.ari; });
        var containerAri = keys[0].containerAri;
        return new Promise(function (resolve, reject) {
            requestService(_this.config.baseUrl, 'reactions/view', {
                method: 'POST',
                headers: _this.getHeaders(),
                body: JSON.stringify({
                    containerAri: containerAri,
                    aris: aris,
                }),
                credentials: 'include',
            }).then(function (reactions) {
                Object.keys(reactions).forEach(function (ari) {
                    var cacheKey = _this.objectReactionKey(containerAri, ari);
                    _this.cachedReactions = tslib_1.__assign({}, _this.cachedReactions, (_a = {}, _a[cacheKey] = {
                        status: types_1.ReactionStatus.ready,
                        reactions: reactions[ari],
                    }, _a));
                    var _a;
                });
                resolve(reactions);
            });
        });
    };
    ReactionsResource.prototype.addReaction = function (containerAri, ari, emojiId) {
        var _this = this;
        analytics_1.analyticsService.trackEvent('reactions.add.reaction', {
            containerAri: containerAri,
            ari: ari,
            emojiId: emojiId,
        });
        this.optimisticAddReaction(containerAri, ari, emojiId);
        var timestamp = Date.now();
        this.lastActionForAri[ari] = timestamp;
        return new Promise(function (resolve, reject) {
            requestService(_this.config.baseUrl, 'reactions', {
                method: 'POST',
                headers: _this.getHeaders(),
                body: JSON.stringify({ emojiId: emojiId, ari: ari, containerAri: containerAri }),
                credentials: 'include',
            })
                .then(function (reactions) {
                var key = _this.objectReactionKey(containerAri, ari);
                // Do not update cache if it was already updated by a more recent action
                if (_this.lastActionForAri[ari] === timestamp) {
                    _this.cachedReactions = tslib_1.__assign({}, _this.cachedReactions, (_a = {}, _a[key] = {
                        status: types_1.ReactionStatus.ready,
                        reactions: reactions.reactions,
                    }, _a));
                }
                resolve(_this.cachedReactions[key]);
                var _a;
            })
                .catch(function () { return reject(); });
        });
    };
    ReactionsResource.prototype.deleteReaction = function (containerAri, ari, emojiId) {
        var _this = this;
        analytics_1.analyticsService.trackEvent('reactions.delete.reaction', {
            containerAri: containerAri,
            ari: ari,
            emojiId: emojiId,
        });
        this.optimisticDeleteReaction(containerAri, ari, emojiId);
        var timestamp = Date.now();
        this.lastActionForAri[ari] = timestamp;
        return new Promise(function (resolve, reject) {
            requestService(_this.config.baseUrl, "reactions?ari=" + ari + "&emojiId=" + emojiId + "&containerAri=" + containerAri, {
                method: 'DELETE',
                headers: _this.getHeaders(),
                credentials: 'include',
            })
                .then(function (reactions) {
                var key = _this.objectReactionKey(containerAri, ari);
                // Do not update cache if it was already updated by a more recent action
                if (_this.lastActionForAri[ari] === timestamp) {
                    _this.cachedReactions = tslib_1.__assign({}, _this.cachedReactions, (_a = {}, _a[key] = {
                        status: types_1.ReactionStatus.ready,
                        reactions: reactions.reactions,
                    }, _a));
                }
                resolve(_this.cachedReactions[key]);
                var _a;
            })
                .catch(function () { return reject(); });
        });
    };
    return ReactionsResource;
}(AbstractReactionsResource_1.default));
exports.default = ReactionsResource;
//# sourceMappingURL=ReactionsResource.js.map