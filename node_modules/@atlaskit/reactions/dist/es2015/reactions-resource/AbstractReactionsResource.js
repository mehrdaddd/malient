import * as tslib_1 from "tslib";
import { findIndex, equalEmojiId, updateReadonlyArray, } from '../internal/helpers';
import { ReactionStatus, } from './types';
var AbstractReactionsResource = /** @class */ (function () {
    function AbstractReactionsResource() {
        this.excludeArisFromAutoPoll = [];
        this.cachedReactions = {};
        this.subscribers = {};
        this.lastActionForAri = {};
        this.batchedKeys = [];
        this.debounced = null;
        this.loadingStatus = {
            status: ReactionStatus.loading,
        };
        this.errorStatus = {
            status: ReactionStatus.error,
            message: 'Error while fetching reactions',
        };
    }
    AbstractReactionsResource.prototype.autoPoll = function (autoPollInterval) {
        var _this = this;
        if (!autoPollInterval) {
            return;
        }
        setTimeout(function () {
            var aris = Object.keys(_this.subscribers);
            if (aris.length) {
                var subscriptionKeys = aris.map(function (ari) {
                    var tokens = ari.split('|');
                    return {
                        ari: tokens[1],
                        containerAri: tokens[0],
                    };
                });
                _this.getReactions(subscriptionKeys).then(function (reactions) {
                    Object.keys(reactions).forEach(function (ari) {
                        _this.includeAriInAutoPoll(ari);
                        _this.notifyUpdated(reactions[ari][0].containerAri, ari, {
                            status: ReactionStatus.ready,
                            reactions: reactions[ari],
                        });
                    });
                    _this.autoPoll(autoPollInterval);
                });
            }
            else {
                _this.autoPoll(autoPollInterval);
            }
        }, autoPollInterval);
    };
    AbstractReactionsResource.prototype.findReaction = function (key, emojiId) {
        var reactionState = this.cachedReactions[key];
        var index = this.findReactionIndex(key, emojiId);
        return index !== -1 &&
            reactionState &&
            reactionState.status === ReactionStatus.ready
            ? reactionState.reactions[index]
            : undefined;
    };
    AbstractReactionsResource.prototype.findReactionIndex = function (key, emojiId) {
        var reactionState = this.cachedReactions[key];
        if (reactionState && reactionState.status === ReactionStatus.ready) {
            return reactionState.reactions.findIndex(function (reaction) {
                return equalEmojiId(reaction.emojiId, emojiId);
            });
        }
        return -1;
    };
    AbstractReactionsResource.prototype.hasReacted = function (key, emojiId) {
        var reaction = this.findReaction(key, emojiId);
        return reaction && reaction.reacted;
    };
    AbstractReactionsResource.prototype.toggleReaction = function (containerAri, ari, emojiId) {
        var _this = this;
        var key = containerAri + "|" + ari;
        if (this.hasReacted(key, emojiId)) {
            return this.deleteReaction(containerAri, ari, emojiId)
                .then(function (state) {
                _this.notifyUpdated(containerAri, ari, state);
                return state;
            })
                .catch(function (e) {
                _this.optimisticAddReaction(containerAri, ari, emojiId);
                _this.notifyUpdated(containerAri, ari, _this.cachedReactions[key]);
                throw e;
            });
        }
        else {
            return this.addReaction(containerAri, ari, emojiId)
                .then(function (state) {
                _this.notifyUpdated(containerAri, ari, state);
                return state;
            })
                .catch(function (e) {
                _this.optimisticDeleteReaction(containerAri, ari, emojiId);
                _this.notifyUpdated(containerAri, ari, _this.cachedReactions[key]);
                throw e;
            });
        }
    };
    AbstractReactionsResource.prototype.notifyUpdated = function (containerAri, ari, state) {
        var key = this.objectReactionKey(containerAri, ari);
        if (!this.subscribers[key]) {
            return;
        }
        this.subscribers[key].forEach(function (listener) {
            listener.handler(state);
        });
    };
    AbstractReactionsResource.prototype.objectReactionKeyToString = function (key) {
        return this.objectReactionKey(key.containerAri, key.ari);
    };
    AbstractReactionsResource.prototype.objectReactionKey = function (containerAri, ari) {
        return containerAri + "|" + ari;
    };
    AbstractReactionsResource.prototype.subscribe = function (subscriptionKey, handler) {
        var _this = this;
        var key = this.objectReactionKeyToString(subscriptionKey);
        if (!this.subscribers[key]) {
            this.subscribers[key] = [];
        }
        this.subscribers[key].push({ handler: handler });
        this.notifyUpdated(subscriptionKey.containerAri, subscriptionKey.ari, this.loadingStatus);
        if (this.debounced) {
            clearTimeout(this.debounced);
        }
        this.queueAri(subscriptionKey);
        this.debounced = setTimeout(function () {
            _this.getReactions(_this.batchedKeys)
                .then(function (reactions) {
                Object.keys(reactions).forEach(function (key) {
                    var objectReactions = reactions[key];
                    var containerAri = subscriptionKey.containerAri;
                    var ari = key;
                    _this.dequeueAri({
                        ari: ari,
                        containerAri: containerAri,
                    });
                    _this.notifyUpdated(containerAri, ari, {
                        status: ReactionStatus.ready,
                        reactions: objectReactions,
                    });
                });
            })
                .catch(function () {
                _this.batchedKeys.forEach(function (key) {
                    _this.notifyUpdated(key.containerAri, key.ari, _this.errorStatus);
                });
            });
        }, 1);
    };
    AbstractReactionsResource.prototype.unsubscribe = function (subscriptionKey, handler) {
        var key = this.objectReactionKeyToString(subscriptionKey);
        if (!this.subscribers[key]) {
            return;
        }
        var index = findIndex(this.subscribers[key], function (listener) { return listener.handler === handler; });
        if (index !== -1) {
            this.subscribers[key].splice(index, 1);
        }
    };
    AbstractReactionsResource.prototype.queueAri = function (subscriptionKey) {
        var index = findIndex(this.batchedKeys, function (i) {
            return i.ari === subscriptionKey.ari &&
                i.containerAri === subscriptionKey.containerAri;
        });
        if (index === -1) {
            this.batchedKeys.push(subscriptionKey);
        }
    };
    AbstractReactionsResource.prototype.dequeueAri = function (subscriptionKey) {
        var index = findIndex(this.batchedKeys, function (i) {
            return i.ari === subscriptionKey.ari &&
                i.containerAri === subscriptionKey.containerAri;
        });
        if (index !== -1) {
            this.batchedKeys.splice(index, 1);
        }
    };
    AbstractReactionsResource.prototype.excludeAriFromAutoPoll = function (ari) {
        if (this.excludeArisFromAutoPoll.indexOf(ari) === -1) {
            this.excludeArisFromAutoPoll.push(ari);
        }
    };
    AbstractReactionsResource.prototype.includeAriInAutoPoll = function (ari) {
        var index = this.excludeArisFromAutoPoll.indexOf(ari);
        if (index === -1) {
            return;
        }
        this.excludeArisFromAutoPoll.splice(index, 1);
    };
    AbstractReactionsResource.prototype.optimisticAddReaction = function (containerAri, ari, emojiId) {
        var key = this.objectReactionKey(containerAri, ari);
        this.excludeAriFromAutoPoll(ari);
        if (!this.cachedReactions[key]) {
            this.cachedReactions = tslib_1.__assign({}, this.cachedReactions, (_a = {}, _a[key] = {
                status: ReactionStatus.ready,
                reactions: [],
            }, _a));
        }
        var reactionState = this.cachedReactions[key];
        if (reactionState.status === ReactionStatus.ready) {
            var reactionIndex = this.findReactionIndex(key, emojiId);
            if (reactionIndex !== -1) {
                reactionState.reactions = updateReadonlyArray(reactionState.reactions, reactionIndex, function (previous) {
                    return tslib_1.__assign({}, previous, { reacted: true, count: previous.count + 1, optimisticallyUpdated: true });
                });
            }
            else {
                reactionState.reactions = reactionState.reactions.concat([
                    {
                        ari: ari,
                        containerAri: containerAri,
                        emojiId: emojiId,
                        count: 1,
                        reacted: true,
                        optimisticallyUpdated: true,
                    },
                ]);
            }
        }
        this.notifyUpdated(containerAri, ari, tslib_1.__assign({}, this.cachedReactions[key]));
        var _a;
    };
    AbstractReactionsResource.prototype.optimisticDeleteReaction = function (containerAri, ari, emojiId) {
        var key = this.objectReactionKey(containerAri, ari);
        this.excludeAriFromAutoPoll(ari);
        var reactionState = this.cachedReactions[key];
        var reactionIndex = this.findReactionIndex(key, emojiId);
        if (reactionState.status === ReactionStatus.ready) {
            reactionState.reactions = updateReadonlyArray(reactionState.reactions, reactionIndex, function (previous) {
                return tslib_1.__assign({}, previous, { reacted: false, count: previous.count - 1, optimisticallyUpdated: true });
            }).filter(function (value) { return value.count > 0; });
            this.notifyUpdated(containerAri, ari, reactionState);
        }
    };
    return AbstractReactionsResource;
}());
export default AbstractReactionsResource;
//# sourceMappingURL=AbstractReactionsResource.js.map