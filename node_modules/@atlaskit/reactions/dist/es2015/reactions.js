import * as tslib_1 from "tslib";
import * as React from 'react';
import { Component } from 'react';
import { style } from 'typestyle';
import Tooltip from '@atlaskit/tooltip';
import Reaction from './internal/reaction';
import ReactionPicker from './reaction-picker';
import { ReactionStatus, } from './reactions-resource';
import { sortByRelevance, sortByPreviousPosition } from './internal/helpers';
var reactionStyle = style({
    display: 'inline-block',
    margin: '0 4px',
});
var reactionsStyle = style({
    display: 'flex',
    position: 'relative',
    background: 'white',
    alignItems: 'center',
    borderRadius: '15px',
    $nest: { '& > :first-child': { marginLeft: 0 } },
});
var Reactions = /** @class */ (function (_super) {
    tslib_1.__extends(Reactions, _super);
    function Reactions(props) {
        var _this = _super.call(this, props) || this;
        // flag to avoid flashing the background of the first set of rections
        _this.flashOnMount = false;
        _this.onEmojiClick = function (emojiId) {
            _this.props.onReactionClick(emojiId);
        };
        _this.onReactionHover = function (reaction) {
            var onReactionHover = _this.props.onReactionHover;
            if (onReactionHover) {
                onReactionHover(reaction);
            }
        };
        _this.flash = function (emojiId) {
            if (_this.reactionRefs[emojiId]) {
                _this.reactionRefs[emojiId].flash();
            }
        };
        _this.getReactionsSortFunction = function (reactions) {
            return reactions && reactions.length
                ? sortByPreviousPosition(reactions)
                : sortByRelevance;
        };
        _this.updateState = function (reactionState) {
            if (reactionState.status === ReactionStatus.ready) {
                var newReactions_1 = reactionState.reactions;
                _this.setState(function (_a) {
                    var reactions = _a.reactions;
                    return ({
                        loading: false,
                        error: false,
                        reactions: newReactions_1.slice().sort(_this.getReactionsSortFunction(reactions)),
                    });
                }, 
                // setting to true so new reactions will flash on mount
                !_this.flashOnMount ? function () { return (_this.flashOnMount = true); } : undefined);
            }
            else if (reactionState.status === ReactionStatus.loading) {
                _this.setState({
                    error: false,
                    loading: true,
                    reactions: [],
                });
            }
            else if (reactionState.status === ReactionStatus.error) {
                _this.setState({
                    loading: false,
                    error: true,
                    reactions: [],
                });
            }
        };
        _this.handleReactionPickerSelection = function (emojiId) {
            if (!_this.hasAlreadyReacted(emojiId)) {
                _this.onEmojiClick(emojiId);
            }
            else {
                _this.flash(emojiId);
            }
        };
        _this.handleReactionRef = function (emojiId) { return function (reaction) {
            _this.reactionRefs[emojiId] = reaction;
        }; };
        _this.getTooltip = function () {
            switch (true) {
                case _this.state.error:
                    return 'Sorry... something went wrong';
                case _this.state.loading:
                    return 'Loading...';
                default:
                    return null;
            }
        };
        _this.renderReaction = function (reaction, index) {
            var emojiId = reaction.emojiId;
            return (React.createElement(Reaction, { key: emojiId, ref: _this.handleReactionRef(emojiId), className: reactionStyle, reaction: tslib_1.__assign({}, reaction), emojiProvider: _this.props.emojiProvider, onClick: _this.onEmojiClick, onMouseOver: _this.onReactionHover, flashOnMount: _this.flashOnMount }));
        };
        _this.renderReactions = function () { return _this.state.reactions.map(_this.renderReaction); };
        _this.state = { reactions: [], loading: false, error: false };
        _this.timeouts = [];
        _this.reactionRefs = {};
        return _this;
    }
    Reactions.prototype.componentDidMount = function () {
        var _a = this.props, ari = _a.ari, containerAri = _a.containerAri, reactionsProvider = _a.reactionsProvider;
        reactionsProvider.subscribe({ ari: ari, containerAri: containerAri }, this.updateState);
    };
    Reactions.prototype.componentWillUnmount = function () {
        var _a = this.props, ari = _a.ari, containerAri = _a.containerAri, reactionsProvider = _a.reactionsProvider;
        reactionsProvider.unsubscribe({ ari: ari, containerAri: containerAri }, this.updateState);
        this.timeouts.forEach(clearTimeout);
    };
    Reactions.prototype.hasAlreadyReacted = function (emojiId) {
        return (this.state.reactions.find(function (reaction) { return reaction.emojiId === emojiId && reaction.reacted; }) !== undefined);
    };
    Reactions.prototype.renderPicker = function () {
        var _a = this.props, emojiProvider = _a.emojiProvider, boundariesElement = _a.boundariesElement, allowAllEmojis = _a.allowAllEmojis;
        return (React.createElement(Tooltip, { content: this.getTooltip() },
            React.createElement(ReactionPicker, { className: reactionStyle, emojiProvider: emojiProvider, onSelection: this.handleReactionPickerSelection, miniMode: true, boundariesElement: boundariesElement, allowAllEmojis: allowAllEmojis, disabled: this.state.loading || this.state.error })));
    };
    Reactions.prototype.render = function () {
        return (React.createElement("div", { className: reactionsStyle },
            this.renderReactions(),
            this.renderPicker()));
    };
    return Reactions;
}(Component));
export default Reactions;
//# sourceMappingURL=reactions.js.map