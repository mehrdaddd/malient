import * as tslib_1 from "tslib";
import * as uuid from 'uuid';
import { MediaStore } from '@atlaskit/media-store';
import { EventEmitter2 } from 'eventemitter2';
import { defaultUploadParams } from '../domain/uploadParams';
import { mapAuthToSourceFileOwner } from '../popup/domain/source-file';
import { getPreviewFromBlob } from '../util/getPreviewFromBlob';
import { getPreviewFromVideo } from '../util/getPreviewFromVideo';
import { SmartMediaProgress } from '../domain/progress';
import { MAX_FILE_SIZE_FOR_PREVIEW, } from './uploadServiceFactory';
var NewUploadServiceImpl = /** @class */ (function () {
    function NewUploadServiceImpl(context, uploadParams) {
        var _this = this;
        this.context = context;
        this.emit = function (event, payload) {
            _this.emitter.emit(event, payload);
        };
        this.onFileSuccess = function (cancellableFileUpload, fileId) {
            var mediaFile = cancellableFileUpload.mediaFile;
            var collectionName = _this.uploadParams.collection;
            _this.copyFileToUsersCollection(fileId, collectionName).catch(console.log); // We intentionally swallow these errors
            var publicMediaFile = tslib_1.__assign({}, mediaFile, { publicId: fileId });
            _this.emit('file-converting', {
                file: publicMediaFile,
            });
            var subscription = _this.context
                .getMediaItemProvider(fileId, 'file', collectionName)
                .observable()
                .subscribe({
                next: function (fileItem) {
                    var fileDetails = fileItem.details;
                    var processingStatus = fileDetails.processingStatus;
                    if (processingStatus === 'succeeded' ||
                        processingStatus === 'failed') {
                        _this.emit('file-converted', {
                            file: publicMediaFile,
                            public: fileItem.details,
                        });
                        _this.releaseCancellableFile(mediaFile);
                    }
                },
                error: _this.onFileError.bind(_this, cancellableFileUpload, 'metadata_fetch_fail'),
            });
            cancellableFileUpload.cancel = function () {
                subscription.unsubscribe();
                _this.releaseCancellableFile(mediaFile);
            };
        };
        this.onFileProgress = function (_a, portion) {
            var mediaFile = _a.mediaFile, file = _a.file;
            var size = file.size;
            var progress = new SmartMediaProgress(size, size * portion, mediaFile.creationDate, Date.now());
            _this.emit('file-uploading', {
                file: mediaFile,
                progress: progress.toJSON(),
            });
        };
        this.onFileError = function (mediaFile, mediaErrorName, error) {
            _this.releaseCancellableFile(mediaFile);
            if (error === 'canceled') {
                // Specific error coming from chunkinator via rejected fileId promise.
                // We do not want to trigger error in this case.
                return;
            }
            var description = error instanceof Error ? error.message : error;
            _this.emit('file-upload-error', {
                file: mediaFile,
                error: {
                    fileId: mediaFile.id,
                    description: description,
                    name: mediaErrorName,
                },
            });
        };
        this.emitter = new EventEmitter2();
        this.cancellableFilesUploads = {};
        if (context.config.userAuthProvider) {
            this.userMediaStore = new MediaStore({
                serviceHost: context.config.serviceHost,
                authProvider: context.config.userAuthProvider,
            });
        }
        this.setUploadParams(uploadParams);
    }
    NewUploadServiceImpl.prototype.setUploadParams = function (uploadParams) {
        this.uploadParams = tslib_1.__assign({}, defaultUploadParams, uploadParams);
    };
    NewUploadServiceImpl.prototype.addFiles = function (files) {
        var _this = this;
        if (files.length === 0) {
            return;
        }
        var creationDate = Date.now();
        var cancellableFileUploads = files.map(function (file) { return ({
            mediaFile: {
                id: uuid.v4(),
                name: file.name,
                size: file.size,
                creationDate: creationDate,
                type: file.type,
            },
            file: file,
        }); });
        var mediaFiles = cancellableFileUploads.map(function (cancellableFileUpload) { return cancellableFileUpload.mediaFile; });
        this.emit('files-added', { files: mediaFiles });
        this.emitPreviews(cancellableFileUploads);
        cancellableFileUploads.forEach(function (cancellableFileUpload) {
            var mediaFile = cancellableFileUpload.mediaFile, file = cancellableFileUpload.file;
            _this.cancellableFilesUploads[mediaFile.id] = cancellableFileUpload;
            var uploadableFile = {
                collection: _this.uploadParams.collection,
                content: file,
                name: file.name,
                mimeType: file.type,
            };
            var _a = _this.context.uploadFile(uploadableFile, {
                onProgress: _this.onFileProgress.bind(_this, cancellableFileUpload),
            }), deferredFileId = _a.deferredFileId, cancel = _a.cancel;
            cancellableFileUpload.cancel = cancel;
            deferredFileId.then(_this.onFileSuccess.bind(_this, cancellableFileUpload), _this.onFileError.bind(_this, mediaFile, 'upload_fail'));
        });
    };
    NewUploadServiceImpl.prototype.cancel = function (id) {
        var _this = this;
        if (id) {
            var cancellableFileUpload = this.cancellableFilesUploads[id];
            if (cancellableFileUpload && cancellableFileUpload.cancel) {
                cancellableFileUpload.cancel();
            }
        }
        else {
            Object.keys(this.cancellableFilesUploads).forEach(function (key) {
                var cancellableFileUpload = _this.cancellableFilesUploads[key];
                if (cancellableFileUpload.cancel) {
                    cancellableFileUpload.cancel();
                }
            });
        }
    };
    NewUploadServiceImpl.prototype.on = function (event, listener) {
        this.emitter.on(event, listener);
    };
    NewUploadServiceImpl.prototype.off = function (event, listener) {
        this.emitter.off(event, listener);
    };
    NewUploadServiceImpl.prototype.emitPreviews = function (cancellableFileUploads) {
        var _this = this;
        cancellableFileUploads.forEach(function (cancellableFileUpload) {
            var file = cancellableFileUpload.file, mediaFile = cancellableFileUpload.mediaFile;
            var size = file.size;
            var mediaType = _this.getMediaTypeFromFile(file);
            if (size < MAX_FILE_SIZE_FOR_PREVIEW && mediaType === 'image') {
                getPreviewFromBlob(file, mediaType).then(function (preview) {
                    _this.emit('file-preview-update', {
                        file: mediaFile,
                        preview: preview,
                    });
                });
            }
            else if (mediaType === 'video') {
                getPreviewFromVideo(file).then(function (preview) {
                    _this.emit('file-preview-update', {
                        file: mediaFile,
                        preview: preview,
                    });
                });
            }
        });
    };
    NewUploadServiceImpl.prototype.getMediaTypeFromFile = function (file) {
        var type = file.type;
        if (type.match(/^image\//)) {
            return 'image';
        }
        else if (type.match(/^video\//)) {
            return 'video';
        }
        return 'unknown';
    };
    NewUploadServiceImpl.prototype.releaseCancellableFile = function (mediaFile) {
        delete this.cancellableFilesUploads[mediaFile.id];
    };
    NewUploadServiceImpl.prototype.copyFileToUsersCollection = function (sourceFileId, sourceCollection) {
        var _this = this;
        if (!this.userMediaStore) {
            return Promise.resolve();
        }
        return this.context.config
            .authProvider({ collectionName: sourceCollection })
            .then(function (auth) {
            var body = {
                sourceFile: {
                    id: sourceFileId,
                    collection: sourceCollection,
                    owner: tslib_1.__assign({}, mapAuthToSourceFileOwner(auth)),
                },
            };
            var params = {
                collection: 'recents',
            };
            return _this.userMediaStore.copyFileWithToken(body, params);
        });
    };
    return NewUploadServiceImpl;
}());
export { NewUploadServiceImpl };
//# sourceMappingURL=newUploadServiceImpl.js.map