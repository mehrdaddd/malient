"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var react_1 = require("react");
var react_redux_1 = require("react-redux");
var media_core_1 = require("@atlaskit/media-core");
var modal_dialog_1 = require("@atlaskit/modal-dialog");
/* Components */
var footer_1 = require("./footer/footer");
var sidebar_1 = require("./sidebar/sidebar");
var upload_1 = require("./views/upload/upload");
var giphyView_1 = require("./views/giphy/giphyView");
var browser_1 = require("./views/browser/browser");
var dropzone_1 = require("./dropzone/dropzone");
var mainEditorView_1 = require("./views/editor/mainEditorView");
/* Configs */
var config_1 = require("../config");
/* actions */
var startApp_1 = require("../actions/startApp");
var hidePopup_1 = require("../actions/hidePopup");
var fileUploadsStart_1 = require("../actions/fileUploadsStart");
var fileUploadPreviewUpdate_1 = require("../actions/fileUploadPreviewUpdate");
var fileUploadProgress_1 = require("../actions/fileUploadProgress");
var fileUploadProcessingStart_1 = require("../actions/fileUploadProcessingStart");
var fileUploadEnd_1 = require("../actions/fileUploadEnd");
var fileUploadError_1 = require("../actions/fileUploadError");
var __1 = require("../..");
var passContext_1 = require("./passContext");
var styled_1 = require("./styled");
var App = /** @class */ (function (_super) {
    tslib_1.__extends(App, _super);
    function App(props) {
        var _this = _super.call(this, props) || this;
        _this.setDropzoneActive = function (isDropzoneActive) {
            _this.setState({
                isDropzoneActive: isDropzoneActive,
            });
        };
        var onStartApp = props.onStartApp, onUploadsStart = props.onUploadsStart, onUploadPreviewUpdate = props.onUploadPreviewUpdate, onUploadStatusUpdate = props.onUploadStatusUpdate, onUploadProcessing = props.onUploadProcessing, onUploadEnd = props.onUploadEnd, onUploadError = props.onUploadError, context = props.context;
        var userAuthProvider = context.config.userAuthProvider;
        if (!userAuthProvider) {
            throw new Error('userAuthProvider must be provided in the context');
        }
        _this.state = {
            isDropzoneActive: false,
        };
        var defaultConfig = {
            uploadParams: {
                collection: config_1.RECENTS_COLLECTION,
            },
        };
        // We can't just use the given context since the Cards in the recents view needs a different authProvider
        _this.mpContext = media_core_1.ContextFactory.create({
            serviceHost: context.config.serviceHost,
            authProvider: userAuthProvider,
        });
        _this.mpBrowser = __1.MediaPicker('browser', _this.mpContext, tslib_1.__assign({}, defaultConfig, { multiple: true, useNewUploadService: _this.props.useNewUploadService }));
        _this.mpBrowser.on('uploads-start', onUploadsStart);
        _this.mpBrowser.on('upload-preview-update', onUploadPreviewUpdate);
        _this.mpBrowser.on('upload-status-update', onUploadStatusUpdate);
        _this.mpBrowser.on('upload-processing', onUploadProcessing);
        _this.mpBrowser.on('upload-end', onUploadEnd);
        _this.mpBrowser.on('upload-error', onUploadError);
        _this.mpDropzone = __1.MediaPicker('dropzone', _this.mpContext, tslib_1.__assign({}, defaultConfig, { headless: true, useNewUploadService: _this.props.useNewUploadService }));
        _this.mpDropzone.on('drag-enter', function () { return _this.setDropzoneActive(true); });
        _this.mpDropzone.on('drag-leave', function () { return _this.setDropzoneActive(false); });
        _this.mpDropzone.on('uploads-start', onUploadsStart);
        _this.mpDropzone.on('upload-preview-update', onUploadPreviewUpdate);
        _this.mpDropzone.on('upload-status-update', onUploadStatusUpdate);
        _this.mpDropzone.on('upload-processing', onUploadProcessing);
        _this.mpDropzone.on('upload-end', onUploadEnd);
        _this.mpDropzone.on('upload-error', onUploadError);
        _this.mpBinary = __1.MediaPicker('binary', _this.mpContext, tslib_1.__assign({}, defaultConfig, { useNewUploadService: _this.props.useNewUploadService }));
        _this.mpBinary.on('uploads-start', onUploadsStart);
        _this.mpBinary.on('upload-preview-update', onUploadPreviewUpdate);
        _this.mpBinary.on('upload-status-update', onUploadStatusUpdate);
        _this.mpBinary.on('upload-processing', onUploadProcessing);
        _this.mpBinary.on('upload-end', onUploadEnd);
        _this.mpBinary.on('upload-error', onUploadError);
        onStartApp({
            onCancelUpload: function (uploadId) {
                _this.mpBrowser.cancel(uploadId);
                _this.mpDropzone.cancel(uploadId);
                _this.mpBinary.cancel(uploadId);
            },
        });
        return _this;
    }
    App.prototype.componentWillReceiveProps = function (_a) {
        var isVisible = _a.isVisible;
        if (isVisible !== this.props.isVisible) {
            if (isVisible) {
                this.mpDropzone.activate();
            }
            else {
                this.mpDropzone.deactivate();
            }
        }
    };
    App.prototype.componentWillUnmount = function () {
        this.mpDropzone.deactivate();
    };
    App.prototype.render = function () {
        var _a = this.props, selectedServiceName = _a.selectedServiceName, isVisible = _a.isVisible, onClose = _a.onClose, store = _a.store;
        var isDropzoneActive = this.state.isDropzoneActive;
        if (!isVisible) {
            return null;
        }
        return (React.createElement(react_redux_1.Provider, { store: store },
            React.createElement(modal_dialog_1.default, { onClose: onClose, width: "x-large", isChromeless: true },
                React.createElement(passContext_1.default, { store: store },
                    React.createElement(styled_1.MediaPickerPopupWrapper, null,
                        React.createElement(styled_1.SidebarWrapper, null,
                            React.createElement(sidebar_1.default, null)),
                        React.createElement(styled_1.ViewWrapper, null,
                            this.renderCurrentView(selectedServiceName),
                            React.createElement(footer_1.default, null)),
                        React.createElement(dropzone_1.Dropzone, { isActive: isDropzoneActive }),
                        React.createElement(mainEditorView_1.default, { binaryUploader: this.mpBinary }))))));
    };
    App.prototype.renderCurrentView = function (selectedServiceName) {
        if (selectedServiceName === 'upload') {
            return (React.createElement(upload_1.default, { mpBrowser: this.mpBrowser, context: this.mpContext, recentsCollection: config_1.RECENTS_COLLECTION }));
        }
        else if (selectedServiceName === 'giphy') {
            return React.createElement(giphyView_1.default, null);
        }
        else {
            return React.createElement(browser_1.default, null);
        }
    };
    return App;
}(react_1.Component));
exports.App = App;
var mapStateToProps = function (_a) {
    var view = _a.view, context = _a.context, useNewUploadService = _a.useNewUploadService;
    return ({
        selectedServiceName: view.service.name,
        isVisible: view.isVisible,
        useNewUploadService: useNewUploadService,
        context: context,
    });
};
var mapDispatchToProps = function (dispatch) { return ({
    onStartApp: function (payload) { return dispatch(startApp_1.startApp(payload)); },
    onUploadsStart: function (payload) {
        return dispatch(fileUploadsStart_1.fileUploadsStart(payload));
    },
    onClose: function () { return dispatch(hidePopup_1.hidePopup()); },
    onUploadPreviewUpdate: function (payload) {
        return dispatch(fileUploadPreviewUpdate_1.fileUploadPreviewUpdate(payload));
    },
    onUploadStatusUpdate: function (payload) {
        return dispatch(fileUploadProgress_1.fileUploadProgress(payload));
    },
    onUploadProcessing: function (payload) {
        return dispatch(fileUploadProcessingStart_1.fileUploadProcessingStart(payload));
    },
    onUploadEnd: function (payload) {
        return dispatch(fileUploadEnd_1.fileUploadEnd(payload));
    },
    onUploadError: function (payload) {
        return dispatch(fileUploadError_1.fileUploadError(payload));
    },
}); };
exports.default = react_redux_1.connect(mapStateToProps, mapDispatchToProps)(App);
//# sourceMappingURL=app.js.map