"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_model_1 = require("prosemirror-model");
var LinkifyIt = require("linkify-it");
var whitelistedURLPatterns = [
    /^https?:\/\//im,
    /^ftps?:\/\//im,
    /^\//im,
    /^mailto:/im,
    /^skype:/im,
    /^callto:/im,
    /^facetime:/im,
    /^git:/im,
    /^irc6?:/im,
    /^news:/im,
    /^nntp:/im,
    /^feed:/im,
    /^cvs:/im,
    /^svn:/im,
    /^mvn:/im,
    /^ssh:/im,
    /^scp:\/\//im,
    /^sftp:\/\//im,
    /^itms:/im,
    /^notes:/im,
    /^hipchat:\/\//im,
    /^sourcetree:/im,
    /^urn:/im,
    /^tel:/im,
    /^xmpp:/im,
    /^telnet:/im,
    /^vnc:/im,
    /^rdp:/im,
    /^whatsapp:/im,
    /^slack:/im,
    /^sips?:/im,
    /^magnet:/im,
];
exports.isSafeUrl = function (url) {
    return whitelistedURLPatterns.some(function (p) { return p.test(url.trim()) === true; });
};
var linkify = LinkifyIt();
linkify.add('sourcetree:', 'http:');
function getLinkMatch(str) {
    var match = str && linkify.match(str);
    return match && match[0];
}
exports.getLinkMatch = getLinkMatch;
/**
 * Instance of class LinkMatcher are used in autoformatting in place of Regex.
 * Hence it has been made similar to regex with an exec method.
 * Extending it directly from class Regex was introducing some issues, thus that has been avoided.
 */
var LinkMatcher = /** @class */ (function () {
    function LinkMatcher() {
    }
    LinkMatcher.prototype.exec = function (str) {
        if (str[str.length - 1] === ' ') {
            var strSplit = str.slice(0, str.length - 1).split(' ');
            var match = linkify.match(strSplit[strSplit.length - 1]);
            if (match && match.length > 0) {
                var lastMatch = match[match.length - 1];
                lastMatch.length = lastMatch.lastIndex - lastMatch.index + 1;
                return [lastMatch];
            }
        }
        return null;
    };
    return LinkMatcher;
}());
exports.LinkMatcher = LinkMatcher;
/**
 * Adds protocol to url if needed.
 */
function normalizeUrl(url) {
    var match = getLinkMatch(url);
    return (match && match.url) || url;
}
exports.normalizeUrl = normalizeUrl;
function linkifyContent(schema, slice) {
    var fragment = linkinfyFragment(schema, slice.content);
    if (fragment) {
        return new prosemirror_model_1.Slice(fragment, slice.openStart, slice.openEnd);
    }
}
exports.linkifyContent = linkifyContent;
function linkinfyFragment(schema, fragment) {
    var linkified = [];
    var _loop_1 = function (i, len) {
        var child = fragment.child(i);
        if (child.type === schema.nodes.table) {
            return { value: void 0 };
        }
        if (child.isText) {
            var text = child.textContent;
            var link_1 = child.type.schema.marks['link'];
            var matches = findLinkMatches(text);
            var pos_1 = 0;
            matches.forEach(function (match) {
                if (match.start > 0) {
                    linkified.push(child.cut(pos_1, match.start));
                }
                linkified.push(child
                    .cut(match.start, match.end)
                    .mark(link_1
                    .create({ href: normalizeUrl(match.href) })
                    .addToSet(child.marks)));
                pos_1 = match.end;
            });
            if (pos_1 < text.length) {
                linkified.push(child.cut(pos_1));
            }
        }
        else {
            linkified.push(child.copy(linkinfyFragment(schema, child.content)));
        }
    };
    for (var i = 0, len = fragment.childCount; i < len; i++) {
        var state_1 = _loop_1(i, len);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return prosemirror_model_1.Fragment.fromArray(linkified);
}
function findLinkMatches(text) {
    var matches = [];
    var linkMatches = text && linkify.match(text);
    if (linkMatches && linkMatches.length > 0) {
        linkMatches.forEach(function (match) {
            matches.push({
                start: match.index,
                end: match.lastIndex,
                title: match.raw,
                href: match.url,
            });
        });
    }
    return matches;
}
//# sourceMappingURL=url.js.map