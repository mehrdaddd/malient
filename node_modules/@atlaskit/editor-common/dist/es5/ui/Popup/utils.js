"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isBody(elem) {
    return elem === document.body;
}
exports.isBody = isBody;
function isTextNode(elem) {
    return elem && elem.nodeType === 3;
}
exports.isTextNode = isTextNode;
/**
 * Decides if given fitHeight fits below or above the target taking boundaries into account.
 */
function getVerticalPlacement(target, boundariesElement, fitHeight, alignY) {
    if (alignY) {
        return alignY;
    }
    if (!fitHeight) {
        return 'bottom';
    }
    if (isTextNode(target)) {
        target = target.parentElement;
    }
    var boundariesClientRect = boundariesElement.getBoundingClientRect();
    var boundriesHeight = boundariesClientRect.height;
    var boundriesTop = isBody(boundariesElement) ? 0 : boundariesClientRect.top;
    var _a = target.getBoundingClientRect(), targetTop = _a.top, targetHeight = _a.height;
    var spaceAbove = targetTop - (boundriesTop - boundariesElement.scrollTop);
    var spaceBelow = boundriesTop + boundriesHeight - (targetTop + targetHeight);
    if (spaceBelow >= fitHeight || spaceBelow >= spaceAbove) {
        return 'bottom';
    }
    return 'top';
}
exports.getVerticalPlacement = getVerticalPlacement;
/**
 * Decides if given fitWidth fits to the left or to the right of the target taking boundaries into account.
 */
function getHorizontalPlacement(target, boundariesElement, fitWidth, alignX) {
    if (alignX) {
        return alignX;
    }
    if (!fitWidth) {
        return 'left';
    }
    if (isTextNode(target)) {
        target = target.parentElement;
    }
    var _a = target.getBoundingClientRect(), targetLeft = _a.left, targetWidth = _a.width;
    var _b = boundariesElement.getBoundingClientRect(), boundriesLeft = _b.left, boundriesWidth = _b.width;
    var spaceLeft = targetLeft - boundriesLeft + targetWidth;
    var spaceRight = boundriesLeft + boundriesWidth - targetLeft;
    if (spaceRight >= fitWidth || spaceRight >= spaceLeft) {
        return 'left';
    }
    return 'right';
}
exports.getHorizontalPlacement = getHorizontalPlacement;
function calculatePlacement(target, boundariesElement, fitWidth, fitHeight, alignX, alignY) {
    return [
        getVerticalPlacement(target, boundariesElement, fitHeight, alignY),
        getHorizontalPlacement(target, boundariesElement, fitWidth, alignX),
    ];
}
exports.calculatePlacement = calculatePlacement;
/**
 * Calculates relative coordinates for placing popup along with the target.
 * Uses placement from calculatePlacement.
 */
function calculatePosition(_a) {
    var placement = _a.placement, target = _a.target, popup = _a.popup, offset = _a.offset, stickToBottom = _a.stickToBottom;
    var position = {};
    if (!target || !popup || !popup.offsetParent) {
        return position;
    }
    if (isTextNode(target)) {
        target = target.parentElement;
    }
    var popupOffsetParent = popup.offsetParent;
    var offsetParentStyle = popupOffsetParent.style;
    var borderBottomWidth = 0;
    if (offsetParentStyle && offsetParentStyle.borderBottomWidth) {
        borderBottomWidth = parseInt(offsetParentStyle.borderBottomWidth, 10);
    }
    var verticalPlacement = placement[0], horizontalPlacement = placement[1];
    var _b = popupOffsetParent.getBoundingClientRect(), popupOffsetParentTop = _b.top, popupOffsetParentLeft = _b.left, popupOffsetParentRight = _b.right, popupOffsetParentHeight = _b.height;
    var _c = target.getBoundingClientRect(), targetTop = _c.top, targetLeft = _c.left, targetRight = _c.right, targetHeight = _c.height;
    if (verticalPlacement === 'top') {
        position.bottom = Math.ceil(popupOffsetParentHeight -
            (targetTop - popupOffsetParentTop) -
            (isBody(popupOffsetParent) ? 0 : popupOffsetParent.scrollTop) -
            borderBottomWidth +
            offset[1]);
    }
    else {
        var top_1 = Math.ceil(targetTop -
            popupOffsetParentTop +
            targetHeight +
            (isBody(popupOffsetParent) ? 0 : popupOffsetParent.scrollTop) -
            borderBottomWidth +
            offset[1]);
        if (stickToBottom) {
            var scrollParent = findOverflowScrollParent(target);
            if (scrollParent) {
                var topOffsetTop = targetTop - scrollParent.getBoundingClientRect().top;
                var targetEnd = targetHeight + topOffsetTop;
                if (scrollParent.clientHeight - targetEnd <
                    popup.clientHeight + offset[1] + 1 &&
                    topOffsetTop < scrollParent.clientHeight) {
                    var marginBottom = window.getComputedStyle(target).marginBottom;
                    var marginBottomCalc = marginBottom ? parseFloat(marginBottom) : 0;
                    var scroll_1 = targetEnd + marginBottomCalc - scrollParent.clientHeight;
                    top_1 -= scroll_1 + popup.clientHeight + 1;
                }
            }
        }
        position.top = top_1;
    }
    if (horizontalPlacement === 'left') {
        position.left = Math.ceil(targetLeft -
            popupOffsetParentLeft +
            (isBody(popupOffsetParent) ? 0 : popupOffsetParent.scrollLeft) +
            offset[0]);
    }
    else if (horizontalPlacement === 'center') {
        var parentWidth = target.parentElement.clientWidth;
        var parentLeft = target.parentElement.getBoundingClientRect().left;
        var targetWidth = target.clientWidth;
        position.left = Math.ceil(parentLeft -
            popupOffsetParentLeft +
            (targetWidth > parentWidth ? parentWidth : targetWidth) / 2 -
            popup.clientWidth / 2 +
            offset[0]);
    }
    else {
        position.right = Math.ceil(popupOffsetParentRight -
            targetRight -
            (isBody(popupOffsetParent) ? 0 : popupOffsetParent.scrollLeft) +
            offset[0]);
    }
    return position;
}
exports.calculatePosition = calculatePosition;
/**
 * Traverse DOM Tree upwards looking for popup parents with "overflow: scroll".
 */
function findOverflowScrollParent(popup) {
    var parent = popup;
    if (!parent) {
        return false;
    }
    while ((parent = parent.parentElement)) {
        // IE11 on Window 8 doesn't show styles from CSS when accessing through element.style property.
        var style = window.getComputedStyle(parent);
        if (style.overflow === 'scroll' ||
            style.overflowX === 'scroll' ||
            style.overflowY === 'scroll') {
            return parent;
        }
    }
    return false;
}
exports.findOverflowScrollParent = findOverflowScrollParent;
//# sourceMappingURL=utils.js.map