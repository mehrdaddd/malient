"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Grabs the latest Items from the service, deduplicating against existing items.
 */
exports.loadLatestItems = function (query, existing, provider, recentUpdateContext) {
    if (recentUpdateContext.localId) {
        // Retry until localId is found
        return exports.retryIteration(function () { return provider.getItems(query).then(function (r) { return r.items; }); }, recentUpdateContext).then(function (items) { return exports.mergeItems(existing, items); });
    }
    // Just load
    return provider
        .getItems(query)
        .then(function (response) { return exports.mergeItems(existing, response.items); });
};
/**
 * Grabs the latest Decisions from the service, deduplicating against existing Decisions.
 */
exports.loadLatestDecisions = function (query, existing, provider) {
    return provider
        .getDecisions(query)
        .then(function (response) { return exports.mergeItems(existing, response.decisions); });
};
/**
 * Grabs the latest Tasks from the service, deduplicating against existing Tasks.
 */
exports.loadLatestTasks = function (query, existing, provider) {
    return provider
        .getTasks(query)
        .then(function (response) { return exports.mergeItems(existing, response.tasks); });
};
var retryDelaysInMilliseconds = [
    500,
    1000,
    1500,
    2500,
    4000,
    6000,
    8000,
    10000,
];
exports.retryIteration = function (loader, recentUpdateContext, retry) {
    if (retry === void 0) { retry = 0; }
    return exports.loadWithDelay(loader, retryDelaysInMilliseconds[retry]).then(function (items) {
        if (items.filter(function (item) { return item.localId === recentUpdateContext.localId; })
            .length > 0) {
            return items;
        }
        var delay = retryDelaysInMilliseconds[retry || 0];
        if (!delay) {
            // Give up - just retry what we've got.
            return items;
        }
        return exports.retryIteration(loader, recentUpdateContext, retry + 1);
    });
};
exports.loadWithDelay = function (loader, delay) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            loader().then(function (items) {
                resolve(items);
            });
        }, delay);
    });
};
exports.mergeItems = function (existingItems, newItems) {
    var newIds = new Set(newItems.map(function (item) { return item.localId; }));
    var unchangedItems = existingItems.filter(function (item) { return !newIds.has(item.localId); });
    return newItems.concat(unchangedItems);
};
//# sourceMappingURL=TaskDecisionLoader.js.map