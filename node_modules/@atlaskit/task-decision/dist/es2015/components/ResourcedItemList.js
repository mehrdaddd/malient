import * as tslib_1 from "tslib";
import * as React from 'react';
import { PureComponent } from 'react';
import styled from 'styled-components';
import Spinner from '@atlaskit/spinner';
import { defaultSortCriteria } from '../constants';
import { loadLatestItems } from '../api/TaskDecisionLoader';
import InfiniteScroll from './InfiniteScroll';
import ListContainer from '../styled/ListContainer';
import ListWrapper from '../styled/ListWrapper';
import DateGroup from '../styled/DateGroup';
import DateGroupHeader from '../styled/DateGroupHeader';
import { isDateSortCriteria, toRendererContext } from '../type-helpers';
import { getFormattedDate, getStartOfDate, isSameDate } from '../util/date';
import { isDecision, isTask, objectKeyToString, toObjectKey, } from '../type-helpers';
import DecisionItem from './DecisionItem';
import ResourcedTaskItem from './ResourcedTaskItem';
// tslint:disable-next-line:variable-name
var LoadingWrapper = styled.div(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 20px 0;\n  height: ", ";\n"], ["\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin: 20px 0;\n  height: ", ";\n"])), function (props) { return props.height || 'auto'; });
var ResourcedItemList = /** @class */ (function (_super) {
    tslib_1.__extends(ResourcedItemList, _super);
    function ResourcedItemList(props) {
        var _this = _super.call(this, props) || this;
        _this.loadLatest = function (recentUpdateContext) {
            var _a = _this.props, initialQuery = _a.initialQuery, taskDecisionProvider = _a.taskDecisionProvider;
            var items = _this.state.items;
            taskDecisionProvider.then(function (provider) {
                loadLatestItems(initialQuery, items || [], provider, recentUpdateContext).then(function (latestItems) {
                    if (_this.mounted) {
                        _this.setState({
                            items: latestItems,
                        });
                    }
                });
            });
        };
        _this.loadMore = function () {
            var nextQuery = _this.state.nextQuery;
            if (nextQuery) {
                _this.performQuery(nextQuery, false);
            }
        };
        _this.state = {
            loading: true,
            error: false,
        };
        return _this;
    }
    ResourcedItemList.prototype.componentDidMount = function () {
        this.mounted = true;
        this.performInitialQuery(this.props);
    };
    ResourcedItemList.prototype.componentWillUnmount = function () {
        this.mounted = false;
        this.unsubscribeRecentUpdates();
    };
    ResourcedItemList.prototype.componentWillReceiveProps = function (nextProps) {
        if (this.props.initialQuery !== nextProps.initialQuery ||
            this.props.taskDecisionProvider !== nextProps.taskDecisionProvider) {
            this.unsubscribeRecentUpdates();
            this.performInitialQuery(nextProps);
        }
    };
    ResourcedItemList.prototype.unsubscribeRecentUpdates = function () {
        var recentUpdatesId = this.recentUpdatesId;
        if (recentUpdatesId) {
            this.props.taskDecisionProvider.then(function (provider) {
                provider.unsubscribeRecentUpdates(recentUpdatesId);
            });
        }
        this.recentUpdatesId = undefined;
    };
    ResourcedItemList.prototype.performInitialQuery = function (props) {
        var _this = this;
        var initialQuery = props.initialQuery;
        this.performQuery(initialQuery, true, {
            id: function (id) {
                _this.recentUpdatesId = id;
            },
            recentUpdates: this.loadLatest,
        });
    };
    ResourcedItemList.prototype.performQuery = function (query, replaceAll, recentUpdatesListener) {
        var _this = this;
        var taskDecisionProvider = this.props.taskDecisionProvider;
        var items = replaceAll ? [] : this.state.items;
        this.setState({
            loading: true,
            error: false,
            items: items,
        });
        taskDecisionProvider.then(function (provider) {
            provider
                .getItems(query, recentUpdatesListener)
                .then(function (result) {
                if (!_this.mounted) {
                    return;
                }
                var items = result.items, nextQuery = result.nextQuery;
                var combinedItems;
                if (replaceAll) {
                    combinedItems = items;
                }
                else {
                    combinedItems = (_this.state.items || []).concat(items);
                }
                _this.setState({
                    items: combinedItems,
                    nextQuery: nextQuery,
                    loading: false,
                });
                var onUpdate = _this.props.onUpdate;
                if (onUpdate) {
                    onUpdate(combinedItems, items);
                }
            })
                .catch(function (err) {
                if (!_this.mounted) {
                    return;
                }
                _this.setState({
                    loading: false,
                    error: true,
                });
            });
        });
    };
    ResourcedItemList.prototype.renderItems = function () {
        var _a = this.props, appearance = _a.appearance, groupItems = _a.groupItems, initialQuery = _a.initialQuery;
        var items = this.state.items;
        if (!items) {
            return null;
        }
        var sortCriteria = initialQuery.sortCriteria;
        var renderedItems;
        if (groupItems && isDateSortCriteria(sortCriteria)) {
            renderedItems = this.renderItemsGroupedByDate(items);
        }
        else {
            renderedItems = this.renderItemsUngrouped(items);
        }
        return (React.createElement(ListContainer, { theme: { appearance: appearance } }, renderedItems));
    };
    ResourcedItemList.prototype.renderItemsUngrouped = function (items) {
        var _a = this.props, appearance = _a.appearance, renderDocument = _a.renderDocument, taskDecisionProvider = _a.taskDecisionProvider;
        return (React.createElement(ListWrapper, null, items.map(function (item) {
            var objectKey = toObjectKey(item);
            if (isDecision(item)) {
                return (React.createElement("li", { key: objectKeyToString(objectKey) },
                    React.createElement(DecisionItem, { appearance: appearance, participants: item.participants, creator: item.creator, lastUpdater: item.lastUpdater }, renderDocument(item.content, toRendererContext(objectKey)))));
            }
            if (isTask(item)) {
                return (React.createElement("li", { key: objectKeyToString(objectKey) },
                    React.createElement(ResourcedTaskItem, { key: objectKeyToString(objectKey), taskDecisionProvider: taskDecisionProvider, taskId: objectKey.localId, objectAri: objectKey.objectAri, containerAri: objectKey.containerAri, appearance: appearance, participants: item.participants, creator: item.creator, lastUpdater: item.lastUpdater }, renderDocument(item.content, toRendererContext(objectKey)))));
            }
            return null;
        })));
    };
    ResourcedItemList.prototype.renderItemsGroupedByDate = function (items) {
        var _this = this;
        var itemsByDate = this.groupItemsByDate(items);
        return (React.createElement(DateGroup, null, itemsByDate.map(function (_a) {
            var date = _a.date, items = _a.items;
            return (React.createElement("li", { key: date.toISOString() },
                React.createElement(DateGroupHeader, null, getFormattedDate(date)),
                _this.renderItemsUngrouped(items)));
        })));
    };
    ResourcedItemList.prototype.groupItemsByDate = function (items) {
        var groupByField = this.props.initialQuery.sortCriteria || defaultSortCriteria;
        var lastDate;
        return items.reduce(function (groups, item) {
            var currentDate = getStartOfDate(item[groupByField]);
            if (isSameDate(lastDate, currentDate)) {
                var lastGroup = groups[groups.length - 1];
                lastGroup.items.push(item);
            }
            else {
                lastDate = currentDate;
                groups.push({
                    date: currentDate,
                    items: [item],
                });
            }
            return groups;
        }, []);
    };
    ResourcedItemList.prototype.render = function () {
        var _a = this.props, emptyComponent = _a.emptyComponent, errorComponent = _a.errorComponent, height = _a.height, useInfiniteScroll = _a.useInfiniteScroll;
        var _b = this.state, error = _b.error, items = _b.items, loading = _b.loading;
        var loadingSpinner;
        if (error && errorComponent) {
            return errorComponent || null;
        }
        if (loading) {
            var height_1;
            if (!items || items.length === 0) {
                height_1 = '100%';
            }
            loadingSpinner = (React.createElement(LoadingWrapper, { height: height_1 },
                React.createElement(Spinner, { size: "medium" })));
        }
        else if (!items || !items.length) {
            return emptyComponent || null;
        }
        if (height && useInfiniteScroll) {
            return (React.createElement(InfiniteScroll, { height: height, onThresholdReached: this.loadMore },
                this.renderItems(),
                loadingSpinner));
        }
        return (React.createElement("div", null,
            this.renderItems(),
            loadingSpinner));
    };
    ResourcedItemList.defaultProps = {
        appearance: 'card',
    };
    return ResourcedItemList;
}(PureComponent));
export default ResourcedItemList;
var templateObject_1;
//# sourceMappingURL=ResourcedItemList.js.map