"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var PropTypes = require("prop-types");
var react_1 = require("react");
var classNames = require("classnames");
var uuid = require("uuid/v1");
var List_1 = require("react-virtualized/dist/commonjs/List");
var constants_1 = require("../../constants");
var EmojiPickerSizes_1 = require("./EmojiPickerSizes");
var EmojiPickerVirtualItems_1 = require("./EmojiPickerVirtualItems");
var styles = require("./styles");
var categories_1 = require("./categories");
var categoryClassname = 'emoji-category';
/**
 * Tracks which category is visible based on
 * scrollTop, and virtual rows.
 */
var CategoryTracker = /** @class */ (function () {
    function CategoryTracker() {
        this.reset();
    }
    CategoryTracker.prototype.reset = function () {
        this.categoryToRow = new Map();
        this.rowToCategory = new Map();
    };
    CategoryTracker.prototype.add = function (category, row) {
        if (!this.categoryToRow.has(category)) {
            this.categoryToRow.set(category, row);
            this.rowToCategory.set(row, category);
        }
    };
    CategoryTracker.prototype.getRow = function (category) {
        return this.categoryToRow.get(category);
    };
    CategoryTracker.prototype.findNearestCategoryAbove = function (startIndex, list) {
        var rows = Array.from(this.rowToCategory.keys()).sort(function (a, b) { return a - b; });
        if (rows.length === 0) {
            return;
        }
        // Return first category if list not yet rendered
        // or the top row is above the first category
        if (!list || rows[0] > startIndex) {
            return this.rowToCategory.get(rows[0]);
        }
        var bounds = [0, rows.length - 1];
        var index = Math.floor(rows.length / 2);
        while (rows[index] !== startIndex && bounds[0] < bounds[1]) {
            if (rows[index] > startIndex) {
                bounds[1] = Math.max(index - 1, 0);
            }
            else {
                bounds[0] = index + 1;
            }
            index = Math.floor((bounds[0] + bounds[1]) / 2);
        }
        var headerRow = rows[rows[index] > startIndex ? Math.max(index - 1, 0) : index];
        return this.rowToCategory.get(headerRow);
    };
    return CategoryTracker;
}());
var byOrder = function (orderableA, orderableB) {
    return (orderableA.order || 0) - (orderableB.order || 0);
};
var EmojiPickerVirtualList = /** @class */ (function (_super) {
    tslib_1.__extends(EmojiPickerVirtualList, _super);
    function EmojiPickerVirtualList(props) {
        var _this = _super.call(this, props) || this;
        _this.idSuffix = uuid();
        _this.virtualItems = [];
        _this.categoryTracker = new CategoryTracker();
        _this.onEmojiMouseEnter = function (emojiId, emoji, event) {
            if (_this.props.onEmojiActive) {
                _this.props.onEmojiActive(emojiId, emoji);
            }
        };
        _this.onSearch = function (e) {
            if (_this.props.onSearch) {
                _this.props.onSearch(e.target.value);
            }
        };
        _this.categoryId = function (category) { return "category_" + category + "_" + _this.idSuffix; };
        _this.buildCategory = function (group) {
            var _a = _this.props, onEmojiSelected = _a.onEmojiSelected, onEmojiDelete = _a.onEmojiDelete;
            var items = [];
            items.push(new EmojiPickerVirtualItems_1.CategoryHeadingItem({
                id: _this.categoryId(group.category),
                title: group.title,
                className: categoryClassname,
            }));
            var remainingEmojis = group.emojis;
            while (remainingEmojis.length > 0) {
                var rowEmojis = remainingEmojis.slice(0, EmojiPickerSizes_1.sizes.emojiPerRow);
                remainingEmojis = remainingEmojis.slice(EmojiPickerSizes_1.sizes.emojiPerRow);
                items.push(new EmojiPickerVirtualItems_1.EmojisRowItem({
                    emojis: rowEmojis,
                    title: group.title,
                    showDelete: group.title === constants_1.userCustomTitle,
                    onSelected: onEmojiSelected,
                    onDelete: onEmojiDelete,
                    onMouseMove: _this.onEmojiMouseEnter,
                }));
            }
            return items;
        };
        _this.buildVirtualItems = function (props, state) {
            var emojis = props.emojis, loading = props.loading, query = props.query;
            var items = [];
            _this.categoryTracker.reset();
            items.push(new EmojiPickerVirtualItems_1.SearchItem({
                onChange: _this.onSearch,
                query: query,
            }));
            if (loading) {
                items.push(new EmojiPickerVirtualItems_1.LoadingItem());
            }
            else {
                if (query) {
                    // Only a single "result" category
                    items = items.concat(_this.buildCategory({
                        category: 'Search',
                        title: 'Search results',
                        emojis: emojis,
                        order: 0,
                    }));
                }
                else {
                    // Group by category
                    // Not searching show in categories.
                    _this.allEmojiGroups.forEach(function (group) {
                        // Optimisation - avoid re-rendering unaffected groups for the current selectedShortcut
                        // by not passing it to irrelevant groups
                        _this.categoryTracker.add(group.category, items.length);
                        items = items.concat(_this.buildCategory(group));
                    });
                }
            }
            var rowCountChanged = _this.virtualItems.length !== items.length;
            _this.virtualItems = items;
            var list = _this.refs.list;
            if (!rowCountChanged && list) {
                // Row count has not changed, so need to tell list to rerender.
                list.forceUpdateGrid();
            }
            if (!query && list) {
                // VirtualList can apply stale heights since it performs a shallow
                // compare to check if the list has changed. Should manually recompute
                // row heights for the case when frequent category come in later
                list.recomputeRowHeights();
            }
        };
        _this.addToCategory = function (categories, emoji, category) {
            if (!categories[category]) {
                var categoryDefinition = categories_1.CategoryDescriptionMap[category];
                categories[category] = {
                    emojis: [],
                    title: categoryDefinition.name,
                    category: category,
                    order: categoryDefinition.order,
                };
            }
            categories[category].emojis.push(emoji);
            return categories;
        };
        _this.groupByCategory = function (currentUser) { return function (categories, emoji) {
            _this.addToCategory(categories, emoji, emoji.category);
            // separate user emojis
            if (emoji.category === constants_1.customCategory &&
                currentUser &&
                emoji.creatorUserId === currentUser.id) {
                _this.addToCategory(categories, emoji, 'USER_CUSTOM');
            }
            return categories;
        }; };
        _this.buildGroups = function (emojis, currentUser) {
            var categoryMap = emojis.reduce(_this.groupByCategory(currentUser), {});
            _this.allEmojiGroups = Object.keys(categoryMap)
                .map(function (key) { return categoryMap[key]; })
                .map(function (category) {
                if (category.category !== 'FREQUENT') {
                    category.emojis.sort(byOrder);
                }
                return category;
            })
                .sort(byOrder);
        };
        _this.repaintList = function () {
            if (_this.refs.root) {
                var root = _this.refs.root;
                var display = root.style.display;
                root.style.display = 'none';
                // tslint:disable-next-line:no-unused-expression no-unused-variable we need to access offset to force repaint
                root.offsetHeight;
                root.style.display = display;
            }
        };
        _this.checkCategoryChange = function (indexes) {
            var startIndex = indexes.startIndex;
            // FS-1844 Fix a rendering problem when scrolling to the top
            if (startIndex === 0) {
                _this.repaintList();
            }
            if (!_this.props.query) {
                // Calculate category in view - only relevant if categories shown, i.e. no query
                var list = _this.refs.list;
                var currentCategory = _this.categoryTracker.findNearestCategoryAbove(startIndex, list);
                if (currentCategory && _this.activeCategory !== currentCategory) {
                    _this.activeCategory = currentCategory;
                    if (_this.props.onCategoryActivated) {
                        _this.props.onCategoryActivated(currentCategory);
                    }
                }
            }
        };
        _this.rowSize = function (_a) {
            var index = _a.index;
            return _this.virtualItems[index].height;
        };
        _this.renderRow = function (context) {
            return EmojiPickerVirtualItems_1.virtualItemRenderer(_this.virtualItems, context);
        };
        _this.buildGroups(props.emojis, props.currentUser);
        _this.buildVirtualItems(props, _this.state);
        return _this;
    }
    EmojiPickerVirtualList.prototype.getChildContext = function () {
        var emoji = this.context.emoji;
        return {
            emoji: tslib_1.__assign({}, emoji),
        };
    };
    EmojiPickerVirtualList.prototype.componentWillUpdate = function (nextProps, nextState) {
        if (this.props.emojis !== nextProps.emojis ||
            this.props.selectedTone !== nextProps.selectedTone ||
            this.props.loading !== nextProps.loading ||
            this.props.query !== nextProps.query) {
            if (!nextProps.query) {
                // Only refresh if no query
                this.buildGroups(nextProps.emojis, nextProps.currentUser);
            }
            this.buildVirtualItems(nextProps, nextState);
        }
    };
    /**
     * Scrolls to a category in the list view
     */
    EmojiPickerVirtualList.prototype.reveal = function (category) {
        var row = this.categoryTracker.getRow(category);
        var list = this.refs.list;
        list.scrollToRow(row);
    };
    EmojiPickerVirtualList.prototype.scrollToBottom = function () {
        var list = this.refs.list;
        list.scrollToRow(this.virtualItems.length);
    };
    EmojiPickerVirtualList.prototype.render = function () {
        var _a = this.props, onMouseLeave = _a.onMouseLeave, onMouseEnter = _a.onMouseEnter;
        var classes = [styles.emojiPickerList];
        return (React.createElement("div", { ref: "root", className: classNames(classes), onMouseLeave: onMouseLeave, onMouseEnter: onMouseEnter },
            React.createElement(List_1.List, { ref: "list", height: EmojiPickerSizes_1.sizes.listHeight, overscanRowCount: 5, rowCount: this.virtualItems.length, rowHeight: this.rowSize, rowRenderer: this.renderRow, scrollToAlignment: "start", width: EmojiPickerSizes_1.sizes.listWidth, className: styles.virtualList, onRowsRendered: this.checkCategoryChange })));
    };
    EmojiPickerVirtualList.contextTypes = {
        emoji: PropTypes.object,
    };
    EmojiPickerVirtualList.childContextTypes = {
        emoji: PropTypes.object,
    };
    EmojiPickerVirtualList.defaultProps = {
        onEmojiSelected: function () { },
        onEmojiActive: function () { },
        onEmojiDelete: function () { },
        onCategoryActivated: function () { },
        onSearch: function () { },
    };
    return EmojiPickerVirtualList;
}(react_1.PureComponent));
exports.default = EmojiPickerVirtualList;
//# sourceMappingURL=EmojiPickerList.js.map