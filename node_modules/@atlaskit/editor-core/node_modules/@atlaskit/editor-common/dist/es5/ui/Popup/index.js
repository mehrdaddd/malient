"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var react_1 = require("react");
var raf_schd_1 = require("raf-schd");
var styles_1 = require("../../styles");
var Portal_1 = require("../Portal");
var utils_1 = require("./utils");
var Popup = /** @class */ (function (_super) {
    tslib_1.__extends(Popup, _super);
    function Popup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            overflowScrollParent: false,
        };
        _this.scheduledResizeFrame = null;
        _this.placement = ['', ''];
        _this.handleRef = function (popup) {
            if (!popup) {
                return;
            }
            _this.initPopup(popup);
        };
        _this.scheduledUpdatePosition = raf_schd_1.default(function () { return _this.updatePosition(); });
        _this.handleReposition = function () {
            _this.scheduledResizeFrame = _this.scheduledUpdatePosition();
        };
        return _this;
    }
    /**
     * Calculates new popup position
     */
    Popup.prototype.updatePosition = function (props, state) {
        if (props === void 0) { props = this.props; }
        if (state === void 0) { state = this.state; }
        var target = props.target, fitHeight = props.fitHeight, fitWidth = props.fitWidth, boundariesElement = props.boundariesElement, offset = props.offset, onPositionCalculated = props.onPositionCalculated, onPlacementChanged = props.onPlacementChanged, alignX = props.alignX, alignY = props.alignY, stickToBottom = props.stickToBottom;
        var popup = state.popup;
        if (!target || !popup) {
            return;
        }
        var placement = utils_1.calculatePlacement(target, boundariesElement, fitWidth, fitHeight, alignX, alignY);
        if (onPlacementChanged && this.placement.join('') !== placement.join('')) {
            onPlacementChanged(placement);
            this.placement = placement;
        }
        var position = utils_1.calculatePosition({
            placement: placement,
            popup: popup,
            target: target,
            offset: offset,
            stickToBottom: stickToBottom,
        });
        position = onPositionCalculated ? onPositionCalculated(position) : position;
        this.setState({ position: position });
    };
    /**
     * Popup initialization.
     * Checks whether it's possible to position popup along given target, and if it's not throws an error.
     */
    Popup.prototype.initPopup = function (popup) {
        var _this = this;
        var target = this.props.target;
        var overflowScrollParent = utils_1.findOverflowScrollParent(popup);
        if (popup.offsetParent && !popup.offsetParent.contains(target)) {
            throw new Error("Popup's offset parent doesn't contain target which means it's impossible to correctly position popup along with given target.");
        }
        if (overflowScrollParent &&
            !overflowScrollParent.contains(popup.offsetParent)) {
            throw new Error('Popup is inside "overflow: scroll" container, but its offset parent isn\'t. Currently Popup isn\'t capable of position itself correctly in such case. Add "position: relative" to "overflow: scroll" container or to some other FloatingPanel wrapper inside it.');
        }
        this.setState({ popup: popup, overflowScrollParent: overflowScrollParent }, function () { return _this.updatePosition(); });
    };
    Popup.prototype.componentWillReceiveProps = function (newProps) {
        this.updatePosition(newProps);
    };
    Popup.prototype.componentDidMount = function () {
        window.addEventListener('resize', this.handleReposition);
        var stickToBottom = this.props.stickToBottom;
        if (stickToBottom) {
            this.scrollElement = utils_1.findOverflowScrollParent(this.props.target);
        }
        else {
            this.scrollElement = this.props.scrollableElement;
        }
        if (this.scrollElement) {
            this.scrollElement.addEventListener('scroll', this.handleReposition);
        }
    };
    Popup.prototype.componentWillUnmount = function () {
        window.removeEventListener('resize', this.handleReposition);
        if (this.scheduledResizeFrame) {
            cancelAnimationFrame(this.scheduledResizeFrame);
        }
        if (this.scrollElement) {
            this.scrollElement.removeEventListener('scroll', this.handleReposition);
        }
    };
    Popup.prototype.renderPopup = function () {
        var position = this.state.position;
        return (React.createElement("div", { ref: this.handleRef, style: tslib_1.__assign({ position: 'absolute', zIndex: styles_1.akEditorFloatingPanelZIndex }, position), "aria-label": this.props.ariaLabel || 'Popup' }, this.props.children));
    };
    Popup.prototype.render = function () {
        if (!this.props.target) {
            return null;
        }
        if (this.props.mountTo) {
            return React.createElement(Portal_1.default, { mountTo: this.props.mountTo }, this.renderPopup());
        }
        // Without mountTo property renders popup as is,
        // which means it will be croped by "overflow: hidden" container.
        return this.renderPopup();
    };
    Popup.defaultProps = {
        offset: [0, 0],
        boundariesElement: document.body,
    };
    return Popup;
}(react_1.PureComponent));
exports.default = Popup;
//# sourceMappingURL=index.js.map