"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Rusha = require("rusha");
var WorkerHasher = /** @class */ (function () {
    function WorkerHasher(numOfWorkers) {
        this.workers = [];
        this.jobs = {};
        for (var i = 0; i < numOfWorkers; ++i) {
            this.workers.push(this.createWorker());
        }
    }
    WorkerHasher.prototype.hash = function (chunk) {
        this.calculateHashInWorker(chunk);
    };
    WorkerHasher.prototype.createWorker = function () {
        var _this = this;
        var worker = Rusha.createWorker();
        var hasherWorker = { worker: worker, activeJobs: 0 };
        worker.addEventListener('message', function (event) {
            _this.handleWorkerMessage(event, hasherWorker);
        });
        return hasherWorker;
    };
    WorkerHasher.prototype.handleWorkerMessage = function (event, hasherWorker) {
        var id = event.data.id;
        var chunk = this.jobs[id];
        if (chunk) {
            delete this.jobs[id];
            hasherWorker.activeJobs--;
            if (event.data.error) {
                this.calculateHashInWorker(chunk);
            }
            else {
                chunk.hash = event.data.hash;
                chunk.preprocessFinished();
            }
        }
    };
    WorkerHasher.prototype.calculateHashInWorker = function (chunk) {
        var file = chunk.fileObj.file;
        var chunkBlob = file.slice(chunk.startByte, chunk.endByte);
        var jobId = chunk.fileObj.fileName + chunk.fileObjSize + chunk.startByte;
        this.jobs[jobId] = chunk;
        var worker = this.getWorker();
        this.dispatch(jobId, worker, chunkBlob);
    };
    WorkerHasher.prototype.dispatch = function (jobId, hasherWorker, chunkBlob) {
        hasherWorker.activeJobs++;
        var worker = hasherWorker.worker;
        /*
         * postMessage() with chunk blob in Safari results in the error
         * "Failed to load resource: The operation couldnâ€™t be completed. (WebKitBlobResource error 1.)"
         *
         * To prevent it, we read the data from the blob using FileReader and pass it via postMessage to the worker.
         */
        if (navigator.userAgent.indexOf('Safari') > -1 &&
            navigator.userAgent.indexOf('Chrome') === -1) {
            var rd_1 = new FileReader();
            rd_1.onload = function () {
                worker.postMessage({ id: jobId, data: rd_1.result });
            };
            rd_1.readAsBinaryString(chunkBlob);
            return;
        }
        worker.postMessage({ id: jobId, data: chunkBlob });
    };
    WorkerHasher.prototype.getWorker = function () {
        // Pick the worker with least number of active jobs
        return this.workers.reduce(function (current, next) {
            if (next.activeJobs < current.activeJobs) {
                return next;
            }
            return current;
        }, this.workers[0]);
    };
    return WorkerHasher;
}());
exports.WorkerHasher = WorkerHasher;
//# sourceMappingURL=workerHasher.js.map