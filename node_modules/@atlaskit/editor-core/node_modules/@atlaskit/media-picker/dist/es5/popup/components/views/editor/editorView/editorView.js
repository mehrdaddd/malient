"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var react_1 = require("react");
var react_redux_1 = require("react-redux");
var media_editor_1 = require("@atlaskit/media-editor");
var toolbar_1 = require("./toolbar/toolbar");
var phrases_1 = require("../phrases");
var styles_1 = require("./styles");
var DEFAULT_WIDTH = 845;
var DEFAULT_HEIGHT = 530;
var TRANSPARENT_COLOR = { red: 0, green: 0, blue: 0, alpha: 0 };
// Properties' names in the local storage
var propertyColor = 'media-editor-color';
var propertyTool = 'media-editor-tool';
var propertyLineWidth = 'media-editor-line-width';
var EditorView = /** @class */ (function (_super) {
    tslib_1.__extends(EditorView, _super);
    function EditorView(props) {
        var _this = _super.call(this, props) || this;
        _this.onLoad = function (url, loadParameters) {
            _this.loadParameters = loadParameters;
        };
        _this.onError = function (error) {
            _this.props.onError(phrases_1.couldNotLoadEditor);
        };
        _this.onSave = function () {
            var imageGetter = _this.loadParameters.imageGetter;
            var image = imageGetter();
            if (image.isExported && image.content) {
                _this.props.onSave(image.content);
            }
            else {
                _this.props.onError(phrases_1.couldNotSaveImage);
            }
        };
        _this.state = {
            dimensions: { width: DEFAULT_WIDTH, height: DEFAULT_HEIGHT },
            color: { red: 0xbf, green: 0x26, blue: 0x00 },
            lineWidth: 10,
            tool: 'arrow',
        };
        return _this;
    }
    EditorView.prototype.componentDidMount = function () {
        var rect = this.rootDiv.getBoundingClientRect();
        var dimensions = {
            width: rect.width || DEFAULT_WIDTH,
            height: rect.height || DEFAULT_HEIGHT,
        };
        this.setState({ dimensions: dimensions });
        this.loadProperties();
    };
    EditorView.prototype.componentWillUnmount = function () {
        this.saveProperties();
    };
    EditorView.prototype.render = function () {
        var _this = this;
        var refHandler = function (div) {
            _this.rootDiv = div;
        };
        return (React.createElement(styles_1.EditorContainer, { innerRef: refHandler },
            this.renderEditor(),
            this.renderToolbar()));
    };
    EditorView.prototype.renderEditor = function () {
        var _this = this;
        var onError = function (url, error) { return _this.onError(error); };
        var onShapeParametersChanged = function (_a) {
            var color = _a.color, lineWidth = _a.lineWidth;
            _this.setState({ color: color, lineWidth: lineWidth });
        };
        var imageUrl = this.props.imageUrl;
        var _a = this.state, dimensions = _a.dimensions, color = _a.color, lineWidth = _a.lineWidth, tool = _a.tool;
        return (React.createElement(media_editor_1.MediaEditor, { imageUrl: imageUrl, dimensions: dimensions, backgroundColor: TRANSPARENT_COLOR, shapeParameters: { color: color, lineWidth: lineWidth, addShadow: true }, tool: tool, onLoad: this.onLoad, onError: onError, onShapeParametersChanged: onShapeParametersChanged }));
    };
    EditorView.prototype.renderToolbar = function () {
        var _this = this;
        var _a = this.state, tool = _a.tool, color = _a.color, lineWidth = _a.lineWidth;
        var onToolChanged = function (tool) { return _this.setState({ tool: tool }); };
        var onColorChanged = function (color) { return _this.setState({ color: color }); };
        var onLineWidthChanged = function (lineWidth) {
            return _this.setState({ lineWidth: lineWidth });
        };
        var onCancel = function () { return _this.props.onCancel(); };
        return (React.createElement(toolbar_1.Toolbar, { tool: tool, color: color, lineWidth: lineWidth, onToolChanged: onToolChanged, onColorChanged: onColorChanged, onLineWidthChanged: onLineWidthChanged, onSave: this.onSave, onCancel: onCancel }));
    };
    // Using local storage to save and load shape properties
    EditorView.prototype.saveProperties = function () {
        var _a = this.state, tool = _a.tool, color = _a.color, lineWidth = _a.lineWidth;
        try {
            localStorage.setItem(propertyColor, JSON.stringify(color));
            localStorage.setItem(propertyTool, tool);
            localStorage.setItem(propertyLineWidth, lineWidth.toString());
        }
        catch (error) {
            // tslint:disable-next-line:no-console
            console.warn("Failed to save properties for MediaEditor: " + color + " " + tool + " " + lineWidth);
        }
    };
    EditorView.prototype.loadProperties = function () {
        var color = localStorage.getItem(propertyColor);
        if (color) {
            try {
                this.setState({
                    color: JSON.parse(color),
                });
            }
            catch (error) {
                // tslint:disable-next-line:no-console
                console.warn("Failed to parse color property for MediaEditor: " + color);
            }
        }
        var tool = localStorage.getItem(propertyTool);
        if (tool && isTool(tool)) {
            this.setState({
                tool: tool,
            });
        }
        var lineWidth = localStorage.getItem(propertyLineWidth);
        if (lineWidth) {
            this.setState({
                lineWidth: parseInt(lineWidth, 10),
            });
        }
    };
    return EditorView;
}(react_1.Component));
exports.EditorView = EditorView;
function isTool(value) {
    return toolbar_1.tools.some(function (tool) { return tool === value; });
}
exports.default = react_redux_1.connect(function (_a) {
    var editorData = _a.editorData;
    return ({
        imageUrl: editorData ? editorData.imageUrl || '' : '',
    });
})(EditorView);
//# sourceMappingURL=editorView.js.map