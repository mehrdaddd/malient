import * as tslib_1 from "tslib";
import axios from 'axios';
import * as url from 'url';
import { getPreviewFromBlob } from '../../../util/getPreviewFromBlob';
import { mapAuthToAuthHeaders } from '../../domain/auth';
var METADATA_POLL_INTERVAL_MS = 2000;
var NON_IMAGE_PREVIEW_WIDTH = 640;
var NON_IMAGE_PREVIEW_HEIGHT = 480;
var MAX_IMAGE_PREVIEW_SIZE = 4096; // This is needed to retrieve the max image dimensions even if the image is smaller/bigger to let Api know that we want the original size.
var MediaApiFetcher = /** @class */ (function () {
    function MediaApiFetcher() {
        var _this = this;
        this.fetchTrendingGifs = function (offset) {
            var baseUrl = 'https://api.giphy.com/v1/gifs/trending';
            var requestConfig = {
                url: "" + baseUrl,
                params: {
                    // TODO Move these keys somewhere in config MSW-406
                    api_key: 'lBOxhhz1BM62Y3JsK0iQv1pRYyOGUjR8',
                    rating: 'pg',
                    offset: offset,
                },
            };
            return axios
                .request(requestConfig)
                .then(function (response) { return _this.mapGiphyResponseToViewModel(response.data); });
        };
        this.fetchGifsRelevantToSearch = function (query, offset) {
            var baseUrl = 'https://api.giphy.com/v1/gifs/search';
            var requestConfig = {
                url: "" + baseUrl,
                params: {
                    api_key: 'lBOxhhz1BM62Y3JsK0iQv1pRYyOGUjR8',
                    rating: 'pg',
                    q: query,
                    offset: offset,
                },
            };
            return axios
                .request(requestConfig)
                .then(function (response) { return _this.mapGiphyResponseToViewModel(response.data); });
        };
        this.mapGiphyResponseToViewModel = function (response) {
            var data = response.data, pagination = response.pagination;
            var cardModels = data.map(function (gif) {
                var id = gif.id, slug = gif.slug;
                var _a = gif.images.fixed_width, size = _a.size, url = _a.url, width = _a.width, height = _a.height;
                var name = slug.replace(new RegExp("-" + id), '');
                var metadata = {
                    id: id,
                    name: name,
                    mediaType: 'image',
                    size: parseInt(size, 10),
                };
                return {
                    metadata: metadata,
                    dataURI: url,
                    dimensions: {
                        width: parseInt(width, 10),
                        height: parseInt(height, 10),
                    },
                };
            });
            return {
                cardModels: cardModels,
                totalResultCount: pagination.total_count,
            };
        };
    }
    MediaApiFetcher.prototype.fetchCloudAccountFolder = function (apiUrl, auth, serviceName, accountId, folderId, cursor) {
        var _this = this;
        return this.query(this.pickerUrl(apiUrl) + "/service/" + serviceName + "/" + accountId + "/folder", 'GET', {
            folderId: folderId,
            limit: 100,
            cursor: cursor,
        }, mapAuthToAuthHeaders(auth)).then(function (_a) {
            var serviceFolder = _a.data;
            if (serviceName === 'dropbox') {
                return tslib_1.__assign({}, serviceFolder, { items: _this.sortDropboxFiles(serviceFolder.items) });
            }
            else {
                return serviceFolder;
            }
        });
    };
    MediaApiFetcher.prototype.pollFile = function (apiUrl, auth, fileId, collection) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            return _this.query(_this.fileStoreUrl(apiUrl) + "/file/" + fileId, 'GET', {
                collection: collection,
            }, mapAuthToAuthHeaders(auth))
                .then(function (_a) {
                var file = _a.data;
                if (file.processingStatus === 'succeeded' ||
                    file.processingStatus === 'failed') {
                    resolve(file);
                }
                else {
                    setTimeout(function () {
                        _this.pollFile(apiUrl, auth, fileId, collection).then(resolve, reject);
                    }, METADATA_POLL_INTERVAL_MS);
                }
            })
                .catch(function (error) {
                // this._handleUploadError('metadata_fetch_fail', JSON.stringify(err));
                reject('metadata_fetch_fail');
            });
        });
    };
    MediaApiFetcher.prototype.getPreview = function (apiUrl, auth, fileId, collection) {
        var _this = this;
        return this.pollFile(apiUrl, auth, fileId, collection).then(function (file) {
            if (file.processingStatus === 'failed') {
                return Promise.reject('get_preview_failed');
            }
            var isImage = file.mediaType === 'image';
            var width = isImage ? MAX_IMAGE_PREVIEW_SIZE : NON_IMAGE_PREVIEW_WIDTH;
            var height = isImage
                ? MAX_IMAGE_PREVIEW_SIZE
                : NON_IMAGE_PREVIEW_HEIGHT;
            return _this.query(_this.fileStoreUrl(apiUrl) + "/file/" + fileId + "/image", 'GET', {
                width: width,
                height: height,
                collection: collection,
            }, mapAuthToAuthHeaders(auth), 'blob').then(function (blob) { return getPreviewFromBlob(blob, file.mediaType); });
        });
    };
    MediaApiFetcher.prototype.getImage = function (apiUrl, auth, fileId, collection) {
        var collectionName = collection ? "?collection=" + collection : '';
        var url = this.fileStoreUrl(apiUrl) + "/file/" + fileId + "/image" + collectionName;
        return this.query(url, 'GET', { mode: 'full-fit' }, mapAuthToAuthHeaders(auth), 'blob');
    };
    MediaApiFetcher.prototype.getServiceList = function (apiUrl, auth) {
        return this.query(this.pickerUrl(apiUrl) + "/accounts", 'GET', {}, mapAuthToAuthHeaders(auth)).then(function (_a) {
            var services = _a.data;
            return flattenAccounts(services);
        });
    };
    MediaApiFetcher.prototype.getRecentFiles = function (apiUrl, auth, limit, sortDirection, inclusiveStartKey) {
        return this.query(this.fileStoreUrl(apiUrl) + "/collection/recents/items", 'GET', {
            sortDirection: sortDirection,
            limit: limit,
            inclusiveStartKey: inclusiveStartKey,
        }, mapAuthToAuthHeaders(auth)).then(function (_a) {
            var data = _a.data;
            return data;
        });
    };
    MediaApiFetcher.prototype.unlinkCloudAccount = function (apiUrl, auth, accountId) {
        return this.query(this.pickerUrl(apiUrl) + "/account/" + accountId, 'DELETE', {}, mapAuthToAuthHeaders(auth));
    };
    MediaApiFetcher.prototype.copyFile = function (apiUrl, sourceFile, _a) {
        var auth = _a.auth, collection = _a.collection;
        var params = collection ? "?collection=" + collection : '';
        return this.query(this.fileStoreUrl(apiUrl) + "/file/copy/withToken" + params, 'POST', JSON.stringify({ sourceFile: sourceFile }), mapAuthToAuthHeaders(auth)).then(function (_a) {
            var file = _a.data;
            return file;
        });
    };
    MediaApiFetcher.prototype.parsePayload = function (method, payload) {
        if (method === 'GET') {
            return { params: payload };
        }
        else {
            return { data: payload };
        }
    };
    MediaApiFetcher.prototype.query = function (url, method, payload, authHeaders, responseType) {
        var contentType = 'application/json; charset=utf-8';
        var headers = tslib_1.__assign({}, authHeaders, { 'Content-Type': contentType });
        var _a = this.parsePayload(method, payload), data = _a.data, params = _a.params;
        var config = {
            url: url,
            method: method,
            headers: headers,
            data: data,
            params: params,
            contentType: contentType,
            responseType: responseType,
        };
        return axios.request(config).then(function (response) { return response.data; });
    };
    MediaApiFetcher.prototype.isFolder = function (item) {
        return item.mimeType === 'application/vnd.atlassian.mediapicker.folder';
    };
    MediaApiFetcher.prototype.sortDropboxFiles = function (items) {
        var _this = this;
        return items.sort(function (a, b) {
            var isAFolder = _this.isFolder(a);
            var isBFolder = _this.isFolder(b);
            if (!isAFolder && isBFolder) {
                return 1;
            }
            if (isAFolder && !isBFolder) {
                return -1;
            }
            var aName = a.name.toLowerCase();
            var bName = b.name.toLowerCase();
            if (aName > bName) {
                return 1;
            }
            else if (aName < bName) {
                return -1;
            }
            else {
                return 0;
            }
        });
    };
    MediaApiFetcher.prototype.fileStoreUrl = function (apiUrl) {
        var _a = url.parse(apiUrl), protocol = _a.protocol, host = _a.host;
        return protocol + "//" + host;
    };
    MediaApiFetcher.prototype.pickerUrl = function (apiUrl) {
        return this.fileStoreUrl(apiUrl) + "/picker";
    };
    return MediaApiFetcher;
}());
export { MediaApiFetcher };
export function flattenAccounts(services) {
    return services.reduce(function (accounts, service) {
        return accounts.concat(service.accounts.map(function (account) { return (tslib_1.__assign({}, account, { type: service.type })); }));
    }, new Array());
}
//# sourceMappingURL=fetcher.js.map