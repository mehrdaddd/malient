import * as tslib_1 from "tslib";
import * as React from 'react';
import { Component } from 'react';
import { connect } from 'react-redux';
import { Card, CardView, } from '@atlaskit/media-card';
import Spinner from '@atlaskit/spinner';
import Flag, { FlagGroup } from '@atlaskit/flag';
import AnnotateIcon from '@atlaskit/icon/glyph/media-services/annotate';
import EditorInfoIcon from '@atlaskit/icon/glyph/error';
import { isImage } from '../../../tools/isImage';
import { isWebGLAvailable } from '../../../tools/webgl';
import { Dropzone } from './dropzone';
import { fileClick } from '../../../actions/fileClick';
import { editorShowImage } from '../../../actions/editorShowImage';
import { editRemoteImage } from '../../../actions/editRemoteImage';
import { menuEdit } from '../editor/phrases';
import { Wrapper, SpinnerWrapper, CardsWrapper, RecentUploadsTitle, CardWrapper, } from './styled';
var createEditCardAction = function (handler) {
    return {
        label: menuEdit,
        handler: handler,
        icon: React.createElement(AnnotateIcon, { label: menuEdit, size: "small" }),
    };
};
var cardDimension = { width: 162, height: 108 };
var StatelessUploadView = /** @class */ (function (_super) {
    tslib_1.__extends(StatelessUploadView, _super);
    function StatelessUploadView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            imageIds: [],
            hasPopupBeenVisible: false,
            isWebGLWarningFlagVisible: false,
            shouldDismissWebGLWarningFlag: false,
        };
        _this.loadingView = function () {
            return (React.createElement(SpinnerWrapper, null,
                React.createElement(Spinner, { size: "large" })));
        };
        _this.renderWebGLWarningFlag = function () { return (React.createElement(FlagGroup, { onDismissed: _this.onFlagDismissed },
            React.createElement(Flag, { shouldDismiss: _this.state.shouldDismissWebGLWarningFlag, description: "Your browser does not support WebGL. Use a WebGL enabled browser to annotate images.", icon: React.createElement(EditorInfoIcon, { label: "info" }), id: "webgl-warning-flag", title: "You're unable to annotate this image", actions: [{ content: 'Learn More', onClick: _this.onLearnMoreClicked }] }))); };
        _this.onCardLoadingChanged = function (cardLoadingState) {
            var payload = cardLoadingState.payload;
            var type = cardLoadingState.type;
            if (type === 'complete' && payload && payload.mediaType === 'image') {
                var imageIds = _this.state.imageIds.concat(payload.id);
                _this.setState({ imageIds: imageIds });
            }
        };
        _this.onFlagDismissed = function () {
            _this.setState({ isWebGLWarningFlagVisible: false });
        };
        _this.onLearnMoreClicked = function () {
            _this.setState({ shouldDismissWebGLWarningFlag: true });
            _this.onFlagDismissed();
            window.open('https://get.webgl.org/');
        };
        return _this;
    }
    StatelessUploadView.prototype.render = function () {
        var isLoading = this.props.isLoading;
        var cards = this.renderCards();
        var isEmpty = !isLoading && cards.length === 0;
        var contentPart = null;
        if (isLoading) {
            contentPart = this.loadingView();
        }
        else if (!isEmpty) {
            contentPart = this.recentView(cards);
        }
        return (React.createElement(Wrapper, null,
            React.createElement(Dropzone, { isEmpty: isEmpty, mpBrowser: this.props.mpBrowser }),
            contentPart));
    };
    StatelessUploadView.prototype.recentView = function (cards) {
        return (React.createElement("div", null,
            React.createElement(RecentUploadsTitle, null, "Recent Uploads"),
            React.createElement(CardsWrapper, null, cards),
            this.state.isWebGLWarningFlagVisible
                ? this.renderWebGLWarningFlag()
                : null));
    };
    StatelessUploadView.prototype.onAnnotateActionClick = function (callback) {
        var _this = this;
        return function () {
            if (isWebGLAvailable()) {
                callback();
            }
            else {
                _this.showWebGLWarningFlag();
            }
        };
    };
    StatelessUploadView.prototype.renderCards = function () {
        var recentFilesCards = this.recentFilesCards();
        var uploadingFilesCards = this.uploadingFilesCards();
        return uploadingFilesCards
            .concat(recentFilesCards)
            .map(function (_a) {
            var key = _a.key, card = _a.el;
            return React.createElement(CardWrapper, { key: key }, card);
        });
    };
    StatelessUploadView.prototype.uploadingFilesCards = function () {
        var _this = this;
        var _a = this.props, uploads = _a.uploads, onFileClick = _a.onFileClick, onEditorShowImage = _a.onEditorShowImage;
        var itemsKeys = Object.keys(uploads);
        itemsKeys.sort(function (a, b) {
            return uploads[b].index - uploads[a].index;
        });
        var selectedUploadIds = this.props.selectedItems
            .filter(function (item) { return item.serviceName === 'upload'; })
            .map(function (item) { return item.id; });
        return itemsKeys.map(function (key) {
            var item = _this.props.uploads[key];
            var progress = item.progress, file = item.file;
            var dataURI = file.dataURI;
            var mediaType = isImage(file.metadata.mimeType) ? 'image' : 'unknown';
            var fileMetadata = tslib_1.__assign({}, file.metadata, { mimeType: mediaType });
            // mimeType
            var id = fileMetadata.id;
            var selected = selectedUploadIds.indexOf(id) > -1;
            var status = progress !== null ? 'uploading' : 'complete';
            var onClick = function () { return onFileClick(fileMetadata, 'upload'); };
            var actions = [];
            if (mediaType === 'image' && dataURI) {
                actions.push(createEditCardAction(_this.onAnnotateActionClick(function () {
                    return onEditorShowImage(fileMetadata, dataURI);
                })));
            }
            var metadata = tslib_1.__assign({}, file.metadata, { mediaType: mediaType });
            return {
                key: id,
                el: (React.createElement(CardView, { status: status, progress: progress || undefined, mediaItemType: 'file', metadata: metadata, dimensions: cardDimension, selectable: true, selected: selected, dataURI: dataURI, onClick: onClick, actions: actions })),
            };
        });
    };
    StatelessUploadView.prototype.recentFilesCards = function () {
        var _this = this;
        var _a = this.props, context = _a.context, recents = _a.recents, recentsCollection = _a.recentsCollection, selectedItems = _a.selectedItems, onFileClick = _a.onFileClick, onEditRemoteImage = _a.onEditRemoteImage;
        var items = recents.items;
        var selectedRecentFiles = selectedItems
            .filter(function (item) { return item.serviceName === 'recent_files'; })
            .map(function (item) { return item.id; });
        var onClick = function (_a) {
            var mediaItemDetails = _a.mediaItemDetails;
            var fileDetails = mediaItemDetails;
            if (fileDetails) {
                onFileClick({
                    id: fileDetails.id,
                    name: fileDetails.name || '',
                    mimeType: fileDetails.mimeType || '',
                    size: fileDetails.size || 0,
                }, 'recent_files');
            }
        };
        var onLoadingChange = this.onCardLoadingChanged;
        var editHandler = function (mediaItem) {
            if (mediaItem.type === 'file') {
                var _a = mediaItem.details, id = _a.id, name_1 = _a.name;
                if (isWebGLAvailable()) {
                    onEditRemoteImage({
                        id: id,
                        name: name_1 || '',
                    }, recentsCollection);
                }
                else {
                    // WebGL not available - show warning flag
                    _this.showWebGLWarningFlag();
                }
            }
        };
        return items.map(function (item) {
            var id = item.id, occurrenceKey = item.occurrenceKey;
            var selected = selectedRecentFiles.indexOf(id) > -1;
            var actions = [];
            if (_this.state.imageIds.indexOf(id) > -1) {
                actions.push(createEditCardAction(editHandler));
            }
            return {
                key: occurrenceKey + "-" + id,
                el: (React.createElement(Card, { context: context, identifier: {
                        mediaItemType: 'file',
                        id: id,
                        collectionName: recentsCollection,
                    }, dimensions: cardDimension, selectable: true, selected: selected, onClick: onClick, actions: actions, onLoadingChange: onLoadingChange })),
            };
        });
    };
    StatelessUploadView.prototype.showWebGLWarningFlag = function () {
        this.setState({ isWebGLWarningFlagVisible: true });
    };
    return StatelessUploadView;
}(Component));
export { StatelessUploadView };
var mapStateToProps = function (state) { return ({
    isLoading: state.view.isLoading,
    recents: state.recents,
    uploads: state.uploads,
    selectedItems: state.selectedItems,
    apiUrl: state.apiUrl,
}); };
var mapDispatchToProps = function (dispatch) { return ({
    onFileClick: function (_a, serviceName) {
        var id = _a.id, mimeType = _a.mimeType, name = _a.name, size = _a.size;
        return dispatch(fileClick({
            date: 0,
            id: id,
            mimeType: mimeType,
            name: name,
            size: size,
        }, serviceName));
    },
    onEditorShowImage: function (file, dataUri) {
        return dispatch(editorShowImage(dataUri, file));
    },
    onEditRemoteImage: function (file, collectionName) {
        return dispatch(editRemoteImage(file, collectionName));
    },
}); };
export default connect(mapStateToProps, mapDispatchToProps)(StatelessUploadView);
//# sourceMappingURL=upload.js.map