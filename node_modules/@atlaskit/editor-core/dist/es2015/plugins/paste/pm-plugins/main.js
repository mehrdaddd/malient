import { keymap } from 'prosemirror-keymap';
import { Slice } from 'prosemirror-model';
import { Plugin, PluginKey, TextSelection, } from 'prosemirror-state';
import * as MarkdownIt from 'markdown-it';
import { MarkdownTransformer } from '@atlaskit/editor-markdown-transformer';
import { analyticsService } from '../../../analytics';
import * as keymaps from '../../../keymaps';
import * as clipboard from '../../../utils/clipboard';
import { stateKey as tableStateKey } from '../../table/pm-plugins/main';
import { containsTable } from '../../table/utils';
import { runMacroAutoConvert } from '../../macro';
import { insertMediaAsMediaSingle } from '../../media/utils/media-single';
import linkify from '../linkify-md-plugin';
import { isSingleLine, escapeLinks } from '../util';
import { removeBodiedExtensionsIfSelectionIsInBodiedExtension, removeBodiedExtensionWrapper, } from '../../extension/actions';
import { removeLayoutsIfSelectionIsInLayout, transformSliceToRemoveOpenLayoutNodes, } from '../../layout/utils';
import { linkifyContent } from '../../hyperlink/utils';
import { hasOpenEnd } from '../../../utils';
import { closeHistory } from 'prosemirror-history';
export var stateKey = new PluginKey('pastePlugin');
export function createPlugin(schema, editorAppearance) {
    var atlassianMarkDownParser;
    var md = MarkdownIt('zero', { html: false });
    md.enable([
        // Process html entity - &#123;, &#xAF;, &quot;, ...
        'entity',
        // Process escaped chars and hardbreaks
        'escape',
    ]);
    // enable modified version of linkify plugin
    // @see https://product-fabric.atlassian.net/browse/ED-3097
    md.use(linkify);
    atlassianMarkDownParser = new MarkdownTransformer(schema, md);
    return new Plugin({
        key: stateKey,
        props: {
            handlePaste: function (view, event, slice) {
                if (!event.clipboardData) {
                    return false;
                }
                // Bail if copied content has files
                if (clipboard.isPastedFile(event)) {
                    return true;
                }
                slice = removeLayoutsIfSelectionIsInLayout(slice, view.state);
                // currently bodiedExtension -> bodiedExtension nesting is restricted in schema, but PM does wraps nested bodiedExtension node with a table to workaround the restriction.
                // that allows us to have infinite nesting: bodiedExtension -> table -> bodiedExtension
                // this function makes sure we prevent that weirdness
                slice = removeBodiedExtensionsIfSelectionIsInBodiedExtension(slice, view.state);
                var _a = view.state.selection, $to = _a.$to, $from = _a.$from;
                // In case of SHIFT+CMD+V ("Paste and Match Style") we don't want to run the usual
                // fuzzy matching of content. ProseMirror already handles this scenario and will
                // provide us with slice containing paragraphs with plain text, which we decorate
                // with "stored marks".
                // @see prosemirror-view/src/clipboard.js:parseFromClipboard()).
                // @see prosemirror-view/src/input.js:doPaste().
                if (view.shiftKey) {
                    // <- using the same internal flag that prosemirror-view is using
                    analyticsService.trackEvent('atlassian.editor.paste.alt');
                    var tr_1 = closeHistory(view.state.tr);
                    tr_1.replaceSelection(slice);
                    var storedMarks = view.state.storedMarks;
                    if (storedMarks && storedMarks.length) {
                        storedMarks.forEach(function (mark) {
                            return (tr_1 = tr_1.addMark($from.pos, $from.pos + slice.size, mark));
                        });
                    }
                    view.dispatch(tr_1.scrollIntoView());
                    return true;
                }
                var text = event.clipboardData.getData('text/plain');
                var html = event.clipboardData.getData('text/html');
                var node = slice.content.firstChild;
                // runs macro autoconvert prior to other conversions
                if (text && !html) {
                    var macro = runMacroAutoConvert(view.state, text);
                    if (macro) {
                        view.dispatch(closeHistory(view.state.tr)
                            .replaceSelectionWith(macro)
                            .scrollIntoView());
                        return true;
                    }
                }
                var schema = view.state.schema;
                var selectedNode = $from.node($from.depth);
                // If we're in a code block, append the text contents of clipboard inside it
                if (text && selectedNode.type === schema.nodes.codeBlock) {
                    view.dispatch(closeHistory(view.state.tr).insertText(text));
                    return true;
                }
                /** If a partial paste of bodied extension, paste only text */
                if (node &&
                    node.type === schema.nodes.bodiedExtension &&
                    hasOpenEnd(slice)) {
                    slice = removeBodiedExtensionWrapper(view.state, slice);
                }
                if (editorAppearance !== 'message' &&
                    node &&
                    node.type === schema.nodes.media) {
                    return insertMediaAsMediaSingle(view, node);
                }
                // If the clipboard contents looks like computer code, create a code block
                // Note: Disabling (text && isCode(text)) check (@see ED-4092) until we decide how to improve it (possibly adding the ability to undo)
                if (text && html && node && node.type === schema.nodes.codeBlock) {
                    analyticsService.trackEvent('atlassian.editor.paste.code');
                    var tr = closeHistory(view.state.tr);
                    if (isSingleLine(text)) {
                        var currentNode = $to.node($to.depth);
                        var nodeText = currentNode && currentNode.textContent;
                        var from = $from.pos;
                        if (nodeText && nodeText[nodeText.length - 1] === '`') {
                            tr = tr.delete($to.pos - 1, $to.pos);
                            from -= 1;
                        }
                        tr = tr.insertText(text);
                        tr = tr.addMark(from, $from.pos + text.length, schema.marks.code.create());
                        var code_1 = view.state.schema.marks.code;
                        // ED-4299, if a new code mark is created by pasting cursor should be moved out of it.
                        if (!$to.marks().some(function (mark) { return mark.type === code_1; })) {
                            tr = tr.removeStoredMark(code_1);
                        }
                    }
                    else {
                        var codeBlockNode = schema.nodes.codeBlock.create(node ? node.attrs : {}, schema.text(text));
                        tr = tr.replaceSelectionWith(codeBlockNode);
                        // ED-4299, If code-block is created at end of its parent a paragraph is added after it.
                        // Selection is moved position after pasted code.
                        if ($to.pos + 1 === $to.end($to.depth - 1)) {
                            var paragraph = view.state.schema.nodes.paragraph;
                            var newSel = tr.selection.$to;
                            tr = tr.insert(newSel.end(newSel.depth - 1), paragraph.createAndFill());
                        }
                        tr = tr.setSelection(new TextSelection(tr.doc.resolve($to.pos + codeBlockNode.nodeSize)));
                    }
                    view.dispatch(tr.scrollIntoView());
                    return true;
                }
                // If the clipboard only contains plain text, attempt to parse it as Markdown
                if (text && !html && atlassianMarkDownParser) {
                    analyticsService.trackEvent('atlassian.editor.paste.markdown');
                    var doc = atlassianMarkDownParser.parse(escapeLinks(text));
                    if (doc && doc.content) {
                        var tr = closeHistory(view.state.tr);
                        tr.replaceSelection(new Slice(doc.content, slice.openStart, slice.openEnd));
                        view.dispatch(tr.scrollIntoView());
                        return true;
                    }
                }
                // If the clipboard contains rich text, pass it through the schema and import what's allowed.
                if (html) {
                    var tableState = tableStateKey.getState(view.state);
                    if (tableState &&
                        tableState.isRequiredToAddHeader() &&
                        containsTable(view.state, slice)) {
                        var selectionStart = view.state.selection.$from.pos;
                        view.dispatch(closeHistory(view.state.tr).replaceSelection(slice));
                        tableState.addHeaderToTableNodes(slice, selectionStart);
                        return true;
                    }
                    slice = linkifyContent(view.state.schema, slice) || slice;
                    view.dispatch(closeHistory(view.state.tr)
                        .replaceSelection(slice)
                        .setStoredMarks([]));
                    return true;
                }
                return false;
            },
            transformPasted: function (slice) {
                // We do this separately so it also applies to drag/drop events
                slice = transformSliceToRemoveOpenLayoutNodes(slice, schema);
                return slice;
            },
        },
    });
}
export function createKeymapPlugin(schema) {
    var list = {};
    keymaps.bindKeymapWithCommand(keymaps.paste.common, function (state, dispatch) {
        analyticsService.trackEvent('atlassian.editor.paste');
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.altPaste.common, function (state, dispatch) {
        analyticsService.trackEvent('atlassian.editor.paste');
        return false;
    }, list);
    return keymap(list);
}
export default function (schema, editorAppearance) { return [
    createPlugin(schema, editorAppearance),
    createKeymapPlugin(schema),
]; };
//# sourceMappingURL=main.js.map