import * as tslib_1 from "tslib";
import * as React from 'react';
import { Component } from 'react';
import CrossIcon from '@atlaskit/icon/glyph/cross';
import { Card, CardView, } from '@atlaskit/media-card';
import { withImageLoader, } from '@atlaskit/editor-common';
import { isImage } from '../../../../utils';
// This is being used by DropPlaceholder now
export var MEDIA_HEIGHT = 125;
export var FILE_WIDTH = 156;
/**
 * Map media state status into CardView processing status
 * Media state status is more broad than CardView API so we need to reduce it
 */
function mapMediaStatusIntoCardStatus(state, progress) {
    switch (state.status) {
        case 'preview':
            return progress === 1 ? 'complete' : 'uploading';
        case 'ready':
        case 'unknown':
        case 'processing':
        // Happens after swap, @see `handleMediaStateChange` method below for more context
        case 'cancelled':
            return 'complete';
        case 'uploading':
            return 'uploading';
        // default case is to let TypeScript know that this function always returns a string
        case 'error':
        default:
            return 'error';
    }
}
var MediaComponentInternal = /** @class */ (function (_super) {
    tslib_1.__extends(MediaComponentInternal, _super);
    function MediaComponentInternal() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.destroyed = false;
        _this.state = {
            id: '',
            status: 'unknown',
        };
        _this.handleMediaStateChange = function (mediaState) {
            /**
             * `cancelled` gets triggered when we do the node swap, so we can ignore it here.
             * Because on real `canceled` event it will get removed anyways.
             */
            if (_this.destroyed || mediaState.status === 'cancelled') {
                return;
            }
            _this.setState(tslib_1.__assign({}, mediaState));
        };
        _this.handleMediaProvider = function (mediaProvider) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, id, tempId, stateManager, mediaState;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, id = _a.id, tempId = _a.tempId;
                        if (this.destroyed) {
                            return [2 /*return*/];
                        }
                        stateManager = mediaProvider.stateManager || this.props.stateManagerFallback;
                        this.setState({ mediaProvider: mediaProvider });
                        if (stateManager && id) {
                            mediaState = stateManager.getState(tempId || id);
                            stateManager.on(id, this.handleMediaStateChange);
                            this.setState(tslib_1.__assign({ id: id }, mediaState));
                        }
                        return [4 /*yield*/, this.setContext('viewContext', mediaProvider)];
                    case 1:
                        _b.sent();
                        return [4 /*yield*/, this.setContext('linkCreateContext', mediaProvider)];
                    case 2:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        }); };
        _this.setContext = function (contextName, mediaProvider) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var context, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, mediaProvider[contextName]];
                    case 1:
                        context = _b.sent();
                        if (this.destroyed || !context) {
                            return [2 /*return*/];
                        }
                        this.setState((_a = {}, _a[contextName] = context, _a));
                        return [2 /*return*/];
                }
            });
        }); };
        return _this;
    }
    MediaComponentInternal.prototype.componentWillMount = function () {
        var mediaProvider = this.props.mediaProvider;
        if (mediaProvider) {
            mediaProvider.then(this.handleMediaProvider);
        }
    };
    MediaComponentInternal.prototype.componentWillReceiveProps = function (nextProps) {
        var mediaProvider = nextProps.mediaProvider;
        if (this.props.mediaProvider !== mediaProvider) {
            if (mediaProvider) {
                mediaProvider.then(this.handleMediaProvider);
            }
            else {
                this.setState({ mediaProvider: mediaProvider });
            }
        }
    };
    MediaComponentInternal.prototype.componentWillUnmount = function () {
        this.destroyed = true;
        var id = this.props.id;
        var mediaProvider = this.state.mediaProvider;
        if (mediaProvider) {
            var stateManager = mediaProvider.stateManager;
            if (stateManager && id) {
                stateManager.off(id, this.handleMediaStateChange);
            }
        }
        var stateManagerFallback = this.props.stateManagerFallback;
        if (stateManagerFallback && id) {
            stateManagerFallback.off(id, this.handleMediaStateChange);
        }
    };
    MediaComponentInternal.prototype.render = function () {
        switch (this.props.type) {
            case 'file':
                return this.renderFile();
            case 'link':
                return this.renderLink();
            case 'external':
                return this.renderExternal();
            default:
                return null;
        }
    };
    MediaComponentInternal.prototype.renderLoadingCard = function (mediaItemType, url) {
        var cardDimensions = this.props.cardDimensions;
        return (React.createElement(CardView, { status: "loading", mediaItemType: mediaItemType, dimensions: cardDimensions }));
    };
    MediaComponentInternal.prototype.renderLink = function () {
        var _a = this.state, mediaProvider = _a.mediaProvider, linkCreateContext = _a.linkCreateContext;
        var _b = this.props, id = _b.id, collection = _b.collection, cardDimensions = _b.cardDimensions, onDelete = _b.onDelete, appearance = _b.appearance, disableOverlay = _b.disableOverlay, otherProps = tslib_1.__rest(_b, ["id", "collection", "cardDimensions", "onDelete", "appearance", "disableOverlay"]);
        var hasProviders = mediaProvider && linkCreateContext;
        if (!hasProviders || !id) {
            return this.renderLoadingCard('link');
        }
        var identifier = {
            mediaItemType: 'link',
            collectionName: collection,
            id: id,
        };
        if (id.substr(0, 10) === 'temporary:') {
            var url = id.substr(id.indexOf(':', 11) + 1);
            return this.renderLoadingCard('link', url);
        }
        if (onDelete) {
            otherProps.actions = [createDeleteAction(onDelete)];
        }
        return (React.createElement(Card, tslib_1.__assign({ context: linkCreateContext, dimensions: cardDimensions, identifier: identifier, appearance: appearance || 'horizontal', resizeMode: this.resizeMode, disableOverlay: disableOverlay }, otherProps)));
    };
    MediaComponentInternal.prototype.renderFile = function () {
        var _a = this.state, mediaProvider = _a.mediaProvider, viewContext = _a.viewContext, thumbnail = _a.thumbnail;
        var id = this.props.id;
        if (!mediaProvider || !viewContext || !id) {
            return this.renderLoadingCard('file');
        }
        if (id.substr(0, 10) === 'temporary:' || (thumbnail && thumbnail.src)) {
            return this.renderTemporaryFile();
        }
        else {
            return this.renderPublicFile();
        }
    };
    MediaComponentInternal.prototype.renderPublicFile = function () {
        var viewContext = this.state.viewContext;
        var _a = this.props, cardDimensions = _a.cardDimensions, collection = _a.collection, id = _a.id, onDelete = _a.onDelete, onClick = _a.onClick, selected = _a.selected, disableOverlay = _a.disableOverlay;
        var otherProps = {};
        if (onDelete) {
            otherProps.actions = [createDeleteAction(onDelete)];
        }
        if (onClick) {
            otherProps.onClick = onClick;
        }
        return (React.createElement(Card, tslib_1.__assign({ context: viewContext, dimensions: cardDimensions, identifier: {
                id: id,
                mediaItemType: 'file',
                collectionName: collection,
            }, selectable: true, selected: selected, resizeMode: this.resizeMode, disableOverlay: disableOverlay }, otherProps)));
    };
    MediaComponentInternal.prototype.renderTemporaryFile = function () {
        var _a = this.state, thumbnail = _a.thumbnail, fileName = _a.fileName, fileSize = _a.fileSize, fileMimeType = _a.fileMimeType, status = _a.status;
        var _b = this.props, onDelete = _b.onDelete, cardDimensions = _b.cardDimensions, appearance = _b.appearance, selected = _b.selected, resizeMode = _b.resizeMode, disableOverlay = _b.disableOverlay;
        // Cache the data url for thumbnail, so it's not regenerated on each re-render (prevents flicker)
        var dataURI;
        if (thumbnail) {
            dataURI = thumbnail.src;
        }
        // Make sure that we always display progress bar when the file is uploading (prevents flicker)
        var progress = this.state.progress;
        if (!progress && status === 'uploading') {
            progress = 0.0;
        }
        var isImageFile = isImage(fileMimeType);
        // Construct file details object
        var fileDetails = {
            name: fileName,
            size: fileSize,
            mimeType: fileMimeType,
            mediaType: thumbnail || isImageFile ? 'image' : 'unknown',
        };
        var otherProps = {};
        if (onDelete) {
            otherProps.actions = [createDeleteAction(onDelete)];
        }
        return (React.createElement(CardView
        // CardViewProps
        , tslib_1.__assign({ 
            // CardViewProps
            status: mapMediaStatusIntoCardStatus(this.state, progress), mediaItemType: "file", metadata: fileDetails, 
            // FileCardProps
            dataURI: dataURI, progress: progress, 
            // SharedCardProps
            dimensions: cardDimensions, appearance: appearance, selectable: true, selected: selected, resizeMode: resizeMode, disableOverlay: disableOverlay }, otherProps)));
    };
    MediaComponentInternal.prototype.renderExternal = function () {
        var _a = this.props, onDelete = _a.onDelete, cardDimensions = _a.cardDimensions, appearance = _a.appearance, selected = _a.selected, resizeMode = _a.resizeMode, imageStatus = _a.imageStatus, url = _a.url, disableOverlay = _a.disableOverlay;
        var otherProps = {};
        if (onDelete) {
            otherProps.actions = [createDeleteAction(onDelete)];
        }
        return (React.createElement(CardView, tslib_1.__assign({ status: imageStatus || 'loading', metadata: {
                mediaType: 'image',
                name: url,
            }, dataURI: url, dimensions: cardDimensions, appearance: appearance, selectable: true, selected: selected, resizeMode: resizeMode, disableOverlay: disableOverlay }, otherProps)));
    };
    Object.defineProperty(MediaComponentInternal.prototype, "resizeMode", {
        get: function () {
            var resizeMode = this.props.resizeMode;
            return resizeMode || 'full-fit';
        },
        enumerable: true,
        configurable: true
    });
    MediaComponentInternal.defaultProps = {
        selected: false,
    };
    return MediaComponentInternal;
}(Component));
export { MediaComponentInternal };
export var createDeleteAction = function (eventHander) {
    return {
        label: 'Delete',
        handler: eventHander,
        icon: React.createElement(CrossIcon, { size: "small", label: "delete" }),
    };
};
export default withImageLoader(MediaComponentInternal);
//# sourceMappingURL=MediaComponent.js.map