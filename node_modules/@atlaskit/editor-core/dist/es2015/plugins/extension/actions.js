import { NodeSelection, TextSelection, } from 'prosemirror-state';
import { Slice, Fragment } from 'prosemirror-model';
import { hasParentNodeOfType, removeSelectedNode, removeParentNodeOfType, selectParentNodeOfType, } from 'prosemirror-utils';
import { pluginKey } from './plugin';
import { insertMacroFromMacroBrowser } from '../macro';
import { getExtensionNode } from './utils';
export var setExtensionElement = function (element) { return function (state, dispatch) {
    var tr = state.tr.setMeta(pluginKey, { element: element });
    if (!element) {
        tr = tr.setSelection(TextSelection.create(state.doc, state.selection.$from.pos));
    }
    dispatch(tr);
    return true;
}; };
export var editExtension = function (macroProvider) { return function (view) {
    var state = view.state, dispatch = view.dispatch;
    // insert macro if there's macroProvider available
    if (macroProvider) {
        var node = getExtensionNode(state);
        if (node) {
            var bodiedExtension = state.schema.nodes.bodiedExtension;
            var tr = state.tr.setMeta(pluginKey, { element: null });
            if (hasParentNodeOfType(bodiedExtension)(tr.selection)) {
                dispatch(selectParentNodeOfType(bodiedExtension)(tr));
            }
            insertMacroFromMacroBrowser(macroProvider, node)(view);
            return true;
        }
    }
    return false;
}; };
export var removeExtension = function (state, dispatch) {
    var schema = state.schema, selection = state.selection;
    var tr = state.tr.setMeta(pluginKey, { element: null });
    if (selection instanceof NodeSelection) {
        tr = removeSelectedNode(tr);
    }
    else {
        tr = removeParentNodeOfType(schema.nodes.bodiedExtension)(tr);
    }
    dispatch(tr);
    return true;
};
export var removeBodiedExtensionWrapper = function (state, slice) {
    var bodiedExtension = state.schema.nodes.bodiedExtension;
    var wrapper = slice.content.firstChild;
    if (wrapper.type !== bodiedExtension || slice.content.childCount > 1) {
        return slice;
    }
    return new Slice(Fragment.from(wrapper.content), Math.max(0, slice.openStart - 1), Math.max(0, slice.openEnd - 1));
};
export var removeBodiedExtensionsIfSelectionIsInBodiedExtension = function (slice, state) {
    var selection = state.selection, bodiedExtension = state.schema.nodes.bodiedExtension;
    if (hasParentNodeOfType(bodiedExtension)(selection)) {
        var nodes_1 = [];
        slice.content.forEach(function (child) {
            if (child.type !== bodiedExtension) {
                nodes_1.push(child);
            }
        });
        return new Slice(Fragment.from(nodes_1), slice.openStart, slice.openEnd);
    }
    return slice;
};
//# sourceMappingURL=actions.js.map