import { findWrapping } from 'prosemirror-transform';
import { NodeSelection, Plugin, PluginKey, } from 'prosemirror-state';
import { findAncestorPosition } from '../../../utils';
import { toggleList } from '../commands';
import keymapPlugin from './keymap';
import inputRulePlugin from './input-rule';
/**
 *
 * Plugin State
 *
 */
var ListsState = /** @class */ (function () {
    function ListsState(state) {
        this.changeHandlers = [];
        // public state
        this.bulletListActive = false;
        this.bulletListDisabled = false;
        this.bulletListHidden = false;
        this.orderedListActive = false;
        this.orderedListDisabled = false;
        this.orderedListHidden = false;
        this.changeHandlers = [];
        // Checks what types of lists schema supports.
        var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList;
        this.bulletListHidden = !bulletList;
        this.orderedListHidden = !orderedList;
    }
    ListsState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    ListsState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    ListsState.prototype.toggleBulletList = function (view) {
        return toggleList(view.state, view.dispatch, view, 'bulletList');
    };
    ListsState.prototype.toggleOrderedList = function (view) {
        return toggleList(view.state, view.dispatch, view, 'orderedList');
    };
    ListsState.prototype.update = function (newEditorState) {
        var doc = newEditorState.doc, selection = newEditorState.selection;
        var ancestorPosition = findAncestorPosition(doc, selection.$from);
        var rootNode = selection instanceof NodeSelection
            ? selection.node
            : ancestorPosition.node(ancestorPosition.depth);
        var dirty = false;
        var newBulletListActive = rootNode.type === newEditorState.schema.nodes.bulletList;
        if (newBulletListActive !== this.bulletListActive) {
            this.bulletListActive = newBulletListActive;
            dirty = true;
        }
        var newOrderedListActive = rootNode.type === newEditorState.schema.nodes.orderedList;
        if (newOrderedListActive !== this.orderedListActive) {
            this.orderedListActive = newOrderedListActive;
            dirty = true;
        }
        var newBulletListDisabled = !(newBulletListActive ||
            newOrderedListActive ||
            this.isWrappingPossible(newEditorState.schema.nodes.bulletList, newEditorState));
        if (newBulletListDisabled !== this.bulletListDisabled) {
            this.bulletListDisabled = newBulletListDisabled;
            dirty = true;
        }
        var newOrderedListDisabled = !(newBulletListActive ||
            newOrderedListActive ||
            this.isWrappingPossible(newEditorState.schema.nodes.orderedList, newEditorState));
        if (newOrderedListDisabled !== this.orderedListDisabled) {
            this.orderedListDisabled = newOrderedListDisabled;
            dirty = true;
        }
        if (dirty) {
            this.triggerOnChange();
        }
    };
    ListsState.prototype.triggerOnChange = function () {
        var _this = this;
        this.changeHandlers.forEach(function (cb) { return cb(_this); });
    };
    ListsState.prototype.isWrappingPossible = function (nodeType, state) {
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        var range = $from.blockRange($to);
        if (!range) {
            return false;
        }
        var wrap = findWrapping(range, nodeType);
        if (!wrap) {
            return false;
        }
        return true;
    };
    return ListsState;
}());
export { ListsState };
export var stateKey = new PluginKey('listsPlugin');
export var plugin = new Plugin({
    state: {
        init: function (config, state) {
            return new ListsState(state);
        },
        apply: function (tr, pluginState, oldState, newState) {
            pluginState.update(newState);
            return pluginState;
        },
    },
    key: stateKey,
    view: function (view) {
        return {};
    },
});
var plugins = function (schema) {
    return [plugin, inputRulePlugin(schema), keymapPlugin(schema)].filter(function (plugin) { return !!plugin; });
};
export default plugins;
//# sourceMappingURL=main.js.map