import { Plugin, PluginKey } from 'prosemirror-state';
import { NORMAL_TEXT, HEADING_1, HEADING_2, HEADING_3, HEADING_4, HEADING_5, HEADING_6, BLOCK_QUOTE, CODE_BLOCK, PANEL, OTHER, } from '../types';
import * as commands from '../../../commands';
import { areBlockTypesDisabled } from '../../../utils';
/**
 *
 * Plugin State
 *
 */
var BlockTypeState = /** @class */ (function () {
    function BlockTypeState(state) {
        var _this = this;
        this.changeHandlers = [];
        // public state
        this.currentBlockType = NORMAL_TEXT;
        this.blockTypesDisabled = false;
        this.availableBlockTypes = [];
        this.availableWrapperBlockTypes = [];
        this.isCodeBlock = false;
        this.nodeBlockType = function (node) {
            if (node.type === _this.state.schema.nodes.heading) {
                switch (node.attrs['level']) {
                    case 1:
                        return HEADING_1;
                    case 2:
                        return HEADING_2;
                    case 3:
                        return HEADING_3;
                    case 4:
                        return HEADING_4;
                    case 5:
                        return HEADING_5;
                    case 6:
                        return HEADING_6;
                }
            }
            else if (node.type === _this.state.schema.nodes.paragraph) {
                return NORMAL_TEXT;
            }
            return OTHER;
        };
        this.isBlockTypeSchemaSupported = function (blockType) {
            var state = _this.state;
            switch (blockType) {
                case NORMAL_TEXT:
                    return !!state.schema.nodes.paragraph;
                case HEADING_1:
                case HEADING_2:
                case HEADING_3:
                case HEADING_4:
                case HEADING_5:
                case HEADING_6:
                    return !!state.schema.nodes.heading;
                case BLOCK_QUOTE:
                    return !!state.schema.nodes.blockquote;
                case CODE_BLOCK:
                    return !!state.schema.nodes.codeBlock;
                case PANEL:
                    return !!state.schema.nodes.panel;
            }
        };
        this.changeHandlers = [];
        this.state = state;
        this.availableBlockTypes = [
            NORMAL_TEXT,
            HEADING_1,
            HEADING_2,
            HEADING_3,
            HEADING_4,
            HEADING_5,
            HEADING_6,
        ].filter(this.isBlockTypeSchemaSupported);
        this.availableWrapperBlockTypes = [BLOCK_QUOTE, CODE_BLOCK, PANEL].filter(this.isBlockTypeSchemaSupported);
        this.update(state);
    }
    BlockTypeState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    BlockTypeState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    BlockTypeState.prototype.setBlockType = function (name, view) {
        return commands.setBlockType(view, name);
    };
    BlockTypeState.prototype.insertBlockType = function (name, view) {
        return commands.insertBlockType(name)(view.state, view.dispatch);
    };
    BlockTypeState.prototype.update = function (newEditorState, dirty) {
        if (dirty === void 0) { dirty = false; }
        this.state = newEditorState;
        var newBlockType = this.detectBlockType();
        if (newBlockType !== this.currentBlockType) {
            this.currentBlockType = newBlockType;
            dirty = true;
        }
        var newBlockTypesDisabled = areBlockTypesDisabled(this.state);
        if (newBlockTypesDisabled !== this.blockTypesDisabled) {
            this.blockTypesDisabled = newBlockTypesDisabled;
            dirty = true;
        }
        if (dirty) {
            this.triggerOnChange();
        }
    };
    BlockTypeState.prototype.triggerOnChange = function () {
        var _this = this;
        this.changeHandlers.forEach(function (cb) { return cb(_this); });
    };
    BlockTypeState.prototype.detectBlockType = function () {
        var _this = this;
        var state = this.state;
        // Before a document is loaded, there is no selection.
        if (!state.selection) {
            return NORMAL_TEXT;
        }
        var blockType;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        state.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {
            var nodeBlockType = _this.availableBlockTypes.filter(function (blockType) { return blockType === _this.nodeBlockType(node); });
            if (nodeBlockType.length > 0) {
                if (!blockType) {
                    blockType = nodeBlockType[0];
                }
                else if (blockType !== OTHER && blockType !== nodeBlockType[0]) {
                    blockType = OTHER;
                }
            }
        });
        return blockType || OTHER;
    };
    return BlockTypeState;
}());
export { BlockTypeState };
export var stateKey = new PluginKey('blockTypePlugin');
export var createPlugin = function (appearance) {
    return new Plugin({
        appendTransaction: function (transactions, oldState, newState) {
            if (appearance === 'comment') {
                var pos = newState.doc.resolve(newState.doc.content.size - 1);
                var lastNode = pos.node(1);
                var paragraph = newState.schema.nodes.paragraph;
                if (lastNode && lastNode.isBlock && lastNode.type !== paragraph) {
                    return newState.tr.insert(newState.doc.content.size, newState.schema.nodes.paragraph.create());
                }
            }
        },
        state: {
            init: function (config, state) {
                return new BlockTypeState(state);
            },
            apply: function (tr, pluginState, oldState, newState) {
                pluginState.update(newState);
                return pluginState;
            },
        },
        key: stateKey,
    });
};
//# sourceMappingURL=main.js.map