import { Selection, TextSelection, } from 'prosemirror-state';
import { removeNodeBefore } from 'prosemirror-utils';
import { GapCursorSelection } from './selection';
import { isIgnored } from './utils';
import { pluginKey } from './pm-plugins/main';
export var arrow = function (direction, endOfTextblock) { return function (state, dispatch) {
    var side = direction === 0 /* BACKWARD */ ? 1 /* LEFT */ : 0 /* RIGHT */;
    var selection = state.selection, tr = state.tr;
    var $pos = side === 0 /* RIGHT */ ? selection.$to : selection.$from;
    var mustMove = selection.empty;
    // start from text selection
    if (selection instanceof TextSelection) {
        if (!endOfTextblock(side === 0 /* RIGHT */ ? 'right' : 'left')) {
            return false;
        }
        mustMove = false;
        $pos = state.doc.resolve(side === 0 /* RIGHT */ ? $pos.after() : $pos.before());
    }
    var nextSelection;
    var nodeAfter = $pos.nodeAfter, nodeBefore = $pos.nodeBefore;
    // when jumping between block nodes at the same depth, we need to reverse cursor without changing ProseMirror position
    if (selection instanceof GapCursorSelection &&
        // next node allow gap cursor position
        (side === 0 /* RIGHT */
            ? nodeAfter && !isIgnored(nodeAfter)
            : nodeBefore && !isIgnored(nodeBefore)) &&
        // gap cursor changes block node
        ((side === 0 /* RIGHT */ && selection.side === 0 /* RIGHT */) ||
            (side === 1 /* LEFT */ && selection.side === 1 /* LEFT */))) {
        // reverse cursor position
        nextSelection = new GapCursorSelection($pos, side === 0 /* RIGHT */ ? 1 /* LEFT */ : 0 /* RIGHT */);
    }
    else {
        nextSelection = GapCursorSelection.findFrom($pos, direction === 0 /* BACKWARD */ ? -1 : 1, mustMove);
        if (!nextSelection) {
            return false;
        }
        var _a = nextSelection.$from, nodeBefore_1 = _a.nodeBefore, nodeAfter_1 = _a.nodeAfter;
        if (side === 0 /* RIGHT */
            ? !nodeBefore_1 || isIgnored(nodeBefore_1)
            : !nodeAfter_1 || isIgnored(nodeAfter_1)) {
            // reverse cursor position
            nextSelection = new GapCursorSelection(nextSelection.$from, side === 0 /* RIGHT */ ? 1 /* LEFT */ : 0 /* RIGHT */);
        }
    }
    dispatch(tr.setSelection(nextSelection).scrollIntoView());
    return true;
}; };
export var deleteNode = function (direction) { return function (state, dispatch) {
    if (state.selection instanceof GapCursorSelection) {
        var $from = state.selection.$from;
        var tr = state.tr;
        if (direction === 0 /* BACKWARD */) {
            tr = removeNodeBefore(state.tr);
        }
        else if ($from.nodeAfter) {
            tr = tr.delete($from.pos, $from.pos + $from.nodeAfter.nodeSize);
        }
        dispatch(tr
            .setSelection(Selection.near(tr.doc.resolve(tr.mapping.map(state.selection.$from.pos))))
            .scrollIntoView());
        return true;
    }
    return false;
}; };
export var setGapCursorAtPos = function (position, side) {
    if (side === void 0) { side = 1 /* LEFT */; }
    return function (state, dispatch) {
        var $pos = state.doc.resolve(position);
        if (GapCursorSelection.valid($pos)) {
            dispatch(state.tr.setSelection(new GapCursorSelection($pos, side)));
            return true;
        }
        return false;
    };
};
// This function captures clicks outside of the ProseMirror contentEditable area
// see also description of "handleClick" in gap-cursor pm-plugin
var captureGapCursorCoords = function (event, editorRef, posAtCoords, state) {
    var rect = editorRef.getBoundingClientRect();
    // capture clicks before the first block element
    if (event.clientY < rect.top) {
        return { position: 0, side: 1 /* LEFT */ };
    }
    if (rect.left > 0) {
        // calculate start position of a node that is vertically at the same level
        var coords = posAtCoords({
            left: rect.left,
            top: event.clientY,
        });
        if (coords && coords.inside > -1) {
            var $from = state.doc.resolve(coords.inside);
            var start = $from.before(1);
            var side = event.clientX < rect.left ? 1 /* LEFT */ : 0 /* RIGHT */;
            var position = void 0;
            if (side === 1 /* LEFT */) {
                position = start;
            }
            else {
                var node = state.doc.nodeAt(start);
                if (node) {
                    position = start + node.nodeSize;
                }
            }
            return { position: position, side: side };
        }
    }
    return null;
};
export var setGapCursorForTopLevelBlocks = function (event, editorRef, posAtCoords) { return function (state, dispatch) {
    // plugin is disabled
    if (!pluginKey.get(state)) {
        return false;
    }
    var gapCursorCoords = captureGapCursorCoords(event, editorRef, posAtCoords, state);
    if (!gapCursorCoords) {
        return false;
    }
    var $pos = state.doc.resolve(gapCursorCoords.position);
    var isAllowed = gapCursorCoords.side === 1 /* LEFT */
        ? $pos.nodeAfter && !isIgnored($pos.nodeAfter)
        : $pos.nodeBefore && !isIgnored($pos.nodeBefore);
    if (isAllowed && GapCursorSelection.valid($pos)) {
        // this forces PM to re-render the decoration node if we change the side of the gap cursor, it doesn't do it by default
        if (state.selection instanceof GapCursorSelection) {
            dispatch(state.tr.setSelection(Selection.near($pos)));
        }
        dispatch(state.tr.setSelection(new GapCursorSelection($pos, gapCursorCoords.side)));
        return true;
    }
    return false;
}; };
//# sourceMappingURL=actions.js.map