import { findPositionOfNodeBefore, findDomRefAtPos } from 'prosemirror-utils';
import { tableMarginTop, tableMarginBottom } from '@atlaskit/editor-common';
// we don't show gap cursor for those nodes
var INGORED_NODES = [
    'paragraph',
    'listItem',
    'taskItem',
    'decisionItem',
    'heading',
    'blockquote',
];
// Returns DOM node's vertical margin. It descents into the node and reads margins of nested DOM nodes
var getDomNodeVerticalMargin = function (ref, side) {
    var margin = 0;
    while (ref && ref.nodeType === 1) {
        var css = window.getComputedStyle(ref);
        var curMargin = parseInt(css["margin-" + side], 10);
        if (curMargin > margin) {
            margin = curMargin;
        }
        ref = ref[side === 'top' ? 'firstChild' : 'lastChild'];
    }
    return margin;
};
export var isIgnored = function (node) {
    if (!node) {
        return false;
    }
    return INGORED_NODES.indexOf(node.type.name) > -1;
};
var isMediaSingle = function (node) {
    if (!node) {
        return false;
    }
    var firstChild = node.firstChild;
    return (!!firstChild &&
        firstChild.nodeType === 1 &&
        firstChild.classList.contains('media-single'));
};
// incapsulated this hack into a separate util function
export var fixCursorAlignment = function (view) {
    var _a = view.state, selection = _a.selection, schema = _a.schema, domAtPos = view.domAtPos;
    var _b = selection, side = _b.side, $from = _b.$from;
    // gap cursor is positioned relative to that node
    var targetNode = side === 1 /* LEFT */ ? $from.nodeAfter : $from.nodeBefore;
    if (!targetNode) {
        return;
    }
    var targetNodePos = side === 1 /* LEFT */ ? $from.pos + 1 : findPositionOfNodeBefore(selection);
    var targetNodeRef = findDomRefAtPos(targetNodePos, domAtPos.bind(view));
    var gapCursorRef = view.dom.querySelector('.ProseMirror-gapcursor span');
    var gapCursorParentNodeRef = gapCursorRef.parentNode;
    var previousSibling = gapCursorParentNodeRef.previousSibling;
    var firstChild = targetNodeRef.firstChild;
    var isTargetNodeMediaSingle = isMediaSingle(targetNodeRef);
    var isMediaWithWrapping = isTargetNodeMediaSingle &&
        /wrap-[right|left]/i.test(targetNode.attrs.layout);
    var prevNodeMarginBottom = getDomNodeVerticalMargin(previousSibling, 'bottom');
    var minHeight = 20;
    var height = 0;
    var width = 0;
    var marginTop = 0;
    var breakoutWidth = 0;
    // gets width and height of the prevNode DOM element, or its nodeView wrapper DOM element
    do {
        var css = window.getComputedStyle(isTargetNodeMediaSingle ? firstChild : targetNodeRef);
        var isInTableCell = /td|th/i.test(targetNodeRef.parentNode.nodeName);
        height = parseInt(css['height'], 10);
        width = parseInt(css['width'], 10);
        if (previousSibling || isMediaWithWrapping || isInTableCell) {
            var curNodeMarginTop = getDomNodeVerticalMargin(targetNodeRef, 'top');
            if (curNodeMarginTop > prevNodeMarginBottom) {
                marginTop = curNodeMarginTop - prevNodeMarginBottom;
            }
            if (isMediaWithWrapping) {
                marginTop = curNodeMarginTop;
            }
        }
        if (/table/i.test(targetNodeRef.nodeName) || isTargetNodeMediaSingle) {
            breakoutWidth = width;
        }
        targetNodeRef = targetNodeRef.parentNode;
    } while (targetNodeRef && !targetNodeRef.contains(gapCursorRef));
    // height of the rule (<hr>) is 0, that's why we set minHeight
    if (height < minHeight) {
        height = minHeight;
        marginTop -= Math.round(minHeight / 2) - 1;
    }
    // table nodeView margin fix
    if (targetNode.type === schema.nodes.table) {
        height -= tableMarginTop + tableMarginBottom;
        marginTop = tableMarginTop;
    }
    // breakout mode
    if (/full-width|wide/i.test(targetNode.attrs.layout)) {
        gapCursorRef.setAttribute('layout', targetNode.attrs.layout);
    }
    // mediaSingle with layout="wrap-left" or "wrap-right"
    if (isMediaWithWrapping) {
        gapCursorParentNodeRef.setAttribute('layout', targetNode.attrs.layout);
        if (targetNode.attrs.layout === 'wrap-right') {
            gapCursorRef.style.marginLeft = "-" + width + "px";
        }
    }
    gapCursorRef.style.height = height + "px";
    gapCursorRef.style.marginTop = marginTop + "px";
    gapCursorRef.style.width = (breakoutWidth || width) + "px";
};
//# sourceMappingURL=utils.js.map