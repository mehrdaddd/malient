import { Step } from 'prosemirror-transform';
import { AllSelection, NodeSelection } from 'prosemirror-state';
export var handleInit = function (initData, view) {
    var doc = initData.doc, json = initData.json;
    if (doc) {
        var state = view.state, _a = view.state, schema_1 = _a.schema, tr = _a.tr;
        var content = (doc.content || []).map(function (child) {
            return schema_1.nodeFromJSON(child);
        });
        if (content.length) {
            var newState = state.apply(tr
                .setMeta('addToHistory', false)
                .replaceWith(0, state.doc.nodeSize - 2, content)
                .scrollIntoView());
            view.updateState(newState);
        }
    }
    else if (json) {
        applyRemoteSteps(json, view);
    }
};
export var handleConnection = function (connectionData, view) {
    var tr = view.state.tr;
    view.dispatch(tr.setMeta('sessionId', connectionData));
};
export var handlePresence = function (presenceData, view) {
    var tr = view.state.tr;
    view.dispatch(tr.setMeta('presence', presenceData));
};
export var applyRemoteData = function (remoteData, view) {
    var json = remoteData.json, newState = remoteData.newState;
    if (json) {
        applyRemoteSteps(json, view);
    }
    else if (newState) {
        view.updateState(newState);
    }
};
export var applyRemoteSteps = function (json, view) {
    var state = view.state, schema = view.state.schema;
    var tr = state.tr;
    json.forEach(function (stepJson) {
        var step = Step.fromJSON(schema, stepJson);
        tr.step(step);
    });
    tr.setMeta('addToHistory', false);
    tr.scrollIntoView();
    var newState = state.apply(tr);
    view.updateState(newState);
};
export var handleTelePointer = function (telepointerData, view) {
    var tr = view.state.tr;
    view.dispatch(tr.setMeta('telepointer', telepointerData));
};
function isAllSelection(selection) {
    return selection instanceof AllSelection;
}
function isNodeSelection(selection) {
    return selection instanceof NodeSelection;
}
export var getSendableSelection = function (selection) {
    /**
     * <kbd>CMD + A</kbd> triggers a AllSelection
     * <kbd>escape</kbd> triggers a NodeSelection
     */
    return {
        type: 'textSelection',
        anchor: selection.anchor,
        head: isAllSelection(selection) || isNodeSelection(selection)
            ? selection.head - 1
            : selection.head,
    };
};
//# sourceMappingURL=actions.js.map