import * as tslib_1 from "tslib";
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { DecisionItem } from '@atlaskit/task-decision';
import { ContentNodeView } from '../../../nodeviews';
var Decision = /** @class */ (function (_super) {
    tslib_1.__extends(Decision, _super);
    function Decision(node, view, getPos) {
        var _this = _super.call(this, node, view) || this;
        _this.isContentEmpty = false;
        _this.isContentEmpty = node.content.childCount === 0;
        _this.node = node;
        _this.renderReactComponent();
        return _this;
    }
    Decision.prototype.renderReactComponent = function () {
        this.domRef = document.createElement('li');
        this.domRef.style['list-style-type'] = 'none';
        // tslint:disable-next-line:variable-name
        ReactDOM.render(React.createElement(DecisionItem, { contentRef: this.handleRef, showPlaceholder: this.isContentEmpty }), this.domRef);
    };
    Object.defineProperty(Decision.prototype, "dom", {
        get: function () {
            return this.domRef;
        },
        enumerable: true,
        configurable: true
    });
    Decision.prototype.update = function (node) {
        /**
         * Returning false here when the previous content was empty â€“ fixes an error where the editor fails to set selection
         * inside the contentDOM after a transaction. See ED-2374.
         */
        return !this.isContentEmpty || node.type !== this.node.type;
    };
    Decision.prototype.destroy = function () {
        ReactDOM.unmountComponentAtNode(this.domRef);
        this.domRef = undefined;
        _super.prototype.destroy.call(this);
    };
    return Decision;
}(ContentNodeView));
export var decisionItemNodeView = function (node, view, getPos) {
    return new Decision(node, view, getPos);
};
//# sourceMappingURL=decisionItem.js.map