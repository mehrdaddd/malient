import { uuid } from '@atlaskit/editor-common';
import { safeInsert, hasParentNodeOfType, replaceParentNodeOfType, } from 'prosemirror-utils';
import { GapCursorSelection } from '../gap-cursor';
var getListTypes = function (listType, schema) {
    var _a = schema.nodes, decisionList = _a.decisionList, decisionItem = _a.decisionItem, taskList = _a.taskList, taskItem = _a.taskItem;
    if (listType === 'taskList') {
        return {
            list: taskList,
            item: taskItem,
        };
    }
    return {
        list: decisionList,
        item: decisionItem,
    };
};
var isSelectionInAList = function (listType, selection) {
    var fromNode = selection.$from.node(selection.$from.depth - 2);
    var endNode = selection.$to.node(selection.$to.depth - 2);
    return (fromNode &&
        fromNode.type.name === listType &&
        endNode &&
        endNode.type.name !== listType);
};
export var changeToTaskDecision = function (view, listType) {
    var state = view.state;
    var selection = state.selection, schema = state.schema;
    var _a = getListTypes(listType, schema), list = _a.list, item = _a.item;
    var tr = state.tr;
    if (!isSelectionInAList(listType, selection)) {
        // Not a list - convert to one.
        var created = createListAtSelection(tr, list, item, schema, state);
        view.dispatch(tr);
        return created;
    }
    return false;
};
export var createListAtSelection = function (tr, list, item, schema, state) {
    var selection = state.selection;
    var $from = selection.$from, $to = selection.$to;
    if ($from.parent !== $to.parent) {
        // ignore selections across multiple nodes
        return false;
    }
    var _a = schema.nodes, paragraph = _a.paragraph, blockquote = _a.blockquote, decisionList = _a.decisionList, taskList = _a.taskList, mediaGroup = _a.mediaGroup;
    if ($from.parent.type === mediaGroup) {
        return false;
    }
    var emptyList = list.create({ localId: uuid.generate() }, [
        item.create({ localId: uuid.generate() }),
    ]);
    // we don't take the content of a block node next to the gap cursor and always create an empty task
    if (selection instanceof GapCursorSelection) {
        safeInsert(emptyList)(tr);
        return true;
    }
    // try to replace any of the given nodeTypes
    if (hasParentNodeOfType([blockquote, paragraph, decisionList, taskList])(selection)) {
        var newTr = replaceParentNodeOfType([blockquote, paragraph, decisionList, taskList], list.create({ localId: uuid.generate() }, [
            item.create({ localId: uuid.generate() }, $from.node($from.depth).content),
        ]))(tr);
        // replacing successful
        if (newTr !== tr) {
            return true;
        }
    }
    safeInsert(emptyList)(tr);
    return true;
};
//# sourceMappingURL=commands.js.map