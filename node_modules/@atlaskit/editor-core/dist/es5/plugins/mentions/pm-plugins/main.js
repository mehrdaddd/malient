"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mention_1 = require("@atlaskit/mention");
var prosemirror_model_1 = require("prosemirror-model");
var prosemirror_state_1 = require("prosemirror-state");
var utils_1 = require("../../../utils");
var analytics_1 = require("../../../analytics");
var mention_2 = require("../nodeviews/mention");
var nodeviews_1 = require("../../../nodeviews");
exports.mentionPluginKey = new prosemirror_state_1.PluginKey('mentionPlugin');
function findMentionQueryMarks(state, active) {
    if (active === void 0) { active = true; }
    var doc = state.doc, schema = state.schema;
    var mentionQuery = schema.marks.mentionQuery;
    var marks = [];
    doc.nodesBetween(0, doc.nodeSize - 2, function (node, pos) {
        var mark = mentionQuery.isInSet(node.marks);
        if (mark) {
            var query = node.textContent.substr(1).trim();
            if ((active && mark.attrs.active) || (!active && !mark.attrs.active)) {
                marks.push({
                    start: pos,
                    end: pos + node.textContent.length,
                    query: query,
                });
            }
            return false;
        }
        return true;
    });
    return marks;
}
var MentionsState = /** @class */ (function () {
    function MentionsState(state, providerFactory) {
        var _this = this;
        this.queryActive = false;
        this.enabled = true;
        this.focused = true;
        this.onSelectPrevious = function () { return false; };
        this.onSelectNext = function () { return false; };
        this.onSelectCurrent = function (key) { return false; };
        this.onDismiss = function () { };
        this.onSpaceTyped = function () { };
        this.changeHandlers = [];
        this.handleProvider = function (name, provider) {
            switch (name) {
                case 'mentionProvider':
                    _this.setMentionProvider(provider);
                    break;
            }
        };
        this.onMentionResult = function (mentions, query) {
            if (!query) {
                return;
            }
            if (query.length > 0 && query === _this.query) {
                _this.currentQueryResult = mentions;
            }
            var match = _this.findExactMatch(query, mentions);
            if (match) {
                _this.queryResults.set(query, match);
            }
            if (_this.isSubQueryOfCurrentQuery(query)) {
                _this.previousQueryResultCount = mentions.length;
            }
        };
        this.insertMentionQuery = function () {
            var state = _this.view.state;
            var node = state.schema.text('@', [state.schema.mark('mentionQuery')]);
            _this.view.dispatch(state.tr.replaceSelection(new prosemirror_model_1.Slice(prosemirror_model_1.Fragment.from(node), 0, 0)));
            if (!_this.view.hasFocus()) {
                _this.view.focus();
            }
        };
        this.changeHandlers = [];
        this.state = state;
        this.dirty = false;
        this.queryResults = new Map();
        this.tokens = new Map();
        this.previousQueryResultCount = -1;
        providerFactory.subscribe('mentionProvider', this.handleProvider);
    }
    MentionsState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    MentionsState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    MentionsState.prototype.notifySubscribers = function () {
        var _this = this;
        this.changeHandlers.forEach(function (cb) { return cb(_this); });
    };
    MentionsState.prototype.apply = function (tr, state) {
        if (!this.mentionProvider) {
            return;
        }
        var mentionQuery = state.schema.marks.mentionQuery;
        var doc = state.doc, selection = state.selection;
        var from = selection.from, to = selection.to;
        this.dirty = false;
        var newEnabled = this.isEnabled(state);
        if (newEnabled !== this.enabled) {
            this.enabled = newEnabled;
            this.dirty = true;
        }
        var hasActiveQueryNode = function (node) {
            var mark = mentionQuery.isInSet(node.marks);
            return mark && mark.attrs.active;
        };
        if (this.rangeHasNodeMatchingQuery(doc, from - 1, to, hasActiveQueryNode)) {
            if (!this.queryActive) {
                this.dirty = true;
                this.queryActive = true;
            }
            var nodeBefore = selection.$from.nodeBefore;
            var newQuery = ((nodeBefore && nodeBefore.textContent) || '').substr(1);
            if (this.query !== newQuery) {
                this.dirty = true;
                this.query = newQuery;
                if (newQuery.length === 0) {
                    this.currentQueryResult = undefined;
                }
            }
        }
        else if (this.queryActive) {
            this.dirty = true;
            return;
        }
    };
    MentionsState.prototype.update = function (state) {
        this.state = state;
        if (!this.mentionProvider) {
            return;
        }
        var mentionQuery = state.schema.marks.mentionQuery;
        var doc = state.doc, selection = state.selection;
        var from = selection.from, to = selection.to;
        if (!doc.rangeHasMark(from - 1, to, mentionQuery) && this.queryActive) {
            this.dismiss();
        }
        var newAnchorElement = this.view.dom.querySelector('[data-mention-query]');
        if (newAnchorElement !== this.anchorElement) {
            this.dirty = true;
            this.anchorElement = newAnchorElement;
        }
        if (this.dirty) {
            this.notifySubscribers();
        }
    };
    MentionsState.prototype.rangeHasNodeMatchingQuery = function (doc, from, to, query) {
        var found = false;
        doc.nodesBetween(from, to, function (node) {
            if (query(node)) {
                found = true;
            }
        });
        return found;
    };
    MentionsState.prototype.dismiss = function () {
        var transaction = this.generateDismissTransaction();
        if (transaction) {
            var view = this.view;
            view.dispatch(transaction);
        }
        this.onDismiss();
        return true;
    };
    MentionsState.prototype.generateDismissTransaction = function (tr) {
        this.clearState();
        var state = this.state;
        var currentTransaction = tr ? tr : state.tr;
        if (state) {
            var schema = state.schema;
            var markType = schema.mark('mentionQuery');
            var _a = this.findActiveMentionQueryMark(), start = _a.start, end = _a.end;
            return currentTransaction
                .removeMark(start, end, markType)
                .removeStoredMark(markType);
        }
        return currentTransaction;
    };
    MentionsState.prototype.isEnabled = function (state) {
        var currentState = state ? state : this.state;
        var mentionQuery = currentState.schema.marks.mentionQuery;
        return utils_1.isMarkTypeAllowedInCurrentSelection(mentionQuery, currentState);
    };
    MentionsState.prototype.findActiveMentionQueryMark = function () {
        var activeMentionQueryMarks = findMentionQueryMarks(this.state, true);
        if (activeMentionQueryMarks.length !== 1) {
            return { start: -1, end: -1, query: '' };
        }
        return activeMentionQueryMarks[0];
    };
    MentionsState.prototype.insertMention = function (mentionData, queryMark) {
        var view = this.view;
        var tr = this.generateInsertMentionTransaction(mentionData, queryMark);
        // This problem affects Chrome v58-62. See: https://github.com/ProseMirror/prosemirror/issues/710
        if (utils_1.isChromeWithSelectionBug) {
            document.getSelection().empty();
        }
        view.dispatch(tr);
    };
    MentionsState.prototype.generateInsertMentionTransaction = function (mentionData, queryMark, tr) {
        var state = this.state;
        var mention = state.schema.nodes.mention;
        var currentTransaction = tr ? tr : state.tr;
        if (mention && mentionData) {
            var activeMentionQueryMark = this.findActiveMentionQueryMark();
            var _a = queryMark ? queryMark : activeMentionQueryMark, start = _a.start, end = _a.end;
            var id = mentionData.id, name_1 = mentionData.name, nickname = mentionData.nickname, accessLevel = mentionData.accessLevel, userType = mentionData.userType;
            var renderName = nickname ? nickname : name_1;
            var nodes = [
                mention.create({
                    text: "@" + renderName,
                    id: id,
                    accessLevel: accessLevel,
                    userType: userType === 'DEFAULT' ? null : userType,
                }),
            ];
            if (!this.isNextCharacterSpace(end, currentTransaction.doc)) {
                nodes.push(state.schema.text(' '));
            }
            this.clearState();
            var transaction = currentTransaction;
            if (activeMentionQueryMark.end !== end) {
                var mentionMark = state.schema.mark('mentionQuery', { active: true });
                transaction = transaction.removeMark(end, activeMentionQueryMark.end, mentionMark);
            }
            transaction = transaction.replaceWith(start, end, nodes);
            return transaction;
        }
        else {
            return this.generateDismissTransaction(currentTransaction);
        }
    };
    MentionsState.prototype.isNextCharacterSpace = function (position, doc) {
        try {
            var resolvedPosition = doc.resolve(position);
            return (resolvedPosition.nodeAfter &&
                resolvedPosition.nodeAfter.textContent.indexOf(' ') === 0);
        }
        catch (e) {
            return false;
        }
    };
    MentionsState.prototype.setMentionProvider = function (provider) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (provider && provider.then) {
                provider
                    .then(function (mentionProvider) {
                    if (_this.mentionProvider) {
                        _this.mentionProvider.unsubscribe('editor-mentionpicker');
                        _this.currentQueryResult = undefined;
                    }
                    _this.mentionProvider = mentionProvider;
                    _this.mentionProvider.subscribe('editor-mentionpicker', undefined, undefined, undefined, _this.onMentionResult);
                    // Improve first mentions performance by establishing a connection and populating local search
                    _this.mentionProvider.filter('');
                    resolve(mentionProvider);
                })
                    .catch(function () {
                    _this.mentionProvider = undefined;
                });
            }
            else {
                _this.mentionProvider = undefined;
            }
        });
    };
    MentionsState.prototype.trySelectCurrent = function (key) {
        var currentQuery = this.query ? this.query.trim() : '';
        var mentions = this.currentQueryResult
            ? this.currentQueryResult
            : [];
        var mentionsCount = mentions.length;
        this.tokens.set(currentQuery, this.findActiveMentionQueryMark());
        if (!this.mentionProvider) {
            return false;
        }
        var queryInFlight = this.mentionProvider.isFiltering(currentQuery);
        if (!queryInFlight && mentionsCount === 1) {
            this.onSelectCurrent(key);
            return true;
        }
        // No results for the current query OR no results expected because previous subquery didn't return anything
        if ((!queryInFlight && mentionsCount === 0) ||
            this.previousQueryResultCount === 0) {
            var match = this.tryInsertingPreviousMention();
            analytics_1.analyticsService.trackEvent('atlassian.fabric.mention.insert.auto', {
                match: match,
            });
        }
        if (!this.query) {
            this.dismiss();
        }
        this.onSpaceTyped();
        return false;
    };
    MentionsState.prototype.tryInsertingPreviousMention = function () {
        var _this = this;
        var mentionInserted = false;
        this.tokens.forEach(function (value, key) {
            var match = _this.queryResults.get(key);
            if (match) {
                _this.insertMention(match, value);
                _this.tokens.delete(key);
                mentionInserted = true;
            }
        });
        if (!mentionInserted) {
            this.dismiss();
        }
        return mentionInserted;
    };
    MentionsState.prototype.isSubQueryOfCurrentQuery = function (query) {
        return (this.query &&
            this.query.indexOf(query) === 0 &&
            !this.mentionProvider.isFiltering(query));
    };
    MentionsState.prototype.findExactMatch = function (query, mentions) {
        var filteredMentions = mentions.filter(function (mention) {
            if (mention.nickname &&
                mention.nickname.toLocaleLowerCase() === query.toLocaleLowerCase()) {
                return mention;
            }
        });
        if (filteredMentions.length > 1) {
            filteredMentions = filteredMentions.filter(function (mention) {
                return mention_1.isSpecialMention(mention);
            });
        }
        return filteredMentions.length === 1 ? filteredMentions[0] : null;
    };
    MentionsState.prototype.clearState = function () {
        this.queryActive = false;
        this.lastQuery = this.query;
        this.query = undefined;
        this.tokens.clear();
        this.previousQueryResultCount = -1;
    };
    MentionsState.prototype.setView = function (view) {
        this.view = view;
    };
    MentionsState.prototype.updateEditorFocused = function (focused) {
        this.focused = focused;
        this.notifySubscribers();
    };
    return MentionsState;
}());
exports.MentionsState = MentionsState;
function createPlugin(providerFactory) {
    return new prosemirror_state_1.Plugin({
        state: {
            init: function (config, state) {
                return new MentionsState(state, providerFactory);
            },
            apply: function (tr, prevPluginState, oldState, newState) {
                // NOTE: Don't replace the pluginState here.
                prevPluginState.apply(tr, newState);
                return prevPluginState;
            },
        },
        props: {
            nodeViews: {
                mention: nodeviews_1.nodeViewFactory(providerFactory, { mention: mention_2.default }),
            },
            handleDOMEvents: {
                focus: function (view, event) {
                    exports.mentionPluginKey.getState(view.state).updateEditorFocused(true);
                    return false;
                },
                blur: function (view, event) {
                    exports.mentionPluginKey.getState(view.state).updateEditorFocused(false);
                    return false;
                },
            },
        },
        key: exports.mentionPluginKey,
        view: function (view) {
            var pluginState = exports.mentionPluginKey.getState(view.state);
            pluginState.setView(view);
            return {
                update: function (view, prevState) {
                    pluginState.update(view.state);
                },
                destroy: function () {
                    providerFactory.unsubscribe('mentionProvider', pluginState.handleProvider);
                },
            };
        },
        appendTransaction: function (transactions, oldState, newState) {
            return findMentionQueryMarks(newState, true).reduce(function (currentTr, queryMark) {
                var doc = currentTr ? currentTr.doc : newState.doc;
                var start = queryMark.start, end = queryMark.end;
                if (!doc
                    .textBetween(start, end)
                    .trim()
                    .startsWith('@')) {
                    var newTr = currentTr ? currentTr : newState.tr;
                    newTr = newTr.removeMark(start, end, newState.schema.marks.mentionQuery);
                    newTr.setMeta('addToHistory', false);
                    return newTr;
                }
                else {
                    return currentTr;
                }
            }, null);
        },
    });
}
exports.createPlugin = createPlugin;
//# sourceMappingURL=main.js.map