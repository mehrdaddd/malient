"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_state_1 = require("prosemirror-state");
var types_1 = require("../types");
var commands = require("../../../commands");
var utils_1 = require("../../../utils");
/**
 *
 * Plugin State
 *
 */
var BlockTypeState = /** @class */ (function () {
    function BlockTypeState(state) {
        var _this = this;
        this.changeHandlers = [];
        // public state
        this.currentBlockType = types_1.NORMAL_TEXT;
        this.blockTypesDisabled = false;
        this.availableBlockTypes = [];
        this.availableWrapperBlockTypes = [];
        this.isCodeBlock = false;
        this.nodeBlockType = function (node) {
            if (node.type === _this.state.schema.nodes.heading) {
                switch (node.attrs['level']) {
                    case 1:
                        return types_1.HEADING_1;
                    case 2:
                        return types_1.HEADING_2;
                    case 3:
                        return types_1.HEADING_3;
                    case 4:
                        return types_1.HEADING_4;
                    case 5:
                        return types_1.HEADING_5;
                    case 6:
                        return types_1.HEADING_6;
                }
            }
            else if (node.type === _this.state.schema.nodes.paragraph) {
                return types_1.NORMAL_TEXT;
            }
            return types_1.OTHER;
        };
        this.isBlockTypeSchemaSupported = function (blockType) {
            var state = _this.state;
            switch (blockType) {
                case types_1.NORMAL_TEXT:
                    return !!state.schema.nodes.paragraph;
                case types_1.HEADING_1:
                case types_1.HEADING_2:
                case types_1.HEADING_3:
                case types_1.HEADING_4:
                case types_1.HEADING_5:
                case types_1.HEADING_6:
                    return !!state.schema.nodes.heading;
                case types_1.BLOCK_QUOTE:
                    return !!state.schema.nodes.blockquote;
                case types_1.CODE_BLOCK:
                    return !!state.schema.nodes.codeBlock;
                case types_1.PANEL:
                    return !!state.schema.nodes.panel;
            }
        };
        this.changeHandlers = [];
        this.state = state;
        this.availableBlockTypes = [
            types_1.NORMAL_TEXT,
            types_1.HEADING_1,
            types_1.HEADING_2,
            types_1.HEADING_3,
            types_1.HEADING_4,
            types_1.HEADING_5,
            types_1.HEADING_6,
        ].filter(this.isBlockTypeSchemaSupported);
        this.availableWrapperBlockTypes = [types_1.BLOCK_QUOTE, types_1.CODE_BLOCK, types_1.PANEL].filter(this.isBlockTypeSchemaSupported);
        this.update(state);
    }
    BlockTypeState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    BlockTypeState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    BlockTypeState.prototype.setBlockType = function (name, view) {
        return commands.setBlockType(view, name);
    };
    BlockTypeState.prototype.insertBlockType = function (name, view) {
        return commands.insertBlockType(name)(view.state, view.dispatch);
    };
    BlockTypeState.prototype.update = function (newEditorState, dirty) {
        if (dirty === void 0) { dirty = false; }
        this.state = newEditorState;
        var newBlockType = this.detectBlockType();
        if (newBlockType !== this.currentBlockType) {
            this.currentBlockType = newBlockType;
            dirty = true;
        }
        var newBlockTypesDisabled = utils_1.areBlockTypesDisabled(this.state);
        if (newBlockTypesDisabled !== this.blockTypesDisabled) {
            this.blockTypesDisabled = newBlockTypesDisabled;
            dirty = true;
        }
        if (dirty) {
            this.triggerOnChange();
        }
    };
    BlockTypeState.prototype.triggerOnChange = function () {
        var _this = this;
        this.changeHandlers.forEach(function (cb) { return cb(_this); });
    };
    BlockTypeState.prototype.detectBlockType = function () {
        var _this = this;
        var state = this.state;
        // Before a document is loaded, there is no selection.
        if (!state.selection) {
            return types_1.NORMAL_TEXT;
        }
        var blockType;
        var _a = state.selection, $from = _a.$from, $to = _a.$to;
        state.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {
            var nodeBlockType = _this.availableBlockTypes.filter(function (blockType) { return blockType === _this.nodeBlockType(node); });
            if (nodeBlockType.length > 0) {
                if (!blockType) {
                    blockType = nodeBlockType[0];
                }
                else if (blockType !== types_1.OTHER && blockType !== nodeBlockType[0]) {
                    blockType = types_1.OTHER;
                }
            }
        });
        return blockType || types_1.OTHER;
    };
    return BlockTypeState;
}());
exports.BlockTypeState = BlockTypeState;
exports.stateKey = new prosemirror_state_1.PluginKey('blockTypePlugin');
exports.createPlugin = function (appearance) {
    return new prosemirror_state_1.Plugin({
        appendTransaction: function (transactions, oldState, newState) {
            if (appearance === 'comment') {
                var pos = newState.doc.resolve(newState.doc.content.size - 1);
                var lastNode = pos.node(1);
                var paragraph = newState.schema.nodes.paragraph;
                if (lastNode && lastNode.isBlock && lastNode.type !== paragraph) {
                    return newState.tr.insert(newState.doc.content.size, newState.schema.nodes.paragraph.create());
                }
            }
        },
        state: {
            init: function (config, state) {
                return new BlockTypeState(state);
            },
            apply: function (tr, pluginState, oldState, newState) {
                pluginState.update(newState);
                return pluginState;
            },
        },
        key: exports.stateKey,
    });
};
//# sourceMappingURL=main.js.map