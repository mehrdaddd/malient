"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_model_1 = require("prosemirror-model");
var prosemirror_transform_1 = require("prosemirror-transform");
var utils_1 = require("../../../utils");
function transformToCodeBlock(state) {
    if (!isConvertableToCodeBlock(state)) {
        return;
    }
    transformToCodeBlockAction(state).scrollIntoView();
}
exports.default = transformToCodeBlock;
function transformToCodeBlockAction(state, attrs) {
    var $from = state.selection.$from;
    var codeBlock = state.schema.nodes.codeBlock;
    var where = $from.before($from.depth);
    var tr = clearMarkupFor(state, where);
    return mergeContent(tr, state).setNodeMarkup(where, codeBlock, attrs);
}
exports.transformToCodeBlockAction = transformToCodeBlockAction;
function isConvertableToCodeBlock(state) {
    // Before a document is loaded, there is no selection.
    if (!state.selection) {
        return false;
    }
    var $from = state.selection.$from;
    var node = $from.parent;
    if (!node.isTextblock || node.type === state.schema.nodes.codeBlock) {
        return false;
    }
    var parentDepth = $from.depth - 1;
    var parentNode = $from.node(parentDepth);
    var index = $from.index(parentDepth);
    return parentNode.canReplaceWith(index, index + 1, state.schema.nodes.codeBlock);
}
exports.isConvertableToCodeBlock = isConvertableToCodeBlock;
/*
 * This is adapted from prosemirror-transform's clearIncompatible helper method
 * https://github.com/ProseMirror/prosemirror-transform/blob/055c50e08df6b8626dadba88299e50a533c9d6f7/src/mark.js#L84
 *
 * It's been modifedt to allow for serialisation of:
 *   - mention nodes to their text representation
 *   - hard breaks / horizontal rules to new lines
 */
function clearMarkupFor(state, pos) {
    var tr = state.tr;
    var node = tr.doc.nodeAt(pos);
    var codeBlock = state.schema.nodes.codeBlock;
    var match = codeBlock.contentMatch;
    var delSteps = [];
    var cur = pos + 1;
    for (var i = 0; i < node.childCount; i++) {
        var child = node.child(i);
        var end = cur + child.nodeSize;
        var allowed = match.matchType(child.type);
        if (!allowed) {
            if (child.type === state.schema.nodes.mention) {
                var content = child.attrs['text'];
                delSteps.push(new prosemirror_transform_1.ReplaceStep(cur, end, utils_1.createSliceWithContent(content, state)));
            }
            else if (child.type === state.schema.nodes.rule ||
                child.type === state.schema.nodes.hardBreak) {
                var content = '\n';
                delSteps.push(new prosemirror_transform_1.ReplaceStep(cur, end, utils_1.createSliceWithContent(content, state)));
            }
            else {
                delSteps.push(new prosemirror_transform_1.ReplaceStep(cur, end, prosemirror_model_1.Slice.empty));
            }
        }
        else {
            match = allowed;
            for (var j = 0; j < child.marks.length; j++) {
                if (!codeBlock.allowsMarkType(child.marks[j].type)) {
                    tr.step(new prosemirror_transform_1.RemoveMarkStep(cur, end, child.marks[j]));
                }
            }
        }
        cur = end;
    }
    if (!match.validEnd) {
        // attempts to insert additional nodes if the last match was not valid
        var fill = match.fillBefore(prosemirror_model_1.Fragment.empty, true);
        tr.replace(cur, cur, new prosemirror_model_1.Slice(fill, 0, 0));
    }
    for (var i = delSteps.length - 1; i >= 0; i--) {
        tr.step(delSteps[i]);
    }
    return tr;
}
function mergeContent(tr, state) {
    var _a = tr.selection, from = _a.from, to = _a.to, empty = _a.empty;
    if (empty) {
        return tr;
    }
    var textContent = '';
    tr.doc.nodesBetween(from, to, function (node, pos) {
        if (node.isTextblock && node.textContent) {
            if (textContent.length > 0) {
                textContent += '\n';
            }
            textContent += node.textContent;
        }
    });
    if (textContent.length > 0) {
        var textNode = state.schema.text(textContent);
        tr.replaceSelectionWith(textNode);
    }
    return tr;
}
//# sourceMappingURL=transform-to-code-block.js.map