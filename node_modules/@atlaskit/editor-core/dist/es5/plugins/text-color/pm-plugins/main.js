"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_state_1 = require("prosemirror-state");
var editor_common_1 = require("@atlaskit/editor-common");
var util_shared_styles_1 = require("@atlaskit/util-shared-styles");
// TODO: Pass during plugin initialization
// https://product-fabric.atlassian.net/browse/ED-1682
exports.DEFAULT_COLOR = {
    color: util_shared_styles_1.akColorN800,
    label: 'Dark grey',
};
var TextColorState = /** @class */ (function () {
    function TextColorState(state, palette) {
        this.changeHandlers = [];
        this.state = state;
        this.palette = palette;
        this.borderColorPalette = editor_common_1.borderColorPalette;
        this.defaultColor = palette.keys().next().value;
        this.update(state);
    }
    TextColorState.prototype.subscribe = function (cb) {
        this.changeHandlers.push(cb);
        cb(this);
    };
    TextColorState.prototype.unsubscribe = function (cb) {
        this.changeHandlers = this.changeHandlers.filter(function (ch) { return ch !== cb; });
    };
    TextColorState.prototype.update = function (newEditorState) {
        this.state = newEditorState;
        var state = this.state;
        var textColor = state.schema.marks.textColor;
        var dirty = false;
        if (textColor) {
            var activeColor = this.getActiveColor();
            if (this.color !== activeColor) {
                this.color = activeColor;
                dirty = true;
            }
            var disabled = !this.toggleTextColor(state);
            if (this.disabled !== disabled) {
                this.disabled = disabled;
                dirty = true;
            }
        }
        if (dirty) {
            this.triggerOnChange();
        }
    };
    TextColorState.prototype.toggleTextColor = function (state, dispatch, color) {
        var textColor = this.state.schema.marks.textColor;
        if (textColor) {
            var _a = state.selection, empty = _a.empty, ranges = _a.ranges, $cursor = _a.$cursor;
            if ((empty && !$cursor) ||
                !this.markApplies(state.doc, ranges, textColor)) {
                return false;
            }
            if (this.isExcluded(state.storedMarks || ($cursor && $cursor.marks()))) {
                return false;
            }
            if (dispatch && color) {
                if ($cursor) {
                    dispatch(state.tr.addStoredMark(textColor.create({ color: color })));
                }
                else {
                    var tr = state.tr;
                    for (var i = 0; i < ranges.length; i++) {
                        var _b = ranges[i], $from = _b.$from, $to = _b.$to;
                        tr.addMark($from.pos, $to.pos, textColor.create({ color: color }));
                    }
                    dispatch(tr.scrollIntoView());
                }
            }
            return true;
        }
        return false;
    };
    TextColorState.prototype.removeTextColor = function (state, dispatch, color) {
        var textColor = this.state.schema.marks.textColor;
        if (textColor) {
            var _a = state.selection, from = _a.from, to = _a.to, $cursor = _a.$cursor;
            if ($cursor) {
                dispatch(state.tr.removeStoredMark(textColor));
            }
            else {
                dispatch(state.tr.removeMark(from, to, textColor));
            }
            return true;
        }
        return false;
    };
    TextColorState.prototype.triggerOnChange = function () {
        var _this = this;
        this.changeHandlers.forEach(function (cb) { return cb(_this); });
    };
    TextColorState.prototype.getActiveColor = function () {
        var _this = this;
        var state = this.state;
        var _a = state.selection, $from = _a.$from, $to = _a.$to, $cursor = _a.$cursor;
        // Filter out other marks
        var marks = [];
        if ($cursor) {
            marks.push(this.findTextColorMark(state.storedMarks || $cursor.marks()));
        }
        else {
            state.doc.nodesBetween($from.pos, $to.pos, function (currentNode) {
                var mark = _this.findTextColorMark(currentNode.marks);
                marks.push(mark);
                return !mark;
            });
        }
        // Merge consecutive same color marks
        var prevMark;
        marks = marks.filter(function (mark) {
            if (mark && prevMark && mark.attrs.color === prevMark.attrs.color) {
                return false;
            }
            prevMark = mark;
            return true;
        });
        var marksWithColor = marks.filter(function (mark) { return !!mark; });
        // When mutiple color is selected revert back to default color
        if (marksWithColor.length > 1 ||
            (marksWithColor.length === 1 && marks.length > 2)) {
            return;
        }
        return marksWithColor.length
            ? marksWithColor[0].attrs.color
            : this.defaultColor;
    };
    TextColorState.prototype.findTextColorMark = function (marks) {
        var textColor = this.state.schema.marks.textColor;
        return this.findMarkType(textColor, marks);
    };
    TextColorState.prototype.findMarkType = function (markType, marks) {
        for (var i = 0; i < marks.length; i++) {
            var currentMark = marks[i];
            if (markType === currentMark.type) {
                return currentMark;
            }
        }
    };
    // Copied from
    // https://github.com/ProseMirror/prosemirror-commands/blob/1c27e7a/src/commands.js#L395~L406
    // This function only checks if the current node allows mark or not, doesn't respect excludes
    TextColorState.prototype.markApplies = function (doc, ranges, type) {
        var _loop_1 = function (i) {
            var _a = ranges[i], $from = _a.$from, $to = _a.$to;
            var can = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
            doc.nodesBetween($from.pos, $to.pos, function (node) {
                if (can) {
                    return false;
                }
                can = node.inlineContent && node.type.allowsMarkType(type);
            });
            if (can) {
                return { value: can };
            }
        };
        for (var i = 0; i < ranges.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return false;
    };
    TextColorState.prototype.isExcluded = function (marks) {
        if (marks) {
            var textColor_1 = this.state.schema.marks.textColor;
            return marks.some(function (mark) { return mark.type !== textColor_1 && mark.type.excludes(textColor_1); });
        }
        return false;
    };
    return TextColorState;
}());
exports.TextColorState = TextColorState;
exports.stateKey = new prosemirror_state_1.PluginKey('textColorPlugin');
exports.plugin = new prosemirror_state_1.Plugin({
    state: {
        init: function (config, state) {
            var palette = new Map([
                [exports.DEFAULT_COLOR.color.toLowerCase(), exports.DEFAULT_COLOR.label],
            ]);
            // Typescript can't spread Map as of 11 May, 2017
            editor_common_1.colorPalette.forEach(function (label, color) { return palette.set(color, label); });
            return new TextColorState(state, palette);
        },
        apply: function (tr, pluginState, oldState, newState) {
            pluginState.update(newState);
            return pluginState;
        },
    },
    key: exports.stateKey,
});
//# sourceMappingURL=main.js.map