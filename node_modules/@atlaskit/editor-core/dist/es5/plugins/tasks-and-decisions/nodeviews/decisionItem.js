"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var ReactDOM = require("react-dom");
var task_decision_1 = require("@atlaskit/task-decision");
var nodeviews_1 = require("../../../nodeviews");
var Decision = /** @class */ (function (_super) {
    tslib_1.__extends(Decision, _super);
    function Decision(node, view, getPos) {
        var _this = _super.call(this, node, view) || this;
        _this.isContentEmpty = false;
        _this.isContentEmpty = node.content.childCount === 0;
        _this.node = node;
        _this.renderReactComponent();
        return _this;
    }
    Decision.prototype.renderReactComponent = function () {
        this.domRef = document.createElement('li');
        this.domRef.style['list-style-type'] = 'none';
        // tslint:disable-next-line:variable-name
        ReactDOM.render(React.createElement(task_decision_1.DecisionItem, { contentRef: this.handleRef, showPlaceholder: this.isContentEmpty }), this.domRef);
    };
    Object.defineProperty(Decision.prototype, "dom", {
        get: function () {
            return this.domRef;
        },
        enumerable: true,
        configurable: true
    });
    Decision.prototype.update = function (node) {
        /**
         * Returning false here when the previous content was empty â€“ fixes an error where the editor fails to set selection
         * inside the contentDOM after a transaction. See ED-2374.
         */
        return !this.isContentEmpty || node.type !== this.node.type;
    };
    Decision.prototype.destroy = function () {
        ReactDOM.unmountComponentAtNode(this.domRef);
        this.domRef = undefined;
        _super.prototype.destroy.call(this);
    };
    return Decision;
}(nodeviews_1.ContentNodeView));
exports.decisionItemNodeView = function (node, view, getPos) {
    return new Decision(node, view, getPos);
};
//# sourceMappingURL=decisionItem.js.map