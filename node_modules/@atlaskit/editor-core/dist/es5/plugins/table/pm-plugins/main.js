"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_tables_1 = require("prosemirror-tables");
var prosemirror_utils_1 = require("prosemirror-utils");
var prosemirror_view_1 = require("prosemirror-view");
var _1 = require("../../../utils/");
var analytics_1 = require("../../../analytics");
var table_1 = require("../nodeviews/table");
var actions_1 = require("../actions");
var utils_1 = require("../utils");
var TableState = /** @class */ (function () {
    function TableState(state, eventDispatcher, pluginConfig) {
        var _this = this;
        this.editorFocused = false;
        this.tableHidden = false;
        this.tableDisabled = false;
        this.tableActive = false;
        this.set = prosemirror_view_1.DecorationSet.empty;
        this.allowColumnResizing = false;
        this.allowMergeCells = false;
        this.allowNumberColumn = false;
        this.allowBackgroundColor = false;
        this.allowHeaderRow = false;
        this.allowHeaderColumn = false;
        this.stickToolbarToBottom = false;
        this.isHeaderRowRequired = false;
        this.removeTable = function () {
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            prosemirror_tables_1.deleteTable(state, dispatch);
            _this.focusEditor();
            analytics_1.analyticsService.trackEvent('atlassian.editor.format.table.delete.button');
        };
        this.remove = function () {
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            var cellSelection = utils_1.getCellSelection(state);
            if (!cellSelection) {
                return;
            }
            var tableNode = cellSelection.$anchorCell.node(-1);
            var isRowSelected = cellSelection.isRowSelection();
            var isColumnSelected = cellSelection.isColSelection();
            // the whole table
            if (isRowSelected && isColumnSelected) {
                prosemirror_tables_1.deleteTable(state, dispatch);
                _this.focusEditor();
                analytics_1.analyticsService.trackEvent('atlassian.editor.format.table.delete.button');
            }
            else if (isColumnSelected) {
                analytics_1.analyticsService.trackEvent('atlassian.editor.format.table.delete_column.button');
                // move the cursor in the column to the left of the deleted column(s)
                var map = prosemirror_tables_1.TableMap.get(tableNode);
                var _b = utils_1.getSelectedColumn(_this.view.state), anchor = _b.anchor, head = _b.head;
                var column = Math.min(anchor, head);
                var nextPos = map.positionAt(0, column > 0 ? column - 1 : 0, tableNode);
                prosemirror_tables_1.deleteColumn(state, dispatch);
                _this.moveCursorTo(nextPos);
            }
            else if (isRowSelected) {
                var _c = _this.view.state.schema.nodes, tableHeader = _c.tableHeader, tableCell = _c.tableCell;
                var parent_1 = prosemirror_utils_1.findParentNodeOfType([tableHeader, tableCell])(_this.view.state.selection);
                var event_1 = parent_1 && parent_1.node.type === tableHeader
                    ? 'delete_header_row'
                    : 'delete_row';
                analytics_1.analyticsService.trackEvent("atlassian.editor.format.table." + event_1 + ".button");
                var headerRowSelected = utils_1.isHeaderRowSelected(_this.view.state);
                // move the cursor to the beginning of the next row, or prev row if deleted row was the last row
                var _d = utils_1.getSelectedRow(_this.view.state), anchor = _d.anchor, head = _d.head;
                var map = prosemirror_tables_1.TableMap.get(tableNode);
                var minRow = Math.min(anchor, head);
                var maxRow = Math.max(anchor, head);
                var isRemovingLastRow = maxRow === map.height - 1;
                prosemirror_tables_1.deleteRow(state, dispatch);
                if (headerRowSelected && _this.isHeaderRowRequired) {
                    _this.convertFirstRowToHeader();
                }
                var nextPos = map.positionAt(isRemovingLastRow ? minRow - 1 : minRow, 0, tableNode);
                _this.moveCursorTo(nextPos);
            }
        };
        this.convertFirstRowToHeader = function () {
            var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
            dispatch(prosemirror_utils_1.selectRow(0)(state.tr));
            prosemirror_tables_1.toggleHeaderRow(state, dispatch);
        };
        this.isRequiredToAddHeader = function () { return _this.isHeaderRowRequired; };
        this.addHeaderToTableNodes = function (slice, selectionStart) {
            var table = _this.view.state.schema.nodes.table;
            slice.content.forEach(function (node, offset) {
                if (node.type === table && !utils_1.containsTableHeader(_this.view.state, node)) {
                    var _a = _this.view, state = _a.state, dispatch = _a.dispatch;
                    var tr = state.tr, doc = state.doc;
                    var $anchor = doc.resolve(selectionStart + offset);
                    dispatch(tr.setSelection(new prosemirror_state_1.TextSelection($anchor)));
                    _this.convertFirstRowToHeader();
                }
            });
        };
        this.setTableLayout = function (layout) {
            var tableNode = prosemirror_utils_1.findTable(_this.view.state.selection);
            if (!tableNode) {
                return false;
            }
            var _a = _this.view.state, schema = _a.schema, tr = _a.tr;
            _this.view.dispatch(tr.setNodeMarkup(tableNode.pos - 1, schema.nodes.table, tslib_1.__assign({}, tableNode.node.attrs, { layout: layout })));
            _this.tableLayout = layout;
            return true;
        };
        this.isLayoutSupported = function () {
            var _a = _this.view.state, selection = _a.selection, schema = _a.schema;
            return (!prosemirror_utils_1.hasParentNodeOfType(schema.nodes.layoutSection)(selection) &&
                !prosemirror_utils_1.hasParentNodeOfType(schema.nodes.bodiedExtension)(selection));
        };
        var _a = state.schema.nodes, table = _a.table, tableCell = _a.tableCell, tableRow = _a.tableRow, tableHeader = _a.tableHeader;
        this.tableHidden = !table || !tableCell || !tableRow || !tableHeader;
        this.isHeaderRowRequired = !!pluginConfig.isHeaderRowRequired;
        this.allowColumnResizing = !!pluginConfig.allowColumnResizing;
        this.allowMergeCells = !!pluginConfig.allowMergeCells;
        this.allowNumberColumn = !!pluginConfig.allowNumberColumn;
        this.allowBackgroundColor = !!pluginConfig.allowBackgroundColor;
        this.allowHeaderRow = !!pluginConfig.allowHeaderRow;
        this.allowHeaderColumn = !!pluginConfig.allowHeaderColumn;
        this.stickToolbarToBottom = !!pluginConfig.stickToolbarToBottom;
        this.eventDispatcher = eventDispatcher;
        this.permittedLayouts = pluginConfig.permittedLayouts || [];
    }
    TableState.prototype.updateEditorFocused = function (editorFocused) {
        this.editorFocused = editorFocused;
    };
    TableState.prototype.update = function () {
        var controlsDirty = this.updateSelection();
        var state = this.view.state;
        var table = state.schema.nodes.table, selection = state.selection;
        var domAtPos = this.view.domAtPos.bind(this.view);
        var parent = prosemirror_utils_1.findParentDomRefOfType(table, domAtPos)(selection);
        var tableElement = parent ? parent.parentNode : undefined;
        if (tableElement !== this.tableElement) {
            this.tableElement = tableElement;
        }
        var tableNode = prosemirror_utils_1.findTable(state.selection);
        if (tableNode && tableNode.node !== this.tableNode) {
            this.tableNode = tableNode.node;
            controlsDirty = true;
        }
        var tableActive = this.editorFocused && !!tableElement;
        if (tableActive !== this.tableActive) {
            this.tableActive = tableActive;
            controlsDirty = true;
        }
        var tableDisabled = !utils_1.canInsertTable(state);
        if (tableDisabled !== this.tableDisabled) {
            this.tableDisabled = tableDisabled;
        }
        if (tableNode) {
            var tableLayout = tableNode.node.attrs.layout;
            if (tableLayout !== this.tableLayout) {
                this.tableLayout = tableLayout;
                controlsDirty = true;
            }
        }
        if (controlsDirty) {
            this.view.dispatch(state.tr.setMeta(exports.stateKey, {
                set: tableActive ? utils_1.createControlsDecorationSet(this.view) : null,
            }));
        }
        return controlsDirty;
    };
    TableState.prototype.setView = function (view) {
        this.view = view;
    };
    // we keep track of selection changes because
    // 1) we want to mark toolbar buttons as active when the whole row/col is selected
    // 2) we want to drop selection if editor looses focus
    TableState.prototype.updateSelection = function () {
        var _a = this.view, state = _a.state, dispatch = _a.dispatch;
        var cellSelection = utils_1.getCellSelection(state);
        if (cellSelection) {
            if (cellSelection !== this.cellSelection) {
                this.cellSelection = cellSelection;
                return true;
            }
            // drop selection if editor looses focus
            if (!this.editorFocused) {
                actions_1.clearSelection(state, dispatch);
                return true;
            }
        }
        else if (this.cellSelection) {
            this.cellSelection = undefined;
            return true;
        }
        return false;
    };
    TableState.prototype.focusEditor = function () {
        if (!this.view.hasFocus()) {
            this.view.focus();
        }
    };
    TableState.prototype.moveCursorInsideTableTo = function (pos) {
        this.focusEditor();
        var tr = this.view.state.tr;
        tr.setSelection(prosemirror_state_1.Selection.near(tr.doc.resolve(pos)));
        this.view.dispatch(tr);
    };
    TableState.prototype.moveCursorTo = function (pos) {
        var table = prosemirror_utils_1.findTable(this.view.state.selection);
        if (table) {
            this.moveCursorInsideTableTo(pos + table.pos);
        }
    };
    return TableState;
}());
exports.TableState = TableState;
exports.stateKey = new prosemirror_state_1.PluginKey('tablePlugin');
exports.createPlugin = function (dispatch, eventDispatcher, pluginConfig) {
    return new prosemirror_state_1.Plugin({
        state: {
            init: function (config, state) {
                return new TableState(state, eventDispatcher, pluginConfig);
            },
            apply: function (tr, state) {
                var meta = tr.getMeta(exports.stateKey);
                if (meta) {
                    state.set = meta.set || prosemirror_view_1.DecorationSet.empty;
                    return state;
                }
                return state;
            },
        },
        key: exports.stateKey,
        view: function (editorView) {
            var pluginState = exports.stateKey.getState(editorView.state);
            pluginState.setView(editorView);
            return {
                update: function (view, prevState) {
                    var dirty = pluginState.update();
                    if (dirty) {
                        dispatch(exports.stateKey, tslib_1.__assign({}, pluginState));
                    }
                },
            };
        },
        props: {
            decorations: function (state) { return exports.stateKey.getState(state).set; },
            nodeViews: {
                table: function (node, view, getPos) {
                    var allowColumnResizing = exports.stateKey.getState(view.state).allowColumnResizing;
                    return new table_1.default({
                        node: node,
                        view: view,
                        allowColumnResizing: allowColumnResizing,
                        eventDispatcher: eventDispatcher,
                        getPos: getPos,
                    });
                },
            },
            handleClick: function (view, pos, event) {
                actions_1.resetHoverSelection(view.state, view.dispatch);
                return false;
            },
            handleDOMEvents: {
                focus: function (view, event) {
                    var pluginState = exports.stateKey.getState(view.state);
                    pluginState.updateEditorFocused(true);
                    var dirty = pluginState.update();
                    if (dirty) {
                        dispatch(exports.stateKey, tslib_1.__assign({}, pluginState));
                    }
                    return false;
                },
                click: function (view, event) {
                    var element = event.target;
                    var table = prosemirror_utils_1.findTable(view.state.selection);
                    /**
                     * Check if the table cell with an image is clicked
                     * and its not the image itself
                     */
                    var matches = element.matches ? 'matches' : 'msMatchesSelector';
                    if (!table ||
                        !_1.isElementInTableCell(element) ||
                        element[matches]('table .image, table p, table .image div')) {
                        return false;
                    }
                    var map = prosemirror_tables_1.TableMap.get(table.node);
                    /** Getting the offset of current item clicked */
                    var colElement = (_1.closestElement(element, 'td') ||
                        _1.closestElement(element, 'th'));
                    var colIndex = colElement && colElement.cellIndex;
                    var rowElement = _1.closestElement(element, 'tr');
                    var rowIndex = rowElement && rowElement.rowIndex;
                    var cellIndex = map.width * rowIndex + colIndex;
                    var posInTable = map.map[cellIndex + 1] - 1;
                    var dispatch = view.dispatch, _a = view.state, tr = _a.tr, paragraph = _a.schema.nodes.paragraph;
                    var editorElement = table.node.nodeAt(map.map[cellIndex]);
                    /** Only if the last item is media group, insert a paragraph */
                    if (_1.isLastItemMediaGroup(editorElement)) {
                        tr.insert(posInTable + table.pos, paragraph.create());
                        dispatch(tr);
                        _1.setNodeSelection(view, posInTable + table.pos);
                    }
                    return true;
                },
                blur: function (view, event) {
                    var pluginState = exports.stateKey.getState(view.state);
                    pluginState.updateEditorFocused(false);
                    var dirty = pluginState.update();
                    if (dirty) {
                        dispatch(exports.stateKey, tslib_1.__assign({}, pluginState));
                    }
                    actions_1.resetHoverSelection(view.state, view.dispatch);
                    return false;
                },
            },
        },
    });
};
//# sourceMappingURL=main.js.map