"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var prosemirror_state_1 = require("prosemirror-state");
var prosemirror_view_1 = require("prosemirror-view");
var prosemirror_tables_1 = require("prosemirror-tables");
var prosemirror_utils_1 = require("prosemirror-utils");
var hover_selection_plugin_1 = require("./pm-plugins/hover-selection-plugin");
var main_1 = require("./pm-plugins/main");
var utils_1 = require("./utils");
var analytics_1 = require("../../analytics");
exports.resetHoverSelection = function (state, dispatch) {
    dispatch(state.tr.setMeta(hover_selection_plugin_1.pluginKey, {
        decorationSet: prosemirror_view_1.DecorationSet.empty,
        isTableHovered: false,
    }));
    return true;
};
exports.hoverColumns = function (columns, danger) { return function (state, dispatch) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (table) {
        var cells = columns.reduce(function (acc, colIdx) {
            var colCells = prosemirror_utils_1.getCellsInColumn(colIdx)(state.selection);
            return colCells ? acc.concat(colCells) : acc;
        }, []);
        dispatch(state.tr.setMeta(hover_selection_plugin_1.pluginKey, {
            decorationSet: utils_1.createHoverDecorationSet(cells, state, danger),
        }));
        return true;
    }
    return false;
}; };
exports.hoverRows = function (rows, danger) { return function (state, dispatch) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (table) {
        var cells = rows.reduce(function (acc, rowIdx) {
            var rowCells = prosemirror_utils_1.getCellsInRow(rowIdx)(state.selection);
            return rowCells ? acc.concat(rowCells) : acc;
        }, []);
        dispatch(state.tr.setMeta(hover_selection_plugin_1.pluginKey, {
            decorationSet: utils_1.createHoverDecorationSet(cells, state, danger),
        }));
        return true;
    }
    return false;
}; };
exports.hoverTable = function (danger) { return function (state, dispatch) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (table) {
        var cells = prosemirror_utils_1.getCellsInTable(state.selection);
        dispatch(state.tr.setMeta(hover_selection_plugin_1.pluginKey, {
            decorationSet: utils_1.createHoverDecorationSet(cells, state, danger),
            isTableHovered: true,
            isTableInDanger: danger,
        }));
        return true;
    }
    return false;
}; };
exports.clearHoverTable = function (state, dispatch) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (table) {
        dispatch(state.tr.setMeta(hover_selection_plugin_1.pluginKey, {
            decorationSet: prosemirror_view_1.DecorationSet.empty,
            isTableHovered: false,
            isTableInDanger: false,
        }));
        return true;
    }
    return false;
};
exports.clearSelection = function (state, dispatch) {
    dispatch(state.tr.setSelection(prosemirror_state_1.Selection.near(state.selection.$from)));
    return true;
};
exports.toggleHeaderRow = function (state, dispatch) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (!table) {
        return false;
    }
    var tr = state.tr;
    var map = prosemirror_tables_1.TableMap.get(table.node);
    var _a = state.schema.nodes, tableHeader = _a.tableHeader, tableCell = _a.tableCell;
    var isNumberColumnEnabled = table.node.attrs.isNumberColumnEnabled;
    var isHeaderRowEnabled = utils_1.checkIfHeaderRowEnabled(state);
    var isHeaderColumnEnabled = utils_1.checkIfHeaderColumnEnabled(state);
    var type = isHeaderRowEnabled ? tableCell : tableHeader;
    for (var column = 0; column < table.node.child(0).childCount; column++) {
        // skip header column
        if (isHeaderColumnEnabled &&
            ((isNumberColumnEnabled && column === 1) ||
                (!isNumberColumnEnabled && column === 0))) {
            continue;
        }
        var from = tr.mapping.map(table.pos + map.map[column]);
        var cell = table.node.child(0).child(column);
        // empty first cell of the number column when converting to header row (remove "1")
        if (!isHeaderRowEnabled && isNumberColumnEnabled && column === 0) {
            tr.replaceWith(from, from + cell.nodeSize, tableHeader.createAndFill(cell.attrs));
        }
        else {
            tr.setNodeMarkup(from, type, cell.attrs);
        }
    }
    dispatch(tr);
    return true;
};
exports.toggleHeaderColumn = function (state, dispatch) {
    var table = prosemirror_utils_1.findTable(state.selection);
    if (!table) {
        return false;
    }
    var tr = state.tr;
    var map = prosemirror_tables_1.TableMap.get(table.node);
    var _a = state.schema.nodes, tableHeader = _a.tableHeader, tableCell = _a.tableCell;
    var type = utils_1.checkIfHeaderColumnEnabled(state) ? tableCell : tableHeader;
    // skip header row
    var startIndex = utils_1.checkIfHeaderRowEnabled(state) ? 1 : 0;
    for (var row = startIndex; row < table.node.childCount; row++) {
        var column = table.node.attrs.isNumberColumnEnabled ? 1 : 0;
        var cell = table.node.child(row).child(column);
        tr.setNodeMarkup(table.pos + map.map[column + row * map.width], type, cell.attrs);
    }
    dispatch(tr);
    return true;
};
exports.toggleNumberColumn = function (state, dispatch) {
    var tr = state.tr;
    var tableNode = main_1.stateKey.getState(state).tableNode;
    var map = prosemirror_tables_1.TableMap.get(tableNode);
    var start = prosemirror_utils_1.findTable(state.selection).pos;
    if (tableNode.attrs.isNumberColumnEnabled) {
        // delete existing number column
        var mapStart = tr.mapping.maps.length;
        for (var i = 0, count = tableNode.childCount; i < count; i++) {
            var cell = tableNode.child(i).child(0);
            var pos = map.positionAt(i, 0, tableNode);
            var from = tr.mapping.slice(mapStart).map(start + pos);
            tr.delete(from, from + cell.nodeSize);
        }
        tr.setNodeMarkup(start - 1, state.schema.nodes.table, tslib_1.__assign({}, tableNode.attrs, { isNumberColumnEnabled: false }));
        dispatch(tr);
    }
    else {
        // insert number column
        var index = 1;
        var inserted = false;
        var _a = state.schema.nodes, tableHeader = _a.tableHeader, tableCell = _a.tableCell, paragraph = _a.paragraph;
        var isHeaderRowEnabled = utils_1.checkIfHeaderRowEnabled(state);
        for (var i = 0, count = tableNode.childCount; i < count; i++) {
            var cell = tableNode.child(i).child(0);
            var from = map.positionAt(i, 0, tableNode);
            var content = cell.type === tableHeader && i === 0
                ? null
                : paragraph.createChecked({}, state.schema.text("" + index++));
            var type = isHeaderRowEnabled && i === 0 ? tableHeader : tableCell;
            if (content) {
                inserted = true;
            }
            tr.insert(tr.mapping.map(start + from), type.create({}, content));
        }
        if (inserted) {
            tr.setNodeMarkup(start - 1, state.schema.nodes.table, tslib_1.__assign({}, tableNode.attrs, { isNumberColumnEnabled: true }));
            dispatch(tr);
        }
    }
    return true;
};
exports.setCellAttr = function (name, value) { return function (state, dispatch) {
    var tr = state.tr;
    var cellSelection = utils_1.getCellSelection(state);
    if (cellSelection) {
        var updated_1 = false;
        cellSelection.forEachCell(function (cell, pos) {
            if (cell.attrs[name] !== value) {
                tr.setNodeMarkup(pos, cell.type, tslib_1.__assign({}, cell.attrs, (_a = {}, _a[name] = value, _a)));
                updated_1 = true;
            }
            var _a;
        });
        if (updated_1) {
            dispatch(tr);
            return true;
        }
    }
    else {
        var cell = prosemirror_tables_1.selectionCell(state);
        if (cell) {
            dispatch(tr.setNodeMarkup(cell.pos, cell.nodeAfter.type, tslib_1.__assign({}, cell.nodeAfter.attrs, (_a = {}, _a[name] = value, _a))));
            return true;
        }
    }
    return false;
    var _a;
}; };
exports.insertColumn = function (column) { return function (state, dispatch) {
    var tr = prosemirror_utils_1.addColumnAt(column)(state.tr);
    var table = prosemirror_utils_1.findTable(tr.selection);
    // move the cursor to the newly created column
    var pos = prosemirror_tables_1.TableMap.get(table.node).positionAt(0, column, table.node);
    dispatch(tr.setSelection(prosemirror_state_1.Selection.near(tr.doc.resolve(table.pos + pos))));
    analytics_1.analyticsService.trackEvent('atlassian.editor.format.table.column.button');
    return true;
}; };
exports.insertRow = function (row) { return function (state, dispatch) {
    var tr = prosemirror_utils_1.addRowAt(row)(state.tr);
    var table = prosemirror_utils_1.findTable(tr.selection);
    // move the cursor to the newly created row
    var pos = prosemirror_tables_1.TableMap.get(table.node).positionAt(row, 0, table.node);
    dispatch(tr.setSelection(prosemirror_state_1.Selection.near(tr.doc.resolve(table.pos + pos))));
    analytics_1.analyticsService.trackEvent('atlassian.editor.format.table.row.button');
    return true;
}; };
//# sourceMappingURL=actions.js.map