"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_keymap_1 = require("prosemirror-keymap");
var prosemirror_model_1 = require("prosemirror-model");
var prosemirror_state_1 = require("prosemirror-state");
var MarkdownIt = require("markdown-it");
var editor_markdown_transformer_1 = require("@atlaskit/editor-markdown-transformer");
var analytics_1 = require("../../../analytics");
var keymaps = require("../../../keymaps");
var clipboard = require("../../../utils/clipboard");
var main_1 = require("../../table/pm-plugins/main");
var utils_1 = require("../../table/utils");
var macro_1 = require("../../macro");
var media_single_1 = require("../../media/utils/media-single");
var linkify_md_plugin_1 = require("../linkify-md-plugin");
var util_1 = require("../util");
var actions_1 = require("../../extension/actions");
var utils_2 = require("../../layout/utils");
var utils_3 = require("../../hyperlink/utils");
var utils_4 = require("../../../utils");
var prosemirror_history_1 = require("prosemirror-history");
exports.stateKey = new prosemirror_state_1.PluginKey('pastePlugin');
function createPlugin(schema, editorAppearance) {
    var atlassianMarkDownParser;
    var md = MarkdownIt('zero', { html: false });
    md.enable([
        // Process html entity - &#123;, &#xAF;, &quot;, ...
        'entity',
        // Process escaped chars and hardbreaks
        'escape',
    ]);
    // enable modified version of linkify plugin
    // @see https://product-fabric.atlassian.net/browse/ED-3097
    md.use(linkify_md_plugin_1.default);
    atlassianMarkDownParser = new editor_markdown_transformer_1.MarkdownTransformer(schema, md);
    return new prosemirror_state_1.Plugin({
        key: exports.stateKey,
        props: {
            handlePaste: function (view, event, slice) {
                if (!event.clipboardData) {
                    return false;
                }
                // Bail if copied content has files
                if (clipboard.isPastedFile(event)) {
                    return true;
                }
                slice = utils_2.removeLayoutsIfSelectionIsInLayout(slice, view.state);
                // currently bodiedExtension -> bodiedExtension nesting is restricted in schema, but PM does wraps nested bodiedExtension node with a table to workaround the restriction.
                // that allows us to have infinite nesting: bodiedExtension -> table -> bodiedExtension
                // this function makes sure we prevent that weirdness
                slice = actions_1.removeBodiedExtensionsIfSelectionIsInBodiedExtension(slice, view.state);
                var _a = view.state.selection, $to = _a.$to, $from = _a.$from;
                // In case of SHIFT+CMD+V ("Paste and Match Style") we don't want to run the usual
                // fuzzy matching of content. ProseMirror already handles this scenario and will
                // provide us with slice containing paragraphs with plain text, which we decorate
                // with "stored marks".
                // @see prosemirror-view/src/clipboard.js:parseFromClipboard()).
                // @see prosemirror-view/src/input.js:doPaste().
                if (view.shiftKey) {
                    // <- using the same internal flag that prosemirror-view is using
                    analytics_1.analyticsService.trackEvent('atlassian.editor.paste.alt');
                    var tr_1 = prosemirror_history_1.closeHistory(view.state.tr);
                    tr_1.replaceSelection(slice);
                    var storedMarks = view.state.storedMarks;
                    if (storedMarks && storedMarks.length) {
                        storedMarks.forEach(function (mark) {
                            return (tr_1 = tr_1.addMark($from.pos, $from.pos + slice.size, mark));
                        });
                    }
                    view.dispatch(tr_1.scrollIntoView());
                    return true;
                }
                var text = event.clipboardData.getData('text/plain');
                var html = event.clipboardData.getData('text/html');
                var node = slice.content.firstChild;
                // runs macro autoconvert prior to other conversions
                if (text && !html) {
                    var macro = macro_1.runMacroAutoConvert(view.state, text);
                    if (macro) {
                        view.dispatch(prosemirror_history_1.closeHistory(view.state.tr)
                            .replaceSelectionWith(macro)
                            .scrollIntoView());
                        return true;
                    }
                }
                var schema = view.state.schema;
                var selectedNode = $from.node($from.depth);
                // If we're in a code block, append the text contents of clipboard inside it
                if (text && selectedNode.type === schema.nodes.codeBlock) {
                    view.dispatch(prosemirror_history_1.closeHistory(view.state.tr).insertText(text));
                    return true;
                }
                /** If a partial paste of bodied extension, paste only text */
                if (node &&
                    node.type === schema.nodes.bodiedExtension &&
                    utils_4.hasOpenEnd(slice)) {
                    slice = actions_1.removeBodiedExtensionWrapper(view.state, slice);
                }
                if (editorAppearance !== 'message' &&
                    node &&
                    node.type === schema.nodes.media) {
                    return media_single_1.insertMediaAsMediaSingle(view, node);
                }
                // If the clipboard contents looks like computer code, create a code block
                // Note: Disabling (text && isCode(text)) check (@see ED-4092) until we decide how to improve it (possibly adding the ability to undo)
                if (text && html && node && node.type === schema.nodes.codeBlock) {
                    analytics_1.analyticsService.trackEvent('atlassian.editor.paste.code');
                    var tr = prosemirror_history_1.closeHistory(view.state.tr);
                    if (util_1.isSingleLine(text)) {
                        var currentNode = $to.node($to.depth);
                        var nodeText = currentNode && currentNode.textContent;
                        var from = $from.pos;
                        if (nodeText && nodeText[nodeText.length - 1] === '`') {
                            tr = tr.delete($to.pos - 1, $to.pos);
                            from -= 1;
                        }
                        tr = tr.insertText(text);
                        tr = tr.addMark(from, $from.pos + text.length, schema.marks.code.create());
                        var code_1 = view.state.schema.marks.code;
                        // ED-4299, if a new code mark is created by pasting cursor should be moved out of it.
                        if (!$to.marks().some(function (mark) { return mark.type === code_1; })) {
                            tr = tr.removeStoredMark(code_1);
                        }
                    }
                    else {
                        var codeBlockNode = schema.nodes.codeBlock.create(node ? node.attrs : {}, schema.text(text));
                        tr = tr.replaceSelectionWith(codeBlockNode);
                        // ED-4299, If code-block is created at end of its parent a paragraph is added after it.
                        // Selection is moved position after pasted code.
                        if ($to.pos + 1 === $to.end($to.depth - 1)) {
                            var paragraph = view.state.schema.nodes.paragraph;
                            var newSel = tr.selection.$to;
                            tr = tr.insert(newSel.end(newSel.depth - 1), paragraph.createAndFill());
                        }
                        tr = tr.setSelection(new prosemirror_state_1.TextSelection(tr.doc.resolve($to.pos + codeBlockNode.nodeSize)));
                    }
                    view.dispatch(tr.scrollIntoView());
                    return true;
                }
                // If the clipboard only contains plain text, attempt to parse it as Markdown
                if (text && !html && atlassianMarkDownParser) {
                    analytics_1.analyticsService.trackEvent('atlassian.editor.paste.markdown');
                    var doc = atlassianMarkDownParser.parse(util_1.escapeLinks(text));
                    if (doc && doc.content) {
                        var tr = prosemirror_history_1.closeHistory(view.state.tr);
                        tr.replaceSelection(new prosemirror_model_1.Slice(doc.content, slice.openStart, slice.openEnd));
                        view.dispatch(tr.scrollIntoView());
                        return true;
                    }
                }
                // If the clipboard contains rich text, pass it through the schema and import what's allowed.
                if (html) {
                    var tableState = main_1.stateKey.getState(view.state);
                    if (tableState &&
                        tableState.isRequiredToAddHeader() &&
                        utils_1.containsTable(view.state, slice)) {
                        var selectionStart = view.state.selection.$from.pos;
                        view.dispatch(prosemirror_history_1.closeHistory(view.state.tr).replaceSelection(slice));
                        tableState.addHeaderToTableNodes(slice, selectionStart);
                        return true;
                    }
                    slice = utils_3.linkifyContent(view.state.schema, slice) || slice;
                    view.dispatch(prosemirror_history_1.closeHistory(view.state.tr)
                        .replaceSelection(slice)
                        .setStoredMarks([]));
                    return true;
                }
                return false;
            },
            transformPasted: function (slice) {
                // We do this separately so it also applies to drag/drop events
                slice = utils_2.transformSliceToRemoveOpenLayoutNodes(slice, schema);
                return slice;
            },
        },
    });
}
exports.createPlugin = createPlugin;
function createKeymapPlugin(schema) {
    var list = {};
    keymaps.bindKeymapWithCommand(keymaps.paste.common, function (state, dispatch) {
        analytics_1.analyticsService.trackEvent('atlassian.editor.paste');
        return false;
    }, list);
    keymaps.bindKeymapWithCommand(keymaps.altPaste.common, function (state, dispatch) {
        analytics_1.analyticsService.trackEvent('atlassian.editor.paste');
        return false;
    }, list);
    return prosemirror_keymap_1.keymap(list);
}
exports.createKeymapPlugin = createKeymapPlugin;
exports.default = function (schema, editorAppearance) { return [
    createPlugin(schema, editorAppearance),
    createKeymapPlugin(schema),
]; };
//# sourceMappingURL=main.js.map