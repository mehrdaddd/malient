"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var prosemirror_state_1 = require("prosemirror-state");
var utils_1 = require("../utils");
var main_1 = require("../pm-plugins/main");
exports.moveRight = function () {
    return function (state, dispatch) {
        var code = state.schema.marks.code;
        var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor;
        if (!empty || !$cursor) {
            return false;
        }
        var storedMarks = state.tr.storedMarks;
        var insideCode = main_1.stateKey.getState(state).markActive(code.create());
        var currentPosHasCode = state.doc.rangeHasMark($cursor.pos, $cursor.pos, code);
        var nextPosHasCode = state.doc.rangeHasMark($cursor.pos, $cursor.pos + 1, code);
        var exitingCode = !currentPosHasCode &&
            !nextPosHasCode &&
            (!storedMarks || !!storedMarks.length);
        var enteringCode = !currentPosHasCode &&
            nextPosHasCode &&
            (!storedMarks || !storedMarks.length);
        // entering code mark (from the left edge): don't move the cursor, just add the mark
        if (!insideCode && enteringCode) {
            dispatch(state.tr.addStoredMark(code.create()));
            return true;
        }
        // exiting code mark: don't move the cursor, just remove the mark
        if (insideCode && exitingCode) {
            dispatch(state.tr.removeStoredMark(code));
            return true;
        }
        return false;
    };
};
exports.moveLeft = function (view) {
    return function (state, dispatch) {
        var code = state.schema.marks.code;
        var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor;
        if (!empty || !$cursor) {
            return false;
        }
        var storedMarks = state.tr.storedMarks;
        var insideCode = main_1.stateKey.getState(state).markActive(code.create());
        var currentPosHasCode = utils_1.hasCode(state, $cursor.pos);
        var nextPosHasCode = utils_1.hasCode(state, $cursor.pos - 1);
        var nextNextPosHasCode = utils_1.hasCode(state, $cursor.pos - 2);
        var exitingCode = currentPosHasCode && !nextPosHasCode && Array.isArray(storedMarks);
        var atLeftEdge = nextPosHasCode &&
            !nextNextPosHasCode &&
            (storedMarks === null ||
                (Array.isArray(storedMarks) && !!storedMarks.length));
        var atRightEdge = ((exitingCode && Array.isArray(storedMarks) && !storedMarks.length) ||
            (!exitingCode && storedMarks === null)) &&
            !nextPosHasCode &&
            nextNextPosHasCode;
        var enteringCode = !currentPosHasCode &&
            nextPosHasCode &&
            Array.isArray(storedMarks) &&
            !storedMarks.length;
        // removing ignored nodes (cursor wrapper) to make sure cursor isn't stuck
        if (view.cursorWrapper && !atLeftEdge && !atRightEdge) {
            utils_1.removeIgnoredNodesLeft(view);
        }
        // at the right edge: remove code mark and move the cursor to the left
        if (!insideCode && atRightEdge) {
            var tr = state.tr.setSelection(prosemirror_state_1.Selection.near(state.doc.resolve($cursor.pos - 1)));
            dispatch(tr.removeStoredMark(code));
            return true;
        }
        // entering code mark (from right edge): don't move the cursor, just add the mark
        if (!insideCode && enteringCode) {
            dispatch(state.tr.addStoredMark(code.create()));
            return true;
        }
        // at the left edge: add code mark and move the cursor to the left
        if (insideCode && atLeftEdge) {
            var tr = state.tr.setSelection(prosemirror_state_1.Selection.near(state.doc.resolve($cursor.pos - 1)));
            dispatch(tr.addStoredMark(code.create()));
            return true;
        }
        // exiting code mark (or at the beginning of the line): don't move the cursor, just remove the mark
        var isFirstChild = $cursor.index($cursor.depth - 1) === 0;
        if (insideCode && (exitingCode || (!$cursor.nodeBefore && isFirstChild))) {
            dispatch(state.tr.removeStoredMark(code));
            return true;
        }
        return false;
    };
};
// removing ignored nodes (cursor wrapper) when pressing Backspace to make sure cursor isn't stuck
exports.removeIgnoredNodes = function (view) {
    return function (state, dispatch) {
        var _a = state.selection, empty = _a.empty, $cursor = _a.$cursor;
        if (empty && $cursor && $cursor.nodeBefore) {
            utils_1.removeIgnoredNodesLeft(view);
        }
        return false;
    };
};
//# sourceMappingURL=text-formatting.js.map