"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var assert = require("assert");
var React = require("react");
var ReactDOM = require("react-dom");
var prosemirror_transform_1 = require("prosemirror-transform");
var prosemirror_view_1 = require("prosemirror-view");
var prosemirror_state_1 = require("prosemirror-state");
var editor_common_1 = require("@atlaskit/editor-common");
var service_1 = require("../../../analytics/service");
var utils_1 = require("../../../utils");
var DropPlaceholder_1 = require("../ui/Media/DropPlaceholder");
var media_links_1 = require("../utils/media-links");
var media_files_1 = require("../utils/media-files");
var media_common_1 = require("../utils/media-common");
var picker_facade_loader_1 = require("../picker-facade-loader");
var default_state_manager_1 = require("../default-state-manager");
exports.DefaultMediaStateManager = default_state_manager_1.default;
var media_single_1 = require("../utils/media-single");
var prosemirror_utils_1 = require("prosemirror-utils");
// We get `publicId` of `file` in `processing` stage so it's possible to send
// consumers a ADF with media-ids before ready state
var MEDIA_RESOLVED_STATES = ['ready', 'error', 'cancelled', 'processing'];
var MediaPluginState = /** @class */ (function () {
    function MediaPluginState(state, options, editorAppearance) {
        var _this = this;
        this.allowsMedia = false;
        this.allowsUploads = false;
        this.allowsLinks = false;
        this.ignoreLinks = false;
        this.waitForMediaUpload = true;
        this.allUploadsFinished = true;
        this.showDropzone = false;
        this.layout = 'center';
        this.mediaNodes = [];
        this.pendingTask = Promise.resolve(null);
        this.pluginStateChangeSubscribers = [];
        this.useDefaultStateManager = true;
        this.destroyed = false;
        this.pickers = [];
        this.removeOnCloseListener = function () { };
        this.setMediaProvider = function (mediaProvider) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var resolvedMediaProvider, Picker, err_1, wrappedError, stateManager, _a, view, allowsUploads, uploadContext, _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!mediaProvider) {
                            this.destroyPickers();
                            this.allowsLinks = false;
                            this.allowsUploads = false;
                            this.allowsMedia = false;
                            this.notifyPluginStateSubscribers();
                            return [2 /*return*/];
                        }
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.all([
                                mediaProvider,
                                picker_facade_loader_1.default(),
                            ])];
                    case 2:
                        _b = _c.sent(), resolvedMediaProvider = _b[0], Picker = _b[1];
                        assert(resolvedMediaProvider && resolvedMediaProvider.viewContext, "MediaProvider promise did not resolve to a valid instance of MediaProvider - " + resolvedMediaProvider);
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _c.sent();
                        wrappedError = new Error("Media functionality disabled due to rejected provider: " + err_1.message);
                        this.errorReporter.captureException(wrappedError);
                        this.destroyPickers();
                        this.allowsLinks = false;
                        this.allowsUploads = false;
                        this.allowsMedia = false;
                        this.notifyPluginStateSubscribers();
                        return [2 /*return*/];
                    case 4:
                        this.mediaProvider = resolvedMediaProvider;
                        this.allowsMedia = true;
                        stateManager = resolvedMediaProvider.stateManager;
                        if (stateManager && this.useDefaultStateManager) {
                            stateManager.destroy();
                            this.useDefaultStateManager = false;
                        }
                        if (stateManager) {
                            this.stateManager = stateManager;
                        }
                        this.allowsLinks = !!resolvedMediaProvider.linkCreateContext;
                        this.allowsUploads = !!resolvedMediaProvider.uploadContext;
                        _a = this, view = _a.view, allowsUploads = _a.allowsUploads;
                        // make sure editable DOM node is mounted
                        if (view.dom.parentNode) {
                            // make PM plugin aware of the state change to update UI during 'apply' hook
                            view.dispatch(view.state.tr.setMeta(exports.stateKey, { allowsUploads: allowsUploads }));
                        }
                        if (!this.allowsUploads) return [3 /*break*/, 6];
                        return [4 /*yield*/, resolvedMediaProvider.uploadContext];
                    case 5:
                        uploadContext = _c.sent();
                        if (resolvedMediaProvider.uploadParams && uploadContext) {
                            this.initPickers(resolvedMediaProvider.uploadParams, uploadContext, Picker);
                        }
                        else {
                            this.destroyPickers();
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        this.destroyPickers();
                        _c.label = 7;
                    case 7:
                        this.notifyPluginStateSubscribers();
                        return [2 /*return*/];
                }
            });
        }); };
        this.updateUploadStateDebounce = null;
        this.insertFile = function (mediaState) {
            // tslint:disable-next-line:no-console
            console.warn('This API is deprecated. Please use insertFiles(mediaStates: MediaState[]) instead');
            _this.insertFiles([mediaState]);
        };
        this.insertFiles = function (mediaStates) {
            var stateManager = _this.stateManager;
            var mediaSingle = _this.view.state.schema.nodes.mediaSingle;
            var collection = _this.collectionFromProvider();
            if (!collection) {
                return;
            }
            var imageAttachments = mediaStates.filter(function (media) {
                return utils_1.isImage(media.fileMimeType);
            });
            var nonImageAttachements = mediaStates.filter(function (media) { return !utils_1.isImage(media.fileMimeType); });
            var grandParentNode = _this.view.state.selection.$from.node(-1);
            // in case of gap cursor, selection might be at depth=0
            if (grandParentNode && media_files_1.isNonImagesBanned(grandParentNode)) {
                nonImageAttachements = [];
            }
            mediaStates.forEach(function (mediaState) {
                return _this.stateManager.on(mediaState.id, _this.handleMediaState);
            });
            if (_this.editorAppearance !== 'message' && mediaSingle) {
                media_files_1.insertMediaGroupNode(_this.view, nonImageAttachements, collection);
                imageAttachments.forEach(function (mediaState) {
                    media_single_1.insertMediaSingleNode(_this.view, mediaState, collection);
                });
            }
            else {
                media_files_1.insertMediaGroupNode(_this.view, mediaStates, collection);
            }
            var isEndState = function (state) {
                return state.status && MEDIA_RESOLVED_STATES.indexOf(state.status) !== -1;
            };
            _this.pendingTask = mediaStates
                .filter(function (state) { return !isEndState(state); })
                .reduce(function (promise, state) {
                // Chain the previous promise with a new one for this media item
                return new Promise(function (resolve, reject) {
                    var onStateChange = function (newState) {
                        // When media item reaches its final state, remove listener and resolve
                        if (isEndState(newState)) {
                            stateManager.off(state.id, onStateChange);
                            resolve(newState);
                        }
                    };
                    stateManager.on(state.id, onStateChange);
                }).then(function () { return promise; });
            }, _this.pendingTask);
            var view = _this.view;
            if (!view.hasFocus()) {
                view.focus();
            }
        };
        this.insertLinks = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var mediaProvider, linkCreateContext, linkCreateContextInstance;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mediaProvider = this.mediaProvider;
                        if (!mediaProvider) {
                            return [2 /*return*/];
                        }
                        linkCreateContext = this.mediaProvider.linkCreateContext;
                        if (!linkCreateContext) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, linkCreateContext];
                    case 1:
                        linkCreateContextInstance = _a.sent();
                        if (!linkCreateContextInstance) {
                            return [2 /*return*/];
                        }
                        return [2 /*return*/, media_links_1.insertLinks(this.view, this.stateManager, this.handleMediaState, this.linkRanges, linkCreateContextInstance, this.collectionFromProvider())];
                }
            });
        }); };
        this.splitMediaGroup = function () { return media_common_1.splitMediaGroup(_this.view); };
        this.insertFileFromDataUrl = function (url, fileName) {
            var binaryPicker = _this.binaryPicker;
            assert(binaryPicker, 'Unable to insert file because media pickers have not been initialized yet');
            binaryPicker.upload(url, fileName);
        };
        // TODO [MSW-454]: remove this logic from Editor
        this.onPopupPickerClose = function () {
            if (_this.dropzonePicker) {
                _this.dropzonePicker.activate();
            }
        };
        this.showMediaPicker = function () {
            if (!_this.popupPicker) {
                return;
            }
            if (_this.dropzonePicker) {
                _this.dropzonePicker.deactivate();
            }
            _this.popupPicker.show();
        };
        /**
         * Returns a promise that is resolved after all pending operations have been finished.
         * An optional timeout will cause the promise to reject if the operation takes too long
         *
         * NOTE: The promise will resolve even if some of the media have failed to process.
         */
        this.waitForPendingTasks = function (timeout, lastTask) {
            if (lastTask && _this.pendingTask === lastTask) {
                return lastTask;
            }
            var chainedPromise = _this.pendingTask.then(function () {
                // Call ourselves to make sure that no new pending tasks have been
                // added before the current promise has resolved.
                return _this.waitForPendingTasks(undefined, _this.pendingTask);
            });
            if (!timeout) {
                return chainedPromise;
            }
            var rejectTimeout;
            var timeoutPromise = new Promise(function (resolve, reject) {
                rejectTimeout = setTimeout(function () {
                    return reject(new Error("Media operations did not finish in " + timeout + " ms"));
                }, timeout);
            });
            return Promise.race([
                timeoutPromise,
                chainedPromise.then(function () {
                    clearTimeout(rejectTimeout);
                }),
            ]);
        };
        /**
         * Called from React UI Component when user clicks on "Delete" icon
         * inside of it
         */
        this.handleMediaNodeRemoval = function (node, getPos) {
            media_common_1.removeMediaNode(_this.view, node, getPos);
        };
        /**
         * Called from React UI Component on componentDidMount
         */
        this.handleMediaNodeMount = function (node, getPos) {
            _this.mediaNodes.push({ node: node, getPos: getPos });
        };
        /**
         * Called from React UI Component on componentWillUnmount and componentWillReceiveProps
         * when React component's underlying node property is replaced with a new node
         */
        this.handleMediaNodeUnmount = function (oldNode) {
            _this.mediaNodes = _this.mediaNodes.filter(function (_a) {
                var node = _a.node;
                return oldNode !== node;
            });
        };
        this.align = function (layout) {
            if (!_this.selectedMediaNode()) {
                return false;
            }
            var _a = _this.view.state, from = _a.selection.from, schema = _a.schema, tr = _a.tr;
            _this.view.dispatch(tr.setNodeMarkup(from - 1, schema.nodes.mediaSingle, {
                layout: layout,
            }));
            return true;
        };
        this.findMediaNode = function (id) {
            var mediaNodes = _this.mediaNodes;
            // Array#find... no IE support
            return mediaNodes.reduce(function (memo, nodeWithPos) {
                if (memo) {
                    return memo;
                }
                var node = nodeWithPos.node;
                if (node.attrs.id === id) {
                    return nodeWithPos;
                }
                return memo;
            }, null);
        };
        this.detectLinkRangesInSteps = function (tr, oldState) {
            var link = _this.view.state.schema.marks.link;
            _this.linkRanges = [];
            if (_this.ignoreLinks) {
                _this.ignoreLinks = false;
                return _this.linkRanges;
            }
            if (!link || !_this.allowsLinks) {
                return _this.linkRanges;
            }
            _this.linkRanges = media_links_1.detectLinkRangesInSteps(tr, link, oldState.selection.$anchor.pos);
        };
        this.destroyPickers = function () {
            var pickers = _this.pickers;
            pickers.forEach(function (picker) { return picker.destroy(); });
            pickers.splice(0, pickers.length);
            _this.popupPicker = undefined;
            _this.binaryPicker = undefined;
            _this.clipboardPicker = undefined;
            _this.dropzonePicker = undefined;
            _this.customPicker = undefined;
        };
        this.handleMediaState = function (state) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, uploadErrorHandler, viewContext;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = state.status;
                        switch (_a) {
                            case 'error': return [3 /*break*/, 1];
                            case 'preview': return [3 /*break*/, 2];
                            case 'processing': return [3 /*break*/, 3];
                            case 'ready': return [3 /*break*/, 6];
                        }
                        return [3 /*break*/, 7];
                    case 1:
                        this.removeNodeById(state.id);
                        uploadErrorHandler = this.options.uploadErrorHandler;
                        if (uploadErrorHandler) {
                            uploadErrorHandler(state);
                        }
                        return [3 /*break*/, 7];
                    case 2:
                        this.replaceTemporaryNode(state);
                        if (state.ready) {
                            this.stateManager.off(state.id, this.handleMediaState);
                        }
                        return [3 /*break*/, 7];
                    case 3:
                        if (!(state.thumbnail && state.publicId)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.mediaProvider.viewContext];
                    case 4:
                        viewContext = _b.sent();
                        // This allows Cards to use local preview while they fetch the remote one
                        viewContext.setLocalPreview(state.publicId, state.thumbnail.src);
                        _b.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        if (state.publicId && this.nodeHasNoPublicId(state)) {
                            this.replaceTemporaryNode(state);
                        }
                        if (state.preview) {
                            this.stateManager.off(state.id, this.handleMediaState);
                        }
                        return [3 /*break*/, 7];
                    case 7: return [2 /*return*/];
                }
            });
        }); };
        this.notifyPluginStateSubscribers = function () {
            _this.pluginStateChangeSubscribers.forEach(function (cb) { return cb.call(cb, _this); });
        };
        this.nodeHasNoPublicId = function (state) {
            var id = state.id;
            var mediaNodeWithPos = _this.findMediaNode(id);
            if (!mediaNodeWithPos) {
                return;
            }
            var mediaNodeId = mediaNodeWithPos.node.attrs.id;
            return mediaNodeId.match(/^temporary:/);
        };
        this.removeNodeById = function (id) {
            // TODO: we would like better error handling and retry support here.
            var mediaNodeWithPos = _this.findMediaNode(id);
            if (mediaNodeWithPos) {
                media_common_1.removeMediaNode(_this.view, mediaNodeWithPos.node, mediaNodeWithPos.getPos);
            }
        };
        this.replaceTemporaryNode = function (state) {
            var view = _this.view;
            if (!view) {
                return;
            }
            var id = state.id, thumbnail = state.thumbnail, fileName = state.fileName, fileSize = state.fileSize, publicId = state.publicId;
            var mediaNodeWithPos = _this.findMediaNode(id);
            if (!mediaNodeWithPos) {
                return;
            }
            var _a = (thumbnail && thumbnail.dimensions) || {
                width: undefined,
                height: undefined,
            }, width = _a.width, height = _a.height;
            var getPos = mediaNodeWithPos.getPos, mediaNode = mediaNodeWithPos.node;
            var newNode = view.state.schema.nodes.media.create(tslib_1.__assign({}, mediaNode.attrs, { id: publicId || id, width: width,
                height: height, __fileName: fileName, __fileSize: fileSize }));
            // Copy all optional attributes from old node
            editor_common_1.copyPrivateMediaAttributes(mediaNode.attrs, newNode.attrs);
            // replace the old node with a new one
            var nodePos = getPos();
            var tr = view.state.tr.replaceWith(nodePos, nodePos + mediaNode.nodeSize, newNode);
            view.dispatch(tr.setMeta('addToHistory', false));
        };
        this.removeSelectedMediaNode = function () {
            var view = _this.view;
            if (_this.selectedMediaNode()) {
                var _a = view.state.selection, from_1 = _a.from, node = _a.node;
                media_common_1.removeMediaNode(view, node, function () { return from_1; });
                return true;
            }
            return false;
        };
        /**
         * Since we replace nodes with public id when node is finalized
         * stateManager contains no information for public ids
         */
        this.getMediaNodeStateStatus = function (id) {
            var state = _this.getMediaNodeState(id);
            return (state && state.status) || 'ready';
        };
        this.getMediaNodeState = function (id) {
            return _this.stateManager.getState(id);
        };
        this.handleDrag = function (dragState) {
            var isActive = dragState === 'enter';
            if (_this.showDropzone === isActive) {
                return;
            }
            _this.showDropzone = isActive;
            var _a = _this.view, dispatch = _a.dispatch, state = _a.state;
            // Trigger state change to be able to pick it up in the decorations handler
            dispatch(state.tr);
        };
        this.options = options;
        this.editorAppearance = editorAppearance;
        this.waitForMediaUpload =
            options.waitForMediaUpload === undefined
                ? true
                : options.waitForMediaUpload;
        var nodes = state.schema.nodes;
        assert(nodes.media && (nodes.mediaGroup || nodes.mediaSingle), 'Editor: unable to init media plugin - media or mediaGroup/mediaSingle node absent in schema');
        this.stateManager = new default_state_manager_1.default();
        options.providerFactory.subscribe('mediaProvider', function (name, provider) {
            return _this.setMediaProvider(provider);
        });
        this.errorReporter = options.errorReporter || new utils_1.ErrorReporter();
    }
    MediaPluginState.prototype.subscribe = function (cb) {
        this.pluginStateChangeSubscribers.push(cb);
        cb(this);
    };
    MediaPluginState.prototype.unsubscribe = function (cb) {
        var pluginStateChangeSubscribers = this.pluginStateChangeSubscribers;
        var pos = pluginStateChangeSubscribers.indexOf(cb);
        if (pos > -1) {
            pluginStateChangeSubscribers.splice(pos, 1);
        }
    };
    MediaPluginState.prototype.updateElement = function () {
        var newElement;
        if (this.selectedMediaNode() && this.isMediaSingle()) {
            newElement = this.getDomElement(this.view.docView);
        }
        if (this.element !== newElement) {
            this.element = newElement;
            this.notifyPluginStateSubscribers();
        }
    };
    MediaPluginState.prototype.updateUploadState = function () {
        var _this = this;
        if (!this.waitForMediaUpload) {
            return;
        }
        if (this.updateUploadStateDebounce) {
            clearTimeout(this.updateUploadStateDebounce);
        }
        this.updateUploadStateDebounce = setTimeout(function () {
            _this.updateUploadStateDebounce = null;
            _this.allUploadsFinished = false;
            _this.notifyPluginStateSubscribers();
            _this.waitForPendingTasks().then(function () {
                _this.allUploadsFinished = true;
                _this.notifyPluginStateSubscribers();
            });
        }, 0);
    };
    MediaPluginState.prototype.updateLayout = function (layout) {
        this.layout = layout;
        this.notifyPluginStateSubscribers();
    };
    MediaPluginState.prototype.isMediaSingle = function () {
        var _a = this.view.state, selection = _a.selection, schema = _a.schema;
        return selection.$from.parent.type === schema.nodes.mediaSingle;
    };
    MediaPluginState.prototype.getDomElement = function (docView) {
        var from = this.view.state.selection.from;
        if (this.selectedMediaNode()) {
            var _a = docView.domFromPos(from), node = _a.node, offset = _a.offset;
            if (!node.childNodes.length) {
                return node.parentNode;
            }
            return node.childNodes[offset].querySelector('.wrapper');
        }
    };
    MediaPluginState.prototype.setView = function (view) {
        this.view = view;
    };
    /**
     * This is called when media node is removed from media group node view
     */
    MediaPluginState.prototype.cancelInFlightUpload = function (id) {
        var mediaNodeWithPos = this.findMediaNode(id);
        if (!mediaNodeWithPos) {
            return;
        }
        var status = this.getMediaNodeStateStatus(id);
        switch (status) {
            case 'uploading':
            case 'processing':
                this.pickers.forEach(function (picker) { return picker.cancel(id); });
        }
    };
    MediaPluginState.prototype.destroy = function () {
        if (this.destroyed) {
            return;
        }
        this.destroyed = true;
        var mediaNodes = this.mediaNodes;
        mediaNodes.splice(0, mediaNodes.length);
        this.removeOnCloseListener();
        this.destroyPickers();
    };
    MediaPluginState.prototype.initPickers = function (uploadParams, context, Picker) {
        var _this = this;
        if (this.destroyed) {
            return;
        }
        var _a = this, errorReporter = _a.errorReporter, pickers = _a.pickers, stateManager = _a.stateManager;
        // create pickers if they don't exist, re-use otherwise
        if (!pickers.length) {
            var pickerFacadeConfig = {
                context: context,
                stateManager: stateManager,
                errorReporter: errorReporter,
            };
            var defaultPickerConfig = {
                uploadParams: uploadParams,
            };
            if (this.options.customMediaPicker) {
                pickers.push((this.customPicker = new Picker('customMediaPicker', pickerFacadeConfig, this.options.customMediaPicker)));
            }
            else {
                if (context.config.userAuthProvider) {
                    pickers.push((this.popupPicker = new Picker('popup', pickerFacadeConfig, tslib_1.__assign({ userAuthProvider: context.config.userAuthProvider }, defaultPickerConfig))));
                }
                else {
                    pickers.push((this.popupPicker = new Picker('browser', pickerFacadeConfig, defaultPickerConfig)));
                }
                pickers.push((this.binaryPicker = new Picker('binary', pickerFacadeConfig, defaultPickerConfig)));
                pickers.push((this.clipboardPicker = new Picker('clipboard', pickerFacadeConfig, defaultPickerConfig)));
                pickers.push((this.dropzonePicker = new Picker('dropzone', pickerFacadeConfig, tslib_1.__assign({ container: this.options.customDropzoneContainer, headless: true }, defaultPickerConfig))));
                this.dropzonePicker.onDrag(this.handleDrag);
                this.removeOnCloseListener = this.popupPicker.onClose(this.onPopupPickerClose);
            }
            pickers.forEach(function (picker) {
                picker.onNewMedia(_this.insertFiles);
                picker.onNewMedia(_this.trackNewMediaEvent(picker.type));
            });
        }
        if (this.popupPicker) {
            this.popupPicker.hide();
        }
        // set new upload params for the pickers
        pickers.forEach(function (picker) { return picker.setUploadParams(uploadParams); });
    };
    MediaPluginState.prototype.trackNewMediaEvent = function (pickerType) {
        return function (mediaStates) {
            mediaStates.forEach(function (mediaState) {
                service_1.default.trackEvent("atlassian.editor.media.file." + pickerType, mediaState.fileMimeType
                    ? { fileMimeType: mediaState.fileMimeType }
                    : {});
            });
        };
    };
    MediaPluginState.prototype.collectionFromProvider = function () {
        return (this.mediaProvider &&
            this.mediaProvider.uploadParams &&
            this.mediaProvider.uploadParams.collection);
    };
    MediaPluginState.prototype.selectedMediaNode = function () {
        var _a = this.view.state, selection = _a.selection, schema = _a.schema;
        if (selection instanceof prosemirror_state_1.NodeSelection &&
            selection.node.type === schema.nodes.media) {
            var node = selection.node;
            return node;
        }
    };
    MediaPluginState.prototype.isLayoutSupported = function () {
        var _a = this.view.state, selection = _a.selection, schema = _a.schema;
        if (selection instanceof prosemirror_state_1.NodeSelection &&
            selection.node.type === schema.nodes.media) {
            return (!prosemirror_utils_1.hasParentNodeOfType(schema.nodes.bodiedExtension)(selection) &&
                !prosemirror_utils_1.hasParentNodeOfType(schema.nodes.layoutSection)(selection));
        }
        return false;
    };
    return MediaPluginState;
}());
exports.MediaPluginState = MediaPluginState;
var createDropPlaceholder = function (editorAppearance) {
    var dropPlaceholder = document.createElement('div');
    if (editorAppearance === 'full-page') {
        ReactDOM.render(React.createElement(DropPlaceholder_1.default, { type: 'single' }), dropPlaceholder);
    }
    else {
        ReactDOM.render(React.createElement(DropPlaceholder_1.default), dropPlaceholder);
    }
    return dropPlaceholder;
};
exports.stateKey = new prosemirror_state_1.PluginKey('mediaPlugin');
exports.getMediaPluginState = function (state) {
    return exports.stateKey.getState(state);
};
exports.createPlugin = function (schema, options, dispatch, editorAppearance) {
    var dropPlaceholder = createDropPlaceholder(editorAppearance);
    return new prosemirror_state_1.Plugin({
        state: {
            init: function (config, state) {
                return new MediaPluginState(state, options, editorAppearance);
            },
            apply: function (tr, pluginState, oldState, newState) {
                pluginState.detectLinkRangesInSteps(tr, oldState);
                // Ignore creating link cards during link editing
                var link = oldState.schema.marks.link;
                var _a = newState.selection.$from, nodeAfter = _a.nodeAfter, nodeBefore = _a.nodeBefore, parent = _a.parent;
                if ((nodeAfter && link.isInSet(nodeAfter.marks)) ||
                    (nodeBefore && link.isInSet(nodeBefore.marks))) {
                    pluginState.ignoreLinks = true;
                }
                // Update Layout
                var mediaSingle = oldState.schema.nodes.mediaSingle;
                if (parent.type === mediaSingle) {
                    pluginState.layout = parent.attrs.layout;
                }
                var meta = tr.getMeta(exports.stateKey);
                if (meta && dispatch) {
                    var showMediaPicker = pluginState.showMediaPicker;
                    var allowsUploads = meta.allowsUploads;
                    dispatch(exports.stateKey, { allowsUploads: allowsUploads, showMediaPicker: showMediaPicker });
                }
                // NOTE: We're not calling passing new state to the Editor, because we depend on the view.state reference
                //       throughout the lifetime of view. We injected the view into the plugin state, because we dispatch()
                //       transformations from within the plugin state (i.e. when adding a new file).
                return pluginState;
            },
        },
        key: exports.stateKey,
        view: function (view) {
            var pluginState = exports.getMediaPluginState(view.state);
            pluginState.setView(view);
            pluginState.updateElement();
            return {
                update: function () {
                    pluginState.updateUploadState();
                    pluginState.insertLinks();
                    pluginState.updateElement();
                },
            };
        },
        props: {
            decorations: function (state) {
                var pluginState = exports.getMediaPluginState(state);
                if (!pluginState.showDropzone) {
                    return;
                }
                var schema = state.schema, $anchor = state.selection.$anchor;
                // When a media is already selected
                if (state.selection instanceof prosemirror_state_1.NodeSelection) {
                    return;
                }
                var pos = $anchor.pos;
                if ($anchor.parent.type !== schema.nodes.paragraph &&
                    $anchor.parent.type !== schema.nodes.codeBlock) {
                    pos = prosemirror_transform_1.insertPoint(state.doc, pos, schema.nodes.mediaGroup);
                }
                if (pos === null || pos === undefined) {
                    return;
                }
                var dropPlaceholders = [
                    prosemirror_view_1.Decoration.widget(pos, dropPlaceholder, { key: 'drop-placeholder' }),
                ];
                return prosemirror_view_1.DecorationSet.create(state.doc, dropPlaceholders);
            },
            nodeViews: options.nodeViews,
            handleTextInput: function (view, from, to, text) {
                exports.getMediaPluginState(view.state).splitMediaGroup();
                return false;
            },
        },
    });
};
//# sourceMappingURL=main.js.map