"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var editor_common_1 = require("@atlaskit/editor-common");
var isCodeBlock = function (node) { return node.type.name === 'codeBlock'; };
var isMediaNode = function (node) { return node.type.name === 'media'; };
var isMentionNode = function (node) { return node.type.name === 'mention'; };
var isParagraph = function (node) { return node.type.name === 'paragraph'; };
var isTable = function (node) { return node.type.name === 'table'; };
var isTableCell = function (node) { return node.type.name === 'tableCell'; };
var isTableHeader = function (node) { return node.type.name === 'tableHeader'; };
var toJSON = function (node) {
    var obj = { type: node.type.name };
    if (isMediaNode(node)) {
        obj.attrs = editor_common_1.mediaToJSON(node).attrs;
    }
    else if (isMentionNode(node)) {
        obj.attrs = editor_common_1.mentionToJSON(node).attrs;
    }
    else if (isCodeBlock(node)) {
        obj.attrs = editor_common_1.codeBlockToJSON(node).attrs;
    }
    else if (isTable(node)) {
        obj.attrs = editor_common_1.tableToJSON(node).attrs;
    }
    else if (isTableCell(node)) {
        obj.attrs = editor_common_1.toJSONTableCell(node).attrs;
    }
    else if (isTableHeader(node)) {
        obj.attrs = editor_common_1.toJSONTableHeader(node).attrs;
    }
    else if (Object.keys(node.attrs).length) {
        obj.attrs = node.attrs;
    }
    if (node.isText) {
        obj.text = node.textContent;
    }
    else {
        node.content.forEach(function (child) {
            obj.content = obj.content || [];
            obj.content.push(toJSON(child));
        });
    }
    if (isParagraph(node)) {
        // Paragraph shall always has a content
        obj.content = obj.content || [];
    }
    if (node.marks.length) {
        obj.marks = node.marks.map(function (n) { return n.toJSON(); });
    }
    return obj;
};
var JSONTransformer = /** @class */ (function () {
    function JSONTransformer() {
    }
    JSONTransformer.prototype.encode = function (node) {
        var content = [];
        node.content.forEach(function (child) {
            content.push(toJSON(child));
        });
        return {
            version: 1,
            type: 'doc',
            content: content,
        };
    };
    JSONTransformer.prototype.parse = function (content) {
        if (content.type !== 'doc') {
            throw new Error('Expected content format to be ADF');
        }
        var doc = editor_common_1.defaultSchema.nodeFromJSON(content);
        doc.check();
        return doc;
    };
    return JSONTransformer;
}());
exports.JSONTransformer = JSONTransformer;
//# sourceMappingURL=index.js.map