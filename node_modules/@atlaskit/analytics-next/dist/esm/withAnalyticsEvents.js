import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _typeof from 'babel-runtime/helpers/typeof';
import _extends from 'babel-runtime/helpers/extends';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React, { Component } from 'react';
import PropTypes from 'prop-types';

import UIAnalyticsEvent from './UIAnalyticsEvent';


export default function withAnalyticsEvents() {
  var createEventMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return function (WrappedComponent) {
    var _class, _temp, _initialiseProps;

    return _temp = _class = function (_Component) {
      _inherits(WithAnalyticsEvents, _Component);

      // Store references to the original and patched event props so we can determine when to update
      // the patched props
      function WithAnalyticsEvents(props) {
        _classCallCheck(this, WithAnalyticsEvents);

        var _this = _possibleConstructorReturn(this, (WithAnalyticsEvents.__proto__ || _Object$getPrototypeOf(WithAnalyticsEvents)).call(this, props));

        _initialiseProps.call(_this);

        _Object$keys(createEventMap).forEach(function (p) {
          _this.originalEventProps[p] = props[p];
        });
        _this.patchedEventProps = _this.mapCreateEventsToProps(_Object$keys(createEventMap), props);
        return _this;
      }

      // Update patched event props only if the original props have changed


      _createClass(WithAnalyticsEvents, [{
        key: 'render',
        value: function render() {
          var patchedEventProps = this.updatePatchedEventProps(this.props);
          var props = _extends({}, this.props, patchedEventProps);
          return React.createElement(WrappedComponent, _extends({}, props, {
            createAnalyticsEvent: this.createAnalyticsEvent
          }));
        }
      }]);

      return WithAnalyticsEvents;
    }(Component), _class.displayName = 'WithAnalyticsEvents(' + (WrappedComponent.displayName || WrappedComponent.name) + ')', _class.contextTypes = {
      getAtlaskitAnalyticsEventHandlers: PropTypes.func,
      getAtlaskitAnalyticsContext: PropTypes.func
    }, _initialiseProps = function _initialiseProps() {
      var _this2 = this;

      this.originalEventProps = {};
      this.patchedEventProps = {};

      this.updatePatchedEventProps = function (props) {
        var changedPropCallbacks = _Object$keys(createEventMap).filter(function (p) {
          return _this2.originalEventProps[p] !== props[p];
        });
        if (changedPropCallbacks.length > 0) {
          _this2.patchedEventProps = _extends({}, _this2.patchedEventProps, _this2.mapCreateEventsToProps(changedPropCallbacks, props));
          changedPropCallbacks.forEach(function (p) {
            _this2.originalEventProps[p] = props[p];
          });
        }

        return _this2.patchedEventProps;
      };

      this.createAnalyticsEvent = function (payload) {
        var _context = _this2.context,
            getAtlaskitAnalyticsEventHandlers = _context.getAtlaskitAnalyticsEventHandlers,
            getAtlaskitAnalyticsContext = _context.getAtlaskitAnalyticsContext;

        var context = typeof getAtlaskitAnalyticsContext === 'function' && getAtlaskitAnalyticsContext() || [];
        var handlers = typeof getAtlaskitAnalyticsEventHandlers === 'function' && getAtlaskitAnalyticsEventHandlers() || [];
        return new UIAnalyticsEvent({ context: context, handlers: handlers, payload: payload });
      };

      this.mapCreateEventsToProps = function (changedPropNames, props) {
        return changedPropNames.reduce(function (modified, propCallbackName) {
          var eventCreator = createEventMap[propCallbackName];
          var providedCallback = props[propCallbackName];
          if (!['object', 'function'].includes(typeof eventCreator === 'undefined' ? 'undefined' : _typeof(eventCreator))) {
            return modified;
          }
          var modifiedCallback = function modifiedCallback() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var analyticsEvent = typeof eventCreator === 'function' ? eventCreator(_this2.createAnalyticsEvent, props) : _this2.createAnalyticsEvent(eventCreator);

            if (providedCallback) {
              providedCallback.apply(undefined, args.concat([analyticsEvent]));
            }
          };
          return _extends({}, modified, _defineProperty({}, propCallbackName, modifiedCallback));
        }, {});
      };
    }, _temp;
  };
}