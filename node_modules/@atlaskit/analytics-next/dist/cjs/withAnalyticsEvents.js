'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends3 = require('babel-runtime/helpers/extends');

var _extends4 = _interopRequireDefault(_extends3);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

exports.default = withAnalyticsEvents;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _UIAnalyticsEvent = require('./UIAnalyticsEvent');

var _UIAnalyticsEvent2 = _interopRequireDefault(_UIAnalyticsEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function withAnalyticsEvents() {
  var createEventMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return function (WrappedComponent) {
    var _class, _temp, _initialiseProps;

    return _temp = _class = function (_Component) {
      (0, _inherits3.default)(WithAnalyticsEvents, _Component);

      // Store references to the original and patched event props so we can determine when to update
      // the patched props
      function WithAnalyticsEvents(props) {
        (0, _classCallCheck3.default)(this, WithAnalyticsEvents);

        var _this = (0, _possibleConstructorReturn3.default)(this, (WithAnalyticsEvents.__proto__ || (0, _getPrototypeOf2.default)(WithAnalyticsEvents)).call(this, props));

        _initialiseProps.call(_this);

        (0, _keys2.default)(createEventMap).forEach(function (p) {
          _this.originalEventProps[p] = props[p];
        });
        _this.patchedEventProps = _this.mapCreateEventsToProps((0, _keys2.default)(createEventMap), props);
        return _this;
      }

      // Update patched event props only if the original props have changed


      (0, _createClass3.default)(WithAnalyticsEvents, [{
        key: 'render',
        value: function render() {
          var patchedEventProps = this.updatePatchedEventProps(this.props);
          var props = (0, _extends4.default)({}, this.props, patchedEventProps);
          return _react2.default.createElement(WrappedComponent, (0, _extends4.default)({}, props, {
            createAnalyticsEvent: this.createAnalyticsEvent
          }));
        }
      }]);
      return WithAnalyticsEvents;
    }(_react.Component), _class.displayName = 'WithAnalyticsEvents(' + (WrappedComponent.displayName || WrappedComponent.name) + ')', _class.contextTypes = {
      getAtlaskitAnalyticsEventHandlers: _propTypes2.default.func,
      getAtlaskitAnalyticsContext: _propTypes2.default.func
    }, _initialiseProps = function _initialiseProps() {
      var _this2 = this;

      this.originalEventProps = {};
      this.patchedEventProps = {};

      this.updatePatchedEventProps = function (props) {
        var changedPropCallbacks = (0, _keys2.default)(createEventMap).filter(function (p) {
          return _this2.originalEventProps[p] !== props[p];
        });
        if (changedPropCallbacks.length > 0) {
          _this2.patchedEventProps = (0, _extends4.default)({}, _this2.patchedEventProps, _this2.mapCreateEventsToProps(changedPropCallbacks, props));
          changedPropCallbacks.forEach(function (p) {
            _this2.originalEventProps[p] = props[p];
          });
        }

        return _this2.patchedEventProps;
      };

      this.createAnalyticsEvent = function (payload) {
        var _context = _this2.context,
            getAtlaskitAnalyticsEventHandlers = _context.getAtlaskitAnalyticsEventHandlers,
            getAtlaskitAnalyticsContext = _context.getAtlaskitAnalyticsContext;

        var context = typeof getAtlaskitAnalyticsContext === 'function' && getAtlaskitAnalyticsContext() || [];
        var handlers = typeof getAtlaskitAnalyticsEventHandlers === 'function' && getAtlaskitAnalyticsEventHandlers() || [];
        return new _UIAnalyticsEvent2.default({ context: context, handlers: handlers, payload: payload });
      };

      this.mapCreateEventsToProps = function (changedPropNames, props) {
        return changedPropNames.reduce(function (modified, propCallbackName) {
          var eventCreator = createEventMap[propCallbackName];
          var providedCallback = props[propCallbackName];
          if (!['object', 'function'].includes(typeof eventCreator === 'undefined' ? 'undefined' : (0, _typeof3.default)(eventCreator))) {
            return modified;
          }
          var modifiedCallback = function modifiedCallback() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            var analyticsEvent = typeof eventCreator === 'function' ? eventCreator(_this2.createAnalyticsEvent, props) : _this2.createAnalyticsEvent(eventCreator);

            if (providedCallback) {
              providedCallback.apply(undefined, args.concat([analyticsEvent]));
            }
          };
          return (0, _extends4.default)({}, modified, (0, _defineProperty3.default)({}, propCallbackName, modifiedCallback));
        }, {});
      };
    }, _temp;
  };
}